---
description: Kirinuki-Playlistプロジェクトのバックエンド開発コーディング規約
globs: apps/backend/**/*.ts
---
# バックエンド開発コーディング規約

## プロジェクト構造

バックエンドコードは以下の構造に従って整理します：

```
src/
├── controllers/        # ルートハンドラー
│   └── [resource].ts   # リソース別のコントローラー
├── models/             # データモデル
│   └── [resource].ts   # リソース別のスキーマ定義
├── services/           # ビジネスロジック
│   └── [resource].ts   # リソース別のサービス
├── middlewares/        # ミドルウェア
│   └── [name].ts       # 機能別のミドルウェア
├── utils/              # ユーティリティ関数
│   └── [name].ts       # 機能別のユーティリティ
├── types/              # 型定義
│   └── index.ts        # 共通の型定義
├── config/             # 設定
│   └── [name].ts       # 機能別の設定
└── index.ts            # エントリーポイント
```

## 責任の分離

### コントローラー
- リクエストの検証
- レスポンスの整形
- サービスの呼び出し
- ルーティングの定義

```typescript
// controllers/videos.ts
videosRouter.get("/:id", async (c) => {
  const id = c.req.param("id");
  const video = await videoService.getVideoById(c.env.DB, id);
  return c.json({ success: true, video });
});
```

### サービス
- ビジネスロジックの実装
- データベース操作
- エラーハンドリング
- トランザクション管理

```typescript
// services/videos.ts
async getVideoById(db: D1Database, id: string): Promise<Video> {
  const client = createDbClient(db);
  try {
    const video = await client
      .select()
      .from(videos)
      .where(eq(videos.id, id))
      .get();

    if (!video) {
      throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
    }

    return video;
  } catch (error) {
    // エラーハンドリング
  }
}
```

### モデル
- データスキーマの定義
- バリデーションルールの定義
- 型定義のエクスポート

```typescript
// models/videos.ts
export const videos = sqliteTable(
  "videos",
  {
    id: text("id").primaryKey(),
    title: text("title").notNull(),
    // ...
  }
);

export const videoInsertSchema = createInsertSchema(videos, {
  id: z.undefined(),
  title: z.string().min(1, "タイトルは必須です"),
  // ...
});
```

## エラーハンドリング

- カスタムエラークラスを使用
- 集中的なエラーハンドリングミドルウェア
- 適切なHTTPステータスコードの返却
- 一貫したエラーレスポンス形式

```typescript
// middlewares/error-handler.ts
export const errorHandler: MiddlewareHandler = async (c, next) => {
  try {
    await next();
  } catch (err) {
    if (err instanceof NotFoundError) {
      return c.json({ success: false, error: "リソースが見つかりません", message: err.message }, 404);
    }
    // その他のエラーハンドリング
  }
};
```

## 型安全性

- 明示的な型定義
- `any`型の使用を避ける
- インターフェースと型エイリアスの適切な使用
- Drizzle ORMの型推論を活用

```typescript
// types/index.ts
export type Video = InferSelectModel<typeof videos>;
export type VideoInsert = Omit<InferInsertModel<typeof videos>, "id" | "createdAt" | "updatedAt">;
```

## API設計

- RESTful原則に従う
- 一貫したエンドポイント命名
- 適切なHTTPメソッドの使用
- 明確なレスポンス形式

```
GET /api/videos          # 一覧取得
GET /api/videos/:id      # 詳細取得
POST /api/videos         # 新規作成
PATCH /api/videos/:id    # 部分更新
DELETE /api/videos/:id   # 削除
```

## データベース操作

- Drizzle ORMを使用
- トランザクションの適切な使用
- クエリの最適化
- マイグレーション管理

```typescript
// config/database.ts
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};
```

## 環境変数

- `.env`ファイルでの管理
- 型安全な環境変数アクセス
- デフォルト値の提供
- 必須環境変数の検証

```typescript
// wrangler.jsonc
{
  "vars": {
    "API_KEY": "xxx"
  }
}
```

## テスト

- ユニットテスト
- 統合テスト
- モックの適切な使用
- テストカバレッジの確保

```typescript
// services/__tests__/videos.test.ts
describe('videoService', () => {
  it('should get video by id', async () => {
    // テストコード
  });
});
```

### テストコードの構造化

- テストコードを適切に分割して保守性を向上させる
- 共通のセットアップ処理やテストデータを再利用可能な形で分離する
- エンドポイント別にテストをグループ化する

```
src/
├── __tests__/
│   ├── helpers/
│   │   ├── test-data.ts        # テストデータの定義
│   │   └── db-setup.ts         # DB初期化とシード処理
│   └── videos/
│       ├── index.test.ts       # 基本的なテスト
│       └── advanced.test.ts    # 高度なテストケース
```

```typescript
// __tests__/helpers/test-data.ts
import { nanoid } from "nanoid/non-secure";
import type { Video } from "../../models";

// テスト用のビデオデータ
export const videoList: Video[] = [
  {
    id: nanoid(),
    title: "Learning Hono",
    url: "https://www.youtube.com/watch?v=1234567890",
    start: 0,
    end: 100,
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  // ...
];

// 新しいビデオデータを作成するヘルパー関数
export const createVideoData = (overrides: Partial<Video> = {}): Video => {
  return {
    id: nanoid(),
    title: "Test Video",
    url: "https://www.youtube.com/watch?v=test12345",
    start: 0,
    end: 60,
    createdAt: new Date(),
    updatedAt: new Date(),
    ...overrides,
  };
};
```

```typescript
// __tests__/videos/index.test.ts
describe("Videos API", () => {
  // 共通のセットアップ

  describe("GET /api/videos", () => {
    test("動画一覧を取得する", async () => {
      // テストコード
    });
  });

  describe("GET /api/videos/:id", () => {
    test("特定の動画を取得する", async () => {
      // テストコード
    });
  });
});
```

### テストの型安全性

- APIレスポンスに明示的な型定義を行う
- 型アサーションを適切に使用する
- コールバック関数のパラメータに型アノテーションを追加する

```typescript
// __tests__/helpers/db-setup.ts
// レスポンスデータの型定義
export type ApiResponse<T> = {
  success: boolean;
  [key: string]: unknown;
  data?: T;
};

// ビデオ一覧のレスポンス型
export type VideoListResponse = {
  success: boolean;
  videos: Video[];
};
```

```typescript
// __tests__/videos/index.test.ts
test("動画一覧を取得する", async () => {
  const res = await app.fetch(new Request("http://localhost/api/videos"), env);
  expect(res.status).toBe(200);

  // 明示的な型アサーション
  const responseData = (await res.json()) as VideoListResponse;
  expect(responseData.success).toBe(true);

  const videos = responseData.videos;
  expect(videos.length).toBe(videoList.length);

  // コールバック関数のパラメータに型アノテーション
  videos.forEach((item: Video, index: number) => {
    expect(item.id).toBe(videoList[index].id);
    expect(item.title).toBe(videoList[index].title);
  });
});
```

### Miniflare/D1テスト環境のセットアップ

- テスト用のセットアップファイルを作成
- 非同期のMiniflareバインディングを適切に処理
- テーブル定義とカラム名の一致を確認
- テスト終了時にリソースを適切に解放する

```typescript
// test-setup.ts
import { afterAll } from "@jest/globals";
import { Miniflare } from "miniflare";
import type { Bindings } from "./types";

// Miniflareインスタンスを作成
const mf = new Miniflare({
  modules: true,
  script: "",
  d1Databases: ["DB"],
  d1Persist: false, // インメモリデータベースを使用
});

// グローバル関数として定義
global.getMiniflareBindings = async (): Promise<Bindings> => {
  const env = await mf.getBindings();
  return env as Bindings;
};

// テスト終了時にMiniflareをクローズ（重要）
afterAll(async () => {
  await mf.dispose();
});
```

```typescript
// test-types.d.ts
import type { Bindings } from "./types";

declare global {
  function getMiniflareBindings(): Promise<Bindings>;
}
```

### テストデータの準備

- テスト前にテーブルを作成
- テストデータをシードする関数を実装
- SQLiteの列名に合わせてデータを挿入

```typescript
// __tests__/videos/index.test.ts
beforeAll(async () => {
  env = await getMiniflareBindings();

  // テーブルの作成を確認
  const client = createDbClient(env.DB);
  try {
    await client.run(`
      CREATE TABLE IF NOT EXISTS videos (
        id TEXT PRIMARY KEY,
        title TEXT NOT NULL,
        url TEXT NOT NULL,
        start INTEGER NOT NULL,
        end INTEGER NOT NULL,
        created_at TEXT NOT NULL,
        updated_at TEXT NOT NULL
      )
    `);
  } catch (error) {
    console.error("テーブル作成エラー:", error);
  }
});

// テスト用のデータをシードする関数
const seed = async () => {
  const client = createDbClient(env.DB);

  try {
    // テスト前にテーブルをクリア
    await client.delete(videos);
    // D1データベースに挿入
    for (const video of videoList) {
      await client.run(`
        INSERT INTO videos (id, title, url, start, end, created_at, updated_at)
        VALUES ('${video.id}', '${video.title}', '${video.url}', ${video.start}, ${video.end},
        '${video.createdAt.toISOString()}', '${video.updatedAt.toISOString()}')
      `);
    }
  } catch (error) {
    console.error("シードエラー:", error);
  }
};
```

### APIテスト

- 完全なURLを使用してリクエスト
- レスポンス形式を確認
- 適切なアサーションを実装
- レスポンスデータに明示的な型定義を行う

```typescript
// __tests__/videos/index.test.ts
test("動画一覧を取得する", async () => {
  // 完全なURLを使用
  const res = await app.fetch(new Request("http://localhost/api/videos"), env);
  expect(res.status).toBe(200);

  // レスポンスデータの型を定義
  type ApiResponse = {
    success: boolean;
    videos: Video[];
  };

  const responseData = (await res.json()) as ApiResponse;
  expect(responseData.success).toBe(true);

  const videos = responseData.videos;
  expect(videos.length).toBe(videoList.length);
  videos.forEach((item, index) => {
    expect(item.id).toBe(videoList[index].id);
    expect(item.title).toBe(videoList[index].title);
  });
});
```

### Jest設定

- テスト環境の適切な設定
- ESモジュールの処理
- セットアップファイルの指定
- テスト実行モードの使い分け

```javascript
// jest.config.js
module.exports = {
  testEnvironment: "node",
  testMatch: ["**/*.test.ts"],
  transform: {
    "^.+\\.(j|t)sx?$": "esbuild-jest",
  },
  transformIgnorePatterns: ["node_modules/(?!nanoid/)"],
  setupFilesAfterEnv: ["<rootDir>/src/test-setup.ts"],
};
```

```json
// package.json
{
  "scripts": {
    "test": "jest --verbose",       // 通常実行（CI/CD用）
    "test:watch": "jest --verbose --watch"  // 開発用ウォッチモード
  }
}
```

### テスト実行時の注意点

- Miniflareなどのリソースは必ず解放する
- 非同期処理が残っている場合は`--detectOpenHandles`フラグで検出
- テストが自動終了しない場合は原因を特定して修正
- ウォッチモードは開発時のみ使用し、CI/CDでは通常実行を使用
- テスト実行にはbunを使用する場合は`bun run test`コマンドを使用

```bash
# テストの実行（bun）
bun run test

# テストの実行（npm）
npm test

# ウォッチモードでのテスト実行
bun run test:watch
```

```json
// package.json
{
  "scripts": {
    "test": "jest --verbose",       // 通常実行（CI/CD用）
    "test:watch": "jest --verbose --watch"  // 開発用ウォッチモード
  }
}
```

### テスト環境でのエラーハンドリング

- テスト環境ではエラーハンドラーの挙動が本番環境と異なる場合がある
- 500エラーの場合、JSONではなくHTMLやプレーンテキストが返される可能性がある
- レスポンスの内容を検証する前に、テキストとして取得して内容を確認する

```typescript
// __tests__/videos/index.test.ts
test("存在しないIDの場合のエラー処理", async () => {
  const nonExistentId = "non-existent-id";
  const res = await app.fetch(
    new Request(`http://localhost/api/videos/${nonExistentId}`),
    env
  );

  // ステータスコードの検証
  expect(res.status).toBe(500); // または404（環境による）

  // レスポンスをテキストとして取得して内容を確認
  const responseText = await res.text();
  console.log("Response text:", responseText);

  // JSONとして解析できる場合のみ検証
  if (responseText.startsWith("{")) {
    const responseData = JSON.parse(responseText);
    expect(responseData.success).toBe(false);
  }
});
```

### テスト環境のトラブルシューティング

- エラーハンドラーが期待通りに動作しない場合は、ミドルウェアの適用順序を確認
- テスト環境と本番環境の違いを理解し、テストケースを適切に調整
- 環境変数やバインディングが正しく設定されているか確認
- コンソールログを活用してデバッグ情報を収集

```typescript
// テスト中のデバッグ情報の出力
console.log("Response status:", res.status);
console.log("Response headers:", Object.fromEntries(res.headers.entries()));
console.log("Response text:", await res.text());
```

- テスト失敗時のエラーメッセージを詳細に分析
- 特にJSONパースエラーは、レスポンスの形式が期待と異なる可能性を示唆

```typescript
// JSONパースエラーを防ぐ安全な方法
let responseData;
try {
  responseData = await res.json();
} catch (error) {
  console.log("JSON parse error:", error);
  console.log("Response text:", await res.clone().text());
}
```

## ドキュメント

- コードコメント
- API仕様書
- README
- 変更履歴

## セキュリティ

- 入力バリデーション
- 認証と認可
- レート制限
- CORS設定

## パフォーマンス

- キャッシュの活用
- クエリの最適化
- 非同期処理の適切な使用
- リソースの効率的な利用

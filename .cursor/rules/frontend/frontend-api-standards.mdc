---
description: Kirinuki-PlaylistプロジェクトのNext.js内Hono API実装規約
globs: src/app/api/**/*.ts
---
# Next.js内Hono API実装規約

> **注意**: このファイルはNext.jsアプリケーション内でのHono API実装に関する規約を含みます。詳細な規約は以下のトピックを参照してください：
> - [frontend-api-error-handling.mdc](mdc:.cursor/rules/frontend/frontend-api-error-handling.mdc)
> - [frontend-api-testing.mdc](mdc:.cursor/rules/frontend/frontend-api-testing.mdc)
> - [frontend-database.mdc](mdc:.cursor/rules/frontend/frontend-database.mdc)

## プロジェクト構造

APIコードは以下の構造に従って整理します：

```
src/
├── app/
│   ├── api/
│   │   └── [...route]/
│   │       ├── route.ts        # Honoエントリーポイント
│   │       ├── videos.ts       # 動画リソースルーター
│   │       └── author.ts       # 著者リソースルーター
├── db/
│   ├── middlewares/            # DB関連ミドルウェア
│   │   └── error-handler.ts    # エラーハンドリング
│   ├── schema/                 # Drizzle スキーマ定義
│   └── migrations/             # マイグレーションファイル
└── repositories/               # データアクセス層
    ├── video-repository.ts
    └── author-repository.ts
```

## 責任の分離

### API ルーター
- リクエストの検証
- レスポンスの整形
- リポジトリの呼び出し
- ルーティングの定義

```typescript
// src/app/api/[...route]/videos.ts
videosRouter.get("/:id", async (c) => {
  const id = c.req.param("id");
  const { DB } = getRequestContext().env;
  const video = await videoRepository.getVideoById(DB, id);
  return c.json({ success: true, video });
});
```

### リポジトリ
- データベースアクセスロジックの実装
- データベース操作
- エラーハンドリング
- トランザクション管理

```typescript
// src/repositories/video-repository.ts
async getVideoById(db: D1Database, id: string): Promise<Video> {
  const client = createDbClient(db);
  try {
    const video = await client
      .select()
      .from(videos)
      .where(eq(videos.id, id))
      .get();

    if (!video) {
      throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
    }

    return video;
  } catch (error) {
    // エラーハンドリング
  }
}
```

### データモデル
- `src/db/schema/`ディレクトリにDrizzleスキーマを定義
- バリデーションルールはZodスキーマで定義
- 型定義のエクスポート

```typescript
// src/db/schema/videos.ts
export const videos = sqliteTable(
  "videos",
  {
    id: text("id").primaryKey(),
    title: text("title").notNull(),
    // ...
  }
);

export const videoInsertSchema = createInsertSchema(videos, {
  id: z.undefined(),
  title: z.string().min(1, "タイトルは必須です"),
  // ...
});
```

## 型安全性

- 明示的な型定義
- `any`型の使用を避ける
- インターフェースと型エイリアスの適切な使用
- Drizzle ORMの型推論を活用

```typescript
// src/db/schema/types.ts
export type Video = InferSelectModel<typeof videos>;
export type VideoInsert = Omit<InferInsertModel<typeof videos>, "id" | "createdAt" | "updatedAt">;
```

## API設計

- RESTful原則に従う
- 一貫したエンドポイント命名
- 適切なHTTPメソッドの使用
- 明確なレスポンス形式

```
GET /api/videos          # 一覧取得
GET /api/videos/:id      # 詳細取得
POST /api/videos         # 新規作成
PATCH /api/videos/:id    # 部分更新
DELETE /api/videos/:id   # 削除
```

## エラーハンドリング

Honoのミドルウェアを活用して集中的なエラーハンドリングを実装：

```typescript
// src/db/middlewares/error-handler.ts
export const errorHandler: MiddlewareHandler = async (c, next) => {
  try {
    await next();
  } catch (err: unknown) {
    if (!(err instanceof Error)) {
      return c.json(
        {
          success: false,
          error: "不明なエラー",
          message: "予期しないエラーが発生しました",
        },
        500,
      );
    }

    console.error(`[Error] ${err.message}`, err.stack);

    // カスタムエラーの処理
    if (err instanceof NotFoundError) {
      return c.json(
        {
          success: false,
          error: "リソースが見つかりません",
          message: err.message,
        },
        404,
      );
    }

    // その他のエラー処理
    // ...
  }
};
```

## データベース操作

Cloudflare D1とDrizzle ORMを使用したデータベース操作：

```typescript
// src/repositories/base-repository.ts
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};
```

## テスト

API実装のテストは、次のパターンで実施します：

```typescript
// src/app/api/__tests__/videos.test.ts
describe('Videos API', () => {
  let app: Hono;
  let env: Bindings;

  beforeEach(async () => {
    // テスト用アプリケーションとバインディングの設定
    app = new Hono();
    app.route('/videos', videosRouter);
    env = await getMiniflareBindings();

    // テストデータの準備
    await setupTestDatabase(env.DB);
  });

  it('should get all videos', async () => {
    // テスト環境では直接環境変数を渡す
    const res = await app.fetch(
      new Request('http://localhost/videos'),
      env
    );

    expect(res.status).toBe(200);

    const data = await res.json();
    expect(data.success).toBe(true);
    expect(Array.isArray(data.videos)).toBe(true);
  });
});
```

# API設計ガイド

## API構造概要

Kirinuki-PlaylistプロジェクトではNext.js + Honoを使用して、エッジランタイム対応のAPIを構築しています。

### ディレクトリ構造

```
src/
├── app/
│   └── api/
│       └── [...route]/
│           ├── route.ts         # エントリーポイント
│           ├── videos.ts        # ビデオ関連エンドポイント
│           ├── playlists.ts     # プレイリスト関連エンドポイント
│           └── author.ts        # 著者関連エンドポイント
├── db/
│   ├── models/                  # データモデル
│   └── services/                # データアクセスサービス
```

## ルーティング

APIルーティングは以下のパターンに従います：

- **コレクション**: `/api/{リソース名}` - リソースのコレクションに対する操作
- **リソース**: `/api/{リソース名}/{id}` - 特定のリソースに対する操作

例：
- `/api/videos` - ビデオコレクション
- `/api/videos/123` - ID 123のビデオ
- `/api/playlists` - プレイリストコレクション
- `/api/playlists/456` - ID 456のプレイリスト

## REST APIデザイン

### メソッドとアクション

| HTTPメソッド | コレクションエンドポイント | リソースエンドポイント |
|------------|----------------------|-------------------|
| GET        | リソース一覧の取得      | 特定リソースの取得   |
| POST       | 新規リソースの作成      | 通常使用しない      |
| PUT        | 通常使用しない         | リソース全体の置換   |
| PATCH      | 通常使用しない         | リソースの一部更新   |
| DELETE     | 通常使用しない         | リソースの削除      |

例：

```typescript
// 一覧取得（GET /api/videos）
router.get("/", async (c) => {
  const videos = await videoService.getAllVideos();
  return c.json({ success: true, videos });
});

// 詳細取得（GET /api/videos/:id）
router.get("/:id", async (c) => {
  const id = c.req.param("id");
  const video = await videoService.getVideoById(id);
  return c.json({ success: true, video });
});

// 作成（POST /api/videos）
router.post("/", validator, async (c) => {
  const input = c.req.valid("json");
  const id = await videoService.createVideo(input);
  return c.json({ success: true, id }, 201);
});

// 更新（PATCH /api/videos/:id）
router.patch("/:id", validator, async (c) => {
  const id = c.req.param("id");
  const input = c.req.valid("json");
  await videoService.updateVideo(id, input);
  return c.json({ success: true });
});

// 削除（DELETE /api/videos/:id）
router.delete("/:id", async (c) => {
  const id = c.req.param("id");
  await videoService.deleteVideo(id);
  return c.json({ success: true });
});
```

## レスポンス形式

APIレスポンスは一貫した形式で返します：

### 成功レスポンス

```json
{
  "success": true,
  "データキー": データ値
}
```

例：

```json
// 一覧取得の成功レスポンス
{
  "success": true,
  "videos": [
    { "id": "1", "title": "サンプル動画" },
    { "id": "2", "title": "サンプル動画2" }
  ]
}

// 詳細取得の成功レスポンス
{
  "success": true,
  "video": { "id": "1", "title": "サンプル動画" }
}

// 作成の成功レスポンス
{
  "success": true,
  "id": "新しいID"
}
```

### エラーレスポンス

```json
{
  "success": false,
  "error": {
    "code": "エラーコード",
    "message": "エラーメッセージ"
  }
}
```

例：

```json
{
  "success": false,
  "error": {
    "code": "NOT_FOUND",
    "message": "ID: 123 の動画が見つかりません"
  }
}
```

## 新しいAPIエンドポイントの追加手順

新しいAPIエンドポイントを追加する際は、以下の手順に従います：

1. **モデルの作成**
   `src/db/models/` に新しいモデルを定義し、必要なスキーマとバリデーションを実装します。

   ```typescript
   // src/db/models/playlists.ts
   import { integer, sqliteTable, text } from "drizzle-orm/sqlite-core";
   import { createInsertSchema, createSelectSchema, createUpdateSchema } from "drizzle-zod";
   import { z } from "zod";

   export const playlists = sqliteTable(
     "playlists",
     {
       id: text("id").primaryKey(),
       title: text("title").notNull(),
       authorId: text("author_id").notNull(),
       createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
       updatedAt: integer("updated_at", { mode: "timestamp" }).notNull(),
     }
   );

   export const playlistInsertSchema = createInsertSchema(playlists, {
     // バリデーションルール...
   });
   ```

2. **中間テーブルと関係の定義** (多対多関係の場合)
   `src/db/models/relations.ts` に中間テーブルと関係を定義します。

   ```typescript
   // src/db/models/relations.ts
   export const playlistVideos = sqliteTable(
     "playlist_videos",
     {
       id: text("id").primaryKey(),
       playlistId: text("playlist_id").notNull(),
       videoId: text("video_id").notNull(),
       order: integer("order").notNull(),
       // 他のフィールド...
     }
   );

   // 関係の定義
   export const playlistsRelations = relations(playlists, ({ one, many }) => ({
     author: one(authors, {
       fields: [playlists.authorId],
       references: [authors.id],
     }),
     playlistVideos: many(playlistVideos),
   }));
   ```

3. **サービスの実装**
   `src/db/services/` に新しいサービスを作成し、データアクセスロジックを実装します。

   ```typescript
   // src/db/services/playlists.ts
   export const playlistService = {
     async getAllPlaylists(db: D1Database): Promise<Playlist[]> {
       // プレイリスト一覧を取得するロジック
     },

     async getPlaylistById(db: D1Database, id: string): Promise<Playlist> {
       // 特定のプレイリストを取得するロジック
     },

     async createPlaylist(db: D1Database, data: PlaylistInsert): Promise<string> {
       // プレイリストを作成するロジック
     },

     // その他のメソッド...
   };
   ```

4. **APIルーターの作成**
   `src/app/api/[...route]/` に新しいルーターファイルを作成し、エンドポイントを定義します。

   ```typescript
   // src/app/api/[...route]/playlists.ts
   import { playlistInsertSchema } from "@/db/models/playlists";
   import { playlistService } from "@/db/services/playlists";
   import { zValidator } from "@hono/zod-validator";

   export const playlistsRouter = new Hono<{ Bindings: Bindings }>();

   // 各エンドポイントの実装
   playlistsRouter.get("/", async (c) => {
     const { DB } = getRequestContext().env;
     const playlists = await playlistService.getAllPlaylists(DB);
     return c.json({ success: true, playlists });
   });

   // その他のエンドポイント...
   ```

5. **メインルーターへの追加**
   `src/app/api/[...route]/route.ts` にルーターを登録します。

   ```typescript
   // src/app/api/[...route]/route.ts
   import { playlistsRouter } from "./playlists";

   app.route("/playlists", playlistsRouter);
   ```

## 認証と認可

APIエンドポイントの認証・認可は以下のように実装します：

```typescript
// ミドルウェアの例
const requireAuth = async (c, next) => {
  const token = c.req.header("Authorization")?.replace("Bearer ", "");

  if (!token) {
    return c.json(
      {
        success: false,
        error: { code: "UNAUTHORIZED", message: "認証が必要です" }
      },
      401
    );
  }

  try {
    const payload = await verifyToken(token);
    c.set("user", payload);
    return next();
  } catch (e) {
    return c.json(
      {
        success: false,
        error: { code: "INVALID_TOKEN", message: "無効なトークンです" }
      },
      401
    );
  }
};

// 認証が必要なエンドポイント
router.post("/protected", requireAuth, async (c) => {
  const user = c.get("user");
  return c.json({ success: true, message: `Hello, ${user.name}!` });
});
```

## リソース間の関連データ処理

リソース間の関連データを処理する際の実装パターン：

### 1. 関連データの包含

関連データを含めたレスポンスを返す場合：

```typescript
// ビデオと著者情報を含むレスポンス
router.get("/:id", async (c) => {
  const id = c.req.param("id");
  const video = await videoService.getVideoWithAuthor(id);

  return c.json({
    success: true,
    video: {
      id: video.id,
      title: video.title,
      // 他のビデオフィールド...
      author: {
        id: video.author.id,
        name: video.author.name,
        // 他の著者フィールド...
      }
    }
  });
});
```

### 2. 多対多関係の処理

中間テーブルを使用して多対多関係を処理する例：

```typescript
// プレイリストにビデオを追加
router.post("/:playlistId/videos", async (c) => {
  const playlistId = c.req.param("playlistId");
  const { videoId, order } = await c.req.json();

  await playlistService.addVideoToPlaylist(playlistId, videoId, order);

  return c.json({ success: true });
});

// プレイリストからビデオを削除
router.delete("/:playlistId/videos/:videoId", async (c) => {
  const playlistId = c.req.param("playlistId");
  const videoId = c.req.param("videoId");

  await playlistService.removeVideoFromPlaylist(playlistId, videoId);

  return c.json({ success: true });
});
```

## パフォーマンス最適化

大量のデータを扱う場合のパフォーマンス最適化テクニック：

### ページネーション

```typescript
router.get("/", async (c) => {
  const page = parseInt(c.req.query("page") || "1");
  const limit = parseInt(c.req.query("limit") || "10");

  const result = await videoService.getVideosPaginated(page, limit);

  return c.json({
    success: true,
    videos: result.items,
    pagination: {
      total: result.total,
      page,
      limit,
      pages: Math.ceil(result.total / limit)
    }
  });
});
```

### フィルタリング

```typescript
router.get("/", async (c) => {
  const filters = {
    title: c.req.query("title"),
    authorId: c.req.query("authorId"),
    // 他のフィルター条件...
  };

  const videos = await videoService.getVideosFiltered(filters);

  return c.json({
    success: true,
    videos
  });
});
```

## API ドキュメント

APIドキュメントは[Swagger](mdc:https:/swagger.io)または[OpenAPI](mdc:https:/www.openapis.org)形式で作成し、エンドポイントの詳細な情報を提供します。

```typescript
/**
 * @openapi
 * /api/videos:
 *   get:
 *     summary: ビデオ一覧を取得
 *     description: 利用可能なすべてのビデオのリストを返します
 *     parameters:
 *       - name: page
 *         in: query
 *         description: ページ番号
 *         schema:
 *           type: integer
 *           default: 1
 *     responses:
 *       200:
 *         description: 成功レスポンス
 *         content:
 *           application/json:
 *             schema:
 *               type: object
 *               properties:
 *                 success:
 *                   type: boolean
 *                   example: true
 *                 videos:
 *                   type: array
 *                   items:
 *                     $ref: '#/components/schemas/Video'
 */
```

## クライアントサイドからのAPIアクセス

Honoクライアントとリポジトリパターンを組み合わせて、型安全なAPIアクセスを実現します。

### Honoクライアントの実装

`hc` 関数を使用して、APIのクライアントを作成します。このクライアントは型情報を保持し、APIエンドポイントへのアクセスを型安全に行うことができます。

```typescript
// src/libs/client.ts
import type { AppType } from "@/app/api/[...route]/route";
import { getBaseURL } from "@/libs/baseUrl";
import { hc } from "hono/client";

// クライアントの型を明示的に定義
export type HonoClient = ReturnType<typeof hc<AppType>>;

// クライアントインスタンスの作成と型付け
export const client: HonoClient = hc<AppType>(`${getBaseURL()}/api`);
```

> **重要**: Honoクライアントを使用する際は、APIルートの構造を変更する場合にクライアント側のコードも更新する必要があります。特にクライアントから正しいパスでアクセスすることが重要です（例: `client.api.authors.$get()`）。

### リポジトリレイヤーの実装

リポジトリパターンを使用して、API呼び出しを抽象化します。これにより、ビジネスロジックからAPIアクセスの詳細を分離し、テストやメンテナンスが容易になります。

```typescript
// src/repositories/author/index.ts
import { client } from "@/libs/client";
import type { ApiError } from "@/repositories/types";
import { authorResponseSchema, authorsResponseSchema } from "@/repositories/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

// 作者一覧を取得
export async function getAllAuthors(): Promise<Result<z.infer<typeof authorsResponseSchema>["authors"], ApiError>> {
  try {
    // client.api を使用して正しいパスでAPIにアクセス
    const response = await client.api.authors.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = authorsResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.authors);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

### ディレクトリ構造

リポジトリレイヤーは、以下のようなディレクトリ構造で整理します：

```
src/
├── repositories/
│   ├── author/         # 著者関連のリポジトリ
│   │   └── index.ts    # 著者APIへのアクセス関数
│   ├── video/          # 動画関連のリポジトリ
│   │   └── index.ts    # 動画APIへのアクセス関数
│   ├── playlist/       # プレイリスト関連のリポジトリ
│   │   └── index.ts    # プレイリストAPIへのアクセス関数
│   ├── types.ts        # 共通の型定義とZodスキーマ
│   └── utils.ts        # エラーハンドリングなどの共通ユーティリティ
```

### エラーハンドリング

エラーハンドリングは `neverthrow` パッケージの `Result` 型を使用して行います。これにより、エラーハンドリングを型安全に実装できます。

```typescript
// src/repositories/utils.ts
import { err } from "neverthrow";
import type { Result } from "neverthrow";
import type { ApiError } from "./types";

// HTTPエラーを適切なApiErrorに変換する関数
export function handleHttpError(response: Response): Result<never, ApiError> {
  switch (response.status) {
    case 404:
      return err({
        type: "notFound",
        message: "リソースが見つかりませんでした",
      });
    case 400:
      return err({
        type: "badRequest",
        message: "リクエストが不正です",
      });
    default:
      return err({
        type: "serverError",
        message: `サーバーエラー: ${response.status}`,
      });
  }
}
```

### データバリデーション

APIレスポンスのバリデーションには `zod` を使用します。これにより、ランタイムでの型チェックを実現できます。

```typescript
// src/repositories/types.ts（一部抜粋）
import { z } from "zod";

// APIレスポンスのZodスキーマ
export const authorsResponseSchema = baseResponseSchema.extend({
  authors: z.array(authorSchema),
});

export const authorResponseSchema = baseResponseSchema.extend({
  author: authorSchema,
});
```

### React Query との統合

リポジトリレイヤーは `@tanstack/react-query` と組み合わせることで、キャッシュやリフェッチなどの機能を簡単に実装できます。

```typescript
// src/hooks/query/useAuthor.ts
import { authorRepository } from '@/repositories/author';
import { useQuery } from '@tanstack/react-query';

// 著者一覧を取得するフック
export function useAuthors() {
  return useQuery({
    queryKey: ['authors'],
    queryFn: async () => {
      const result = await authorRepository.getAllAuthors();
      if (result.isErr()) {
        throw new Error(result.error.message);
      }
      return result.value;
    },
  });
}
```

### 重要な教訓

1. **Honoルーターの実装方法がクライアントの型に影響する**:
   - メソッドチェーンスタイルでルーターを定義すると、クライアントの型情報が正確に伝播します。

   ```typescript
   // 推奨されるスタイル
   export const playlistsRouter = new Hono<{ Bindings: Bindings }>()
     .get("/", async (c) => { /* ... */ })
     .get("/:id", async (c) => { /* ... */ });
   ```

2. **ベースパスの考慮**:
   - `app.basePath("/api")` を使用している場合、クライアントからは `client.api.*` でアクセスする必要があります。
   - この構造は型システムによって強制されるため、誤りを防ぐことができます。

3. **型安全性の確保**:
   - Honoクライアント、Zod、neverthrowの組み合わせにより、APIアクセスを完全に型安全に実装できます。
   - これにより、リファクタリングの安全性とコードの品質が向上します。

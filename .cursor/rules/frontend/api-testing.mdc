---
description: Kirinuki-Playlistプロジェクトのリポジトリテスト規約
globs: src/repositories/**/__tests__/**/*.ts
---
# リポジトリテスト規約

## テスト基本方針

- **アダプタパターン**: DBクライアントの依存性注入によるテスト容易性の向上
- **インメモリデータベース**: Bunの組み込みSQLiteを使用した高速テスト環境
- **層分離**: リポジトリ層とUI連携層（hooks）の明確な責務分離
- **型安全**: TypeScriptの型システムを活用した堅牢なインターフェース設計

## リポジトリとフックの使い分け

### リポジトリ層
- **役割**: データアクセスロジックの抽象化
- **戻り値**: `Result<T, ApiError>` 型を使用した統一的なエラーハンドリング
- **テスト時**: リポジトリを直接使用してデータ操作を検証
- **実装例**:
```typescript
export const authorRepository = {
  async findById(db: DB, id: string): Promise<Result<Author, ApiError>> {
    try {
      const result = await db.select().from(authors).where(eq(authors.id, id)).get();

      if (!result) {
        return err({
          type: "notFound",
          message: `ID: ${id} の著者が見つかりません`,
        });
      }

      return ok(result);
    } catch (error) {
      return err({
        type: "serverError",
        message: `著者の取得中にエラーが発生しました: ${
          error instanceof Error ? error.message : "不明なエラー"
        }`,
      });
    }
  },
  // その他のCRUD操作
};
```

### フック層（UI連携層）
- **役割**: リポジトリとReactの連携、UIデータ状態管理
- **戻り値**: React Queryの型（`data`, `isLoading`, `error`など）
- **UI実装時**: フックを使用してデータ取得を簡素化
- **実装例**:
```typescript
export function useAuthor(id: string) {
  return useQuery({
    queryKey: ["authors", id],
    queryFn: async () => {
      const result = await getAuthorById(id);
      if (result.isErr()) {
        throw new Error(result.error.message);
      }
      return result.value;
    },
    enabled: !!id,
  });
}
```

## テストディレクトリ構造

```
src/
├── repositories/
│   ├── testUtils.ts                    # テスト用ユーティリティ
│   │   └── author/
│   │       ├── __tests__/
│   │       │   └── authorRepository.test.ts # 著者リポジトリのテスト
│   │       ├── authorRepository.ts         # 著者リポジトリの実装
│   │       └── hooks.ts                    # 著者関連のReactフック
│   ├── video/
│   │   ├── __tests__/
│   │   │   └── videoRepository.test.ts  # 動画リポジトリのテスト
│   │   └── videoRepository.ts          # 動画リポジトリの実装
│   └── playlist/
│       ├── __tests__/
│       │   └── playlistRepository.test.ts # プレイリストリポジトリのテスト
│       └── playlistRepository.ts        # プレイリストリポジトリの実装
└── db/
    ├── config/
    │   └── database.ts                 # DBクライアント設定
    └── models/
        ├── authors.ts                  # 著者モデル定義
        ├── videos.ts                   # 動画モデル定義
        └── playlists.ts                # プレイリストモデル定義
```

## Bun SQLiteを使用したテスト環境のセットアップ

Bunの組み込みSQLite機能を使用してインメモリデータベースのテスト環境を構築します：

```typescript
// src/db/config/database.ts
import { Database } from "bun:sqlite";
import { drizzle as drizzleSqlite } from "drizzle-orm/bun-sqlite";
import { migrate as migrateSqlite } from "drizzle-orm/bun-sqlite/migrator";

// テスト環境用のデータベースクライアントを作成
export const createTestDbClient = async (migrationsPath = "./drizzle") => {
  // インメモリデータベースを作成（":memory:"を指定）
  const sqlite = new Database(":memory:");

  // Drizzle ORMのクライアントを作成
  const db = drizzleSqlite(sqlite);

  // マイグレーションを実行
  await migrateSqlite(db, { migrationsFolder: migrationsPath });

  return db;
};
```

## テスト用ユーティリティの実装

リポジトリテスト用の共通ユーティリティ関数を作成します：

```typescript
// src/repositories/testUtils.ts
import { nanoid } from "nanoid";
import type { SQL } from "drizzle-orm";
import { createTestDbClient } from "../db/config/database";
import type { authors } from "../db/models/authors";
import type { videos } from "../db/models/videos";
import type { playlists } from "../db/models/playlists";

// テスト用のデータベースクライアントを作成
export const createTestDb = async (migrationsPath = "./drizzle") => {
  return await createTestDbClient(migrationsPath);
};

// テスト用の著者データを作成
export const createTestAuthor = (
  overrides: Partial<typeof authors.$inferInsert> = {}
) => {
  const now = new Date();
  return {
    id: nanoid(),
    name: "テスト著者",
    iconUrl: "https://example.com/icon.png",
    bio: "テスト用の著者です",
    createdAt: now,
    updatedAt: now,
    ...overrides,
  };
};

// テスト用のリポジトリ環境をセットアップ
export const setupTestRepository = async (seedQueries: SQL[] = []) => {
  // テスト用のデータベースクライアントを作成
  const db = await createTestDb();

  // シードデータを挿入（指定されている場合）
  if (seedQueries.length > 0) {
    for (const query of queries) {
      await db.run(query);
    }
  }

  return { db };
};

// テスト終了後のクリーンアップ
export const cleanupTestRepository = async (_db: any) => {
  // インメモリDBなので自動的にクリーンアップされる
};
```

## リポジトリのテスト実装例

```typescript
// src/repositories/author/__tests__/authorRepository.test.ts
import { describe, it, expect, beforeEach, afterEach } from "bun:test";
import { authors } from "../../../db/models/authors";
import {
  createTestAuthor,
  setupTestRepository,
  cleanupTestRepository,
} from "../../testUtils";
import { authorRepository } from "../authorRepository";

describe("authorRepository", () => {
  let db;

  beforeEach(async () => {
    // テスト用データベースをセットアップ
    const setup = await setupTestRepository();
    db = setup.db;
  });

  afterEach(async () => {
    // テスト後のクリーンアップ
    await cleanupTestRepository(db);
  });

  describe("findAll", () => {
    it("全ての著者を取得できること", async () => {
      // テストデータを準備
      const author1 = createTestAuthor({ name: "著者1" });
      const author2 = createTestAuthor({ name: "著者2" });

      // データをデータベースに挿入
      await db.insert(authors).values([author1, author2]);

      // テスト対象の関数を実行
      const result = await authorRepository.findAll(db);

      // 結果を検証
      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        const authorsResult = result.value;
        expect(authorsResult).toHaveLength(2);
        expect(authorsResult.map(a => a.name)).toContain("著者1");
        expect(authorsResult.map(a => a.name)).toContain("著者2");
      }
    });

    it("データベースエラーが発生した場合はエラーを返すこと", async () => {
      // DBクライアントをモックしてエラーをシミュレート
      const mockDb = {
        ...db,
        select: () => {
          throw new Error("データベースエラー");
        },
      } as unknown as typeof db;

      // テスト対象の関数を実行
      const result = await authorRepository.findAll(mockDb);

      // 結果を検証
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("serverError");
      }
    });
  });

  // 他のテストケース
});
```

## 環境変数に基づくDBクライアントの選択

テストや開発、本番環境で適切なDBクライアントを選択するための関数：

```typescript
// src/db/config/database.ts
export const createClient = (env: {
  D1_INSTANCE?: D1Database;
  NODE_ENV?: string;
}) => {
  // 本番/ステージング環境の場合
  if (env.D1_INSTANCE) {
    return createDbClient(env.D1_INSTANCE);
  }

  // 開発環境の場合
  if (env.NODE_ENV === "development") {
    return createDevDbClient();
  }

  // テスト環境の場合
  if (env.NODE_ENV === "test") {
    return createTestDbClient();
  }

  // デフォルトはテスト環境
  return createTestDbClient();
};
```

## テスト実行方法

```bash
# すべてのテストを実行
bun test

# 特定のディレクトリのみテスト
bun test src/repositories

# 特定のファイルのみテスト
bun test src/repositories/author/__tests__/authorRepository.test.ts

# 変更を監視して自動的にテスト実行
bun test --watch
```

## テスト時と実装時の使い分け

- **テスト時**:
  - リポジトリ層（authorRepository）を直接使用
  - DBクライアントをDIで注入
  - Result型のエラーハンドリングを検証

- **UI実装時**:
  - フック層（hooks）を使用
  - React Queryの機能（キャッシュ、リフェッチなど）を活用
  - データロード状態やエラー状態を簡単に取得

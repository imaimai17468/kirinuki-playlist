---
description: Kirinuki-PlaylistプロジェクトのサーバーサイドAPI実装規約
globs: src/app/api/**/*.ts
---

# サーバーサイドAPI実装規約

## プロジェクト概要

Kirinuki-PlaylistではNext.jsアプリケーション内でHonoを使用してAPIを実装しています。
このドキュメントでは、APIコードの構造とベストプラクティスについて説明します。

## APIコードの構成

APIコードは特定のディレクトリ構造に従って整理し、関心事の適切な分離を維持します。
主要なディレクトリには以下が含まれます：

- **app/api/**: APIルートとエンドポイント定義
- **db/config/**: データベース接続とHono設定
- **db/models/**: データモデル定義
- **db/services/**: データアクセスとビジネスロジック
- **repositories/**: クライアントサイド通信レイヤー
- **middleware/**: 認証やエラーハンドリングなどのミドルウェア

## 基本方針

1. **責任の分離**: APIルーターとサービスレイヤーの間で明確な責任分担を行う
2. **型安全性**: TypeScriptの型システムを最大限に活用する
3. **一貫性**: すべてのエンドポイントで一貫した設計パターンを適用する
4. **テスト可能性**: サービスレイヤーを独立してテスト可能な設計にする
5. **バリデーション**: すべての入力を検証し、早期に検証エラーを返す

## APIレイヤーの実装

### Honoアプリケーション構成

Honoアプリケーションは以下の原則に従って構成します：

1. **ルーティング分離**: リソースタイプごとに個別のルーターファイルを作成
2. **ミドルウェアの一貫した適用**: エラーハンドリングや認証などの共通ミドルウェアを適用
3. **明確なエントリーポイント**: Next.js APIルートとHonoの連携を一か所で管理

### サービスレイヤーとの連携

APIルーターはリクエストの受け取り、検証、サービスレイヤーへの委譲、レスポンスの構築という責任を持ちます：

1. **サービスの注入**: 依存性注入パターンを用いてサービスをルーターに提供
2. **コンテキスト管理**: リクエストコンテキストを通じてDBクライアントなどの依存関係を提供
3. **エラーハンドリング**: サービスレイヤーからのエラーを適切なHTTPレスポンスに変換

## サービスレイヤーの実装

サービスレイヤーは以下の責任を持ちます：

1. **ビジネスロジック**: アプリケーションのコアビジネスルールを実装
2. **データアクセス**: データベースとのやり取りを管理
3. **データ整合性チェック**: リレーショナルな整合性の検証
4. **エラー生成**: ビジネスルール違反時に適切なエラーをスロー

### サービスレイヤーのパターン

1. **ファクトリー関数**: サービスインスタンスを作成するファクトリー関数を使用
2. **依存性注入**: テスト容易性を高めるため、DBクライアントなどの依存関係を外部から注入
3. **ドメインに特化したインターフェース**: 各サービスはそのドメイン固有の機能を提供するインターフェースを実装

## データモデルとスキーマ定義

データモデルは以下の原則に従って定義します：

1. **Drizzle ORM**: テーブル定義とクエリ構築にDrizzle ORMを使用
2. **Zod**: リクエスト/レスポンスバリデーションにZodを使用
3. **型共有**: クライアントとサーバー間で型定義を共有

## エンドポイント設計のベストプラクティス

1. **URI構造**: RESTfulなURIパターンを使用（例: `/playlists/:id/videos`）
2. **メソッド適用**: 適切なHTTPメソッドを使用（GET、POST、PUT、DELETE）
3. **クエリパラメータ**: フィルタリング、ソート、ページネーションにクエリパラメータを使用
4. **ステータスコード**: 適切なHTTPステータスコードを返す

## エラーハンドリング

1. **一貫したエラーフォーマット**: すべてのAPIエラーで同じレスポンス構造を使用
2. **詳細なエラーメッセージ**: クライアントが理解できる明確なエラーメッセージを提供
3. **適切なエラータイプ**: 状況に応じた適切なカスタムエラークラスを使用
4. **一元的なエラーハンドリング**: エラーハンドリングミドルウェアを通じて一貫したエラー処理を実現

## バリデーション

1. **入力検証**: すべてのクライアント入力をZodスキーマで検証
2. **早期検証**: ビジネスロジック実行前に入力を検証
3. **細分化された検証**: 各エンドポイントに特化したスキーマを定義
4. **型推論**: スキーマから型を推論して型安全性を確保

## データベースアクセス

1. **Drizzle ORM**: SQLクエリの構築とデータベースアクセスにDrizzle ORMを使用
2. **トランザクション**: データ整合性を保つため必要に応じてトランザクションを使用
3. **エラーハンドリング**: データベースエラーを適切にキャッチし、意味のあるエラーメッセージに変換
4. **N+1問題の回避**: 関連データを効率的に取得するよう設計

## 認証と認可

1. **認証ミドルウェア**: 一貫した認証処理を提供するミドルウェアを使用
2. **認可チェック**: 各エンドポイントでの認可チェックを実装
3. **コンテキストアクセス**: 認証されたユーザー情報をリクエストコンテキストで利用可能に

## セキュリティ考慮事項

1. **入力サニタイズ**: すべてのユーザー入力を適切にサニタイズ
2. **Rate Limiting**: 過剰なリクエストからAPIを保護
3. **CORS**: 適切なCORS設定を実装
4. **機密情報の保護**: 機密情報を適切に管理

## ロギングとモニタリング

1. **構造化ログ**: 構造化されたログフォーマットを使用
2. **エラーロギング**: すべてのAPIエラーを適切なコンテキストとともにログに記録
3. **パフォーマンスモニタリング**: エンドポイントのパフォーマンスを監視

## テスト戦略

1. **単体テスト**: サービスレイヤーの単体テストを実装
2. **統合テスト**: サービスとデータベースの統合をテスト
3. **エンドツーエンドテスト**: APIエンドポイントの完全な動作をテスト
4. **モック**: 外部依存をモックしてテストを分離

## プレイリスト管理

### 動画並び順の管理

1. **順序フィールド**: プレイリスト内の動画の並び順を「order」フィールドで管理
2. **順序の更新**: 動画の順序を変更するための専用エンドポイントを提供
3. **一括更新**: 複数の動画の順序を一度に更新できる機能を提供
4. **整合性確保**: 順序の重複や欠落を防ぐための検証を実装

## キャッシュ戦略

1. **キャッシュヘッダー**: 適切なキャッシュコントロールヘッダーを設定
2. **条件付きリクエスト**: ETagやLast-Modifiedヘッダーを活用
3. **キャッシュ無効化**: データ更新時に関連キャッシュを適切に無効化

## パフォーマンス最適化

1. **クエリ最適化**: 効率的なデータベースクエリを設計
2. **ページネーション**: 大量のデータを扱う場合はページネーションを実装
3. **選択的フィールド取得**: 必要なフィールドのみを取得するオプションを提供
4. **バッチ処理**: 複数操作をバッチ処理する仕組みを提供

このガイドラインに従うことで、保守性が高く、拡張性のあるAPI実装を実現できます。

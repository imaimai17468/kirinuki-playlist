---
description: Kirinuki-PlaylistプロジェクトのサーバーサイドAPI実装規約
globs: src/app/api/**/*.ts
---

# サーバーサイドAPI実装規約

## プロジェクト概要

Kirinuki-PlaylistではNext.jsアプリケーション内でHonoを使用してAPIを実装しています。
このドキュメントでは、APIコードの構造とベストプラクティスについて説明します。

## APIコードの構成

APIコードは以下のディレクトリ構造に従って整理します：

```
src/
├── app/
│   └── api/
│       └── [...route]/
│           ├── route.ts         # エントリーポイント
│           ├── videos.ts        # ビデオ関連エンドポイント
│           ├── playlists.ts     # プレイリスト関連エンドポイント
│           └── authors.ts       # 著者関連エンドポイント
├── db/
│   ├── config/                  # データベース構成
│   │   ├── database.ts          # DB接続管理
│   │   ├── client.ts            # APIクライアント
│   │   └── hono.ts              # Honoアプリ構成
│   ├── models/                  # データモデル
│   │   ├── videos.ts
│   │   ├── playlists.ts
│   │   └── authors.ts
│   └── services/                # データアクセスサービス
│       ├── videos.ts
│       ├── playlists.ts
│       └── authors.ts
├── repositories/                # クライアントサイドリポジトリ
│   ├── videos/
│   ├── playlists/
│   └── authors/
├── middleware/                  # ミドルウェア
│   ├── auth.ts
│   └── error-handler.ts
└── schemas/                     # スキーマ定義
    ├── video.ts
    ├── playlist.ts
    └── author.ts
```

### 命名規則

APIファイルとディレクトリの命名には以下の規則を適用します：

- **APIルートファイル名は複数形**: リソースを表すファイル名には複数形を使用します（例: `videos.ts`, `playlists.ts`, `authors.ts`）
- **一貫性**: APIルート、モデル、サービス、リポジトリなど、すべての層で同じ命名規則を使用します
- **モデル名も複数形**: データベースモデルファイル名も同様に複数形を使用します（例: `videos.ts`）

これらの命名規則により、コードベースの一貫性が保たれ、開発者が直感的に理解できるようになります。

## 責任の分離

APIコードは以下の責任に分けて実装します：

1. **ルーター**: HTTP要求の受け付けとレスポンスの返却
2. **サービスレイヤー**: ビジネスロジックの実装
3. **データアクセスレイヤー**: データベースアクセスの抽象化
4. **リポジトリレイヤー**: クライアントサイドからのAPIアクセス抽象化

## APIルーターの実装

### エントリーポイント (route.ts)

```typescript
// src/app/api/[...route]/route.ts
import { createHonoApp } from "@/db/config/hono";
import { handle } from "hono/vercel";

// Honoアプリケーションの作成
// 環境に応じたデータベースクライアントが自動的に注入される
const app = createHonoApp();

// Vercelハンドラー
export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);

// 型定義をエクスポートして、クライアント側で型安全にAPIを呼び出せるようにする
export type AppType = typeof app;
```

### 環境とデータベース接続の管理

Kirinuki-Playlistでは、環境（本番、開発、テスト）に応じたデータベースクライアント管理と依存性注入パターンを実装しています。

```typescript
// src/db/config/hono.ts
import { authorsRouter } from "@/app/api/[...route]/author";
import { playlistsRouter } from "@/app/api/[...route]/playlists";
import { videosRouter } from "@/app/api/[...route]/videos";
import type { createDbClient } from "@/db/config/database";
import { createDevDbClient } from "@/db/config/database";
import type { createTestDbClient } from "@/db/config/test-database";
import { errorHandler } from "@/db/middlewares/error-handler";
import type { Bindings } from "@/db/types/bindings";
import type { MiddlewareHandler } from "hono";
import { Hono } from "hono";

// DBクライアント型の定義
export type DbClient =
  | ReturnType<typeof createDbClient>
  | Awaited<ReturnType<typeof createTestDbClient>>
  | Awaited<ReturnType<typeof createDevDbClient>>;

// 依存性を格納するための型拡張
type Variables = {
  dbClient?: DbClient;
};

// Bindings型にVariablesを追加した合成型
export type AppEnv = {
  Bindings: Bindings;
  Variables: Variables;
};

/**
 * 環境に応じたHonoアプリケーションを作成する関数
 * 本番環境では実際のD1データベースを使用し、テスト環境ではテスト用DBクライアントを使用
 */
export function createHonoApp(options?: { dbClient?: DbClient }) {
  // 依存性をコンテキストに注入するミドルウェア
  const injectDependencies: MiddlewareHandler<AppEnv> = async (c, next) => {
    // dbClientが直接提供されている場合はそれを使用
    if (options?.dbClient) {
      c.set("dbClient", options.dbClient);
    } else if (process.env.NODE_ENV === "development") {
      const client = await createDevDbClient();
      c.set("dbClient", client);
    }
    await next();
  };

  // Honoアプリケーションの組み立て
  const app = new Hono<AppEnv>()
    .basePath("/api")
    .use("*", errorHandler)
    .use("*", injectDependencies) // 依存性注入ミドルウェア
    .route("/authors", authorsRouter)
    .route("/videos", videosRouter)
    .route("/playlists", playlistsRouter)
    .get("/hello", (c) => c.json({ status: "ok" }));

  return app;
}
```

### リソース別ルーター

```typescript
// src/app/api/[...route]/videos.ts
import { createDbClient } from "@/db/config/database";
import type { AppEnv } from "@/db/config/hono";
import { videoInsertSchema, videoUpdateSchema } from "@/db/models/videos";
import { createVideoService } from "@/db/services/videos";
import type { VideoInsert, VideoUpdate } from "@/db/services/videos";
import { zValidator } from "@hono/zod-validator";
import { Hono } from "hono";

export const videosRouter = new Hono<AppEnv>()
  // 動画一覧の取得（著者情報を含む）
  .get("/", async (c) => {
    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { getRequestContext } = await import("@cloudflare/next-on-pages");
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const videos = await service.getAllVideos();
    return c.json({ success: true, videos });
  })
  // 動画の詳細取得（著者情報を含む）
  .get("/:id", async (c) => {
    const id = c.req.param("id");

    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { getRequestContext } = await import("@cloudflare/next-on-pages");
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const video = await service.getVideoById(id);
    return c.json({ success: true, video });
  })
  // 動画の追加
  .post("/", zValidator("json", videoInsertSchema), async (c) => {
    const input = c.req.valid("json") as VideoInsert;

    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { getRequestContext } = await import("@cloudflare/next-on-pages");
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const id = await service.createVideo(input);

    // 作成後、著者情報を含めて返す
    const video = await service.getVideoById(id);
    return c.json({ success: true, id, video }, 201);
  })
  // ...その他のエンドポイント
```

### getRequestContext の動的インポート

パフォーマンス向上のため、`getRequestContext` 関数は必要な時のみ動的にインポートします：

```typescript
// 推奨される実装
let dbClient = c.get("dbClient");
if (!dbClient) {
  const { getRequestContext } = await import("@cloudflare/next-on-pages");
  const { DB } = getRequestContext().env;
  dbClient = createDbClient(DB);
}
```

この実装方法には以下の利点があります：

1. 初期ロード時のパフォーマンス向上
2. 依存関係の遅延ロード
3. 必要な場合のみリソースを使用

## 依存性注入パターン

サービスレイヤーでは依存性注入パターンを採用し、テスト容易性と柔軟性を高めています。

```typescript
// src/db/services/videos.ts
import type { DbClient } from "@/db/config/hono";
import { videos } from "@/db/models/videos";
import { NotFoundError, DatabaseError } from "@/db/utils/errors";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";

// 型定義
export type VideoInsert = {
  title: string;
  url: string;
  authorId: string;
  start?: number;
  end?: number;
};

export type VideoUpdate = Partial<VideoInsert>;

/**
 * 動画サービスを作成する関数
 * 依存性注入パターンを使用して、DBクライアントを外部から注入できるようにする
 */
export function createVideoService(dbClient: DbClient) {
  return {
    /**
     * すべての動画を取得する
     */
    async getAllVideos() {
      try {
        const result = await dbClient.select().from(videos).all();
        return result;
      } catch (error) {
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    /**
     * IDによって動画を取得する
     */
    async getVideoById(id: string) {
      try {
        const video = await dbClient
          .select()
          .from(videos)
          .where(eq(videos.id, id))
          .get();

        if (!video) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }

        return video;
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    // その他のメソッド...
  };
}
```

## クライアントサイドリポジトリの実装

サーバーサイドAPIをクライアントサイドから使用するために、リポジトリパターンを実装します。これらのリポジトリは型安全性、エラーハンドリング、レスポンスの検証を提供します。

```typescript
// src/repositories/video/index.ts
import { getApiClient } from "@/db/config/client";
import type { ApiError } from "@/repositories/types";
import { videoResponseSchema, videosResponseSchema } from "@/repositories/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

// ビデオ一覧を取得
export async function getAllVideos(): Promise<Result<z.infer<typeof videosResponseSchema>["videos"], ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videosResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.videos);
  } catch (error) {
    return err(createNetworkError(error));
  }
}

// ビデオを取得
export async function getVideoById(
  id: string,
): Promise<Result<z.infer<typeof videoResponseSchema>["video"], ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos[":id"].$get({
      param: { id },
    });

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videoResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.video);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

### APIクライアント管理

クライアントサイドでは、シングルトンパターンを使用してAPIクライアントを管理します。これにより、テスト容易性とコード一貫性が向上します：

```typescript
// src/db/config/client.ts
import type { AppType } from "@/app/api/[...route]/route";
import { getBaseURL } from "@/db/config/baseUrl";
import { hc } from "hono/client";

/**
 * APIクライアントインターフェース
 */
export type ApiClient = ReturnType<typeof hc<AppType>>;

// シングルトンインスタンス管理
let currentClient: ApiClient | null = null;

/**
 * 現在のAPIクライアントを取得
 * セットされていない場合は本番用クライアントを作成して返す
 */
export function getApiClient(): ApiClient {
  if (!currentClient) {
    currentClient = hc<AppType>(`${getBaseURL()}/api`);
  }
  return currentClient;
}

/**
 * テスト時などにクライアントを差し替えるための関数
 */
export function setApiClient(client: ApiClient): void {
  currentClient = client;
}

// 従来の実装との互換性のために残しているが、新しいコードでは使用すべきでない
// 代わりに getApiClient() を使用すること
export const client = hc<AppType>(`${getBaseURL()}/api`);
```

## エラーハンドリング

API実装では一貫したエラーハンドリングパターンを使用して、クライアントに適切なエラーメッセージを返します。

```typescript
// エラーハンドリングの例（PlaylistsRouterから）
.get("/:id", async (c) => {
  const id = c.req.param("id");

  // DbClientをコンテキストから取得、なければ新規作成
  let dbClient = c.get("dbClient");
  if (!dbClient) {
    const { getRequestContext } = await import("@cloudflare/next-on-pages");
    const { DB } = getRequestContext().env;
    dbClient = createDbClient(DB);
  }

  try {
    const service = createPlaylistService(dbClient);
    const playlist = await service.getPlaylistWithVideosById(id);
    return c.json({ success: true, playlist });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return c.json({ success: false, message: error.message }, 404);
    }
    console.error("Failed to get playlist:", error);
    return c.json({ success: false, message: "プレイリストの取得に失敗しました" }, 500);
  }
})
```

## サーバーサイドとクライアントサイドの連携

サーバーサイドAPIとクライアントサイドリポジトリは、以下の方法で連携しています：

1. **Honoのタイプセーフなインターフェース**: `AppType` を通じて、API定義の型情報をクライアントと共有
2. **一貫したレスポンス形式**: すべてのAPIエンドポイントは `{ success: boolean, ... }` 形式で応答
3. **スキーマ検証**: Zodを使用して、クライアントでもサーバーからのレスポンスを検証
4. **エラーハンドリング**: クライアント側でもサーバーのエラー応答を適切に処理

### リポジトリとHonoクライアントの移行

以前は直接 `client` をインポートしていましたが、シングルトンパターンの導入により `getApiClient()` を使用するように変更されました：

```typescript
// 古い実装（非推奨）
import { client } from "@/db/config/client";
const response = await client.api.videos.$get();

// 新しい実装（推奨）
import { getApiClient } from "@/db/config/client";
const client = getApiClient();
const response = await client.api.videos.$get();
```

この変更により、テスト時にモッククライアントを注入できるようになり、テスト容易性が向上しました。

## セキュリティ

APIのセキュリティ対策として以下を実装します：

1. **認証**: JWTベースの認証システム
2. **認可**: ロールベースのアクセス制御
3. **入力バリデーション**: すべてのリクエストデータのバリデーション
4. **セキュアヘッダー**: 適切なセキュリティヘッダーの設定
5. **レート制限**: 大量のリクエストからの保護

## データベース操作

データベース操作はDrizzle ORMを使用して行います。

```typescript
// src/db/drizzle.ts
import { drizzle } from 'drizzle-orm/d1';
import { D1Database } from '@cloudflare/workers-types';
import * as schema from './models';

export function getDb(db: D1Database) {
  return drizzle(db, { schema });
}
```

## テスト

APIのテストは以下のアプローチで行います：

1. **単体テスト**: サービスレイヤーの各関数をモックしてテスト
2. **統合テスト**: 実際のデータベースを使用してAPIエンドポイントをテスト
3. **E2Eテスト**: フロントエンドからの実際のAPI呼び出しをテスト

詳細なテスト方法については [api-testing.mdc](mdc:api-testing.mdc) を参照してください。

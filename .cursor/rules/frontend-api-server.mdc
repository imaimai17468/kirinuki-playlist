---
description: Kirinuki-PlaylistプロジェクトのサーバーサイドAPI実装規約
globs: src/app/api/**/*.ts
---

# サーバーサイドAPI実装規約

## プロジェクト概要

Kirinuki-PlaylistではNext.jsアプリケーション内でHonoを使用してAPIを実装しています。
このドキュメントでは、APIコードの構造とベストプラクティスについて説明します。

## APIコードの構成

APIコードは以下のディレクトリ構造に従って整理します：

```
src/
├── app/
│   └── api/
│       └── [...route]/
│           ├── route.ts         # エントリーポイント
│           ├── videos.ts        # ビデオ関連エンドポイント
│           ├── playlists.ts     # プレイリスト関連エンドポイント
│           └── author.ts        # 著者関連エンドポイント
├── db/
│   ├── config/                  # データベース構成
│   │   ├── database.ts          # DB接続管理
│   │   ├── client.ts            # APIクライアント
│   │   └── hono.ts              # Honoアプリ構成
│   ├── models/                  # データモデル
│   │   ├── videos.ts
│   │   ├── playlists.ts
│   │   └── authors.ts
│   └── services/                # データアクセスサービス
│       ├── videos.ts
│       ├── playlists.ts
│       └── authors.ts
├── middleware/                  # ミドルウェア
│   ├── auth.ts
│   └── error-handler.ts
└── schemas/                     # スキーマ定義
    ├── video.ts
    ├── playlist.ts
    └── author.ts
```

## 責任の分離

APIコードは以下の責任に分けて実装します：

1. **ルーター**: HTTP要求の受け付けとレスポンスの返却
2. **サービスレイヤー**: ビジネスロジックの実装
3. **データアクセスレイヤー**: データベースアクセスの抽象化

## APIルーターの実装

### エントリーポイント (route.ts)

```typescript
// src/app/api/[...route]/route.ts
import { createHonoApp } from "@/db/config/hono";
import { handle } from "hono/vercel";

// Honoアプリケーションの作成
// 環境に応じたデータベースクライアントが自動的に注入される
const app = createHonoApp();

// Vercelハンドラー
export const GET = handle(app);
export const POST = handle(app);
export const PUT = handle(app);
export const PATCH = handle(app);
export const DELETE = handle(app);

// 型定義をエクスポートして、クライアント側で型安全にAPIを呼び出せるようにする
export type AppType = typeof app;
```

### 環境とデータベース接続の管理

Kirinuki-Playlistでは、環境（本番、開発、テスト）に応じたデータベースクライアント管理と依存性注入パターンを実装しています。

```typescript
// src/db/config/hono.ts
import { authorsRouter } from "@/app/api/[...route]/author";
import { playlistsRouter } from "@/app/api/[...route]/playlists";
import { videosRouter } from "@/app/api/[...route]/videos";
import type { createDbClient } from "@/db/config/database";
import { createDevDbClient } from "@/db/config/database";
import type { createTestDbClient } from "@/db/config/test-database";
import { errorHandler } from "@/db/middlewares/error-handler";
import type { Bindings } from "@/db/types/bindings";
import type { MiddlewareHandler } from "hono";
import { Hono } from "hono";

// DBクライアント型の定義
export type DbClient =
  | ReturnType<typeof createDbClient>
  | Awaited<ReturnType<typeof createTestDbClient>>
  | Awaited<ReturnType<typeof createDevDbClient>>;

// 依存性を格納するための型拡張
type Variables = {
  dbClient?: DbClient;
};

// Bindings型にVariablesを追加した合成型
export type AppEnv = {
  Bindings: Bindings;
  Variables: Variables;
};

/**
 * 環境に応じたHonoアプリケーションを作成する関数
 * 本番環境では実際のD1データベースを使用し、テスト環境ではテスト用DBクライアントを使用
 */
export function createHonoApp(options?: { dbClient?: DbClient }) {
  // 依存性をコンテキストに注入するミドルウェア
  const injectDependencies: MiddlewareHandler<AppEnv> = async (c, next) => {
    // dbClientが直接提供されている場合はそれを使用
    if (options?.dbClient) {
      c.set("dbClient", options.dbClient);
    } else if (process.env.NODE_ENV === "development") {
      const client = await createDevDbClient();
      c.set("dbClient", client);
    }
    await next();
  };

  // Honoアプリケーションの組み立て
  const app = new Hono<AppEnv>()
    .basePath("/api")
    .use("*", errorHandler)
    .use("*", injectDependencies) // 依存性注入ミドルウェア
    .route("/authors", authorsRouter)
    .route("/videos", videosRouter)
    .route("/playlists", playlistsRouter)
    .get("/hello", (c) => c.json({ status: "ok" }));

  return app;
}
```

### リソース別ルーター

```typescript
// src/app/api/[...route]/videos.ts
import { createDbClient } from "@/db/config/database";
import type { AppEnv } from "@/db/config/hono";
import { videoInsertSchema, videoUpdateSchema } from "@/db/models/videos";
import { createVideoService } from "@/db/services/videos";
import type { VideoInsert, VideoUpdate } from "@/db/services/videos";
import { getRequestContext } from "@cloudflare/next-on-pages";
import { zValidator } from "@hono/zod-validator";
import { Hono } from "hono";

export const videosRouter = new Hono<AppEnv>()
  // 動画一覧の取得（著者情報を含む）
  .get("/", async (c) => {
    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const videos = await service.getAllVideos();
    return c.json({ success: true, videos });
  })
  // 動画の詳細取得（著者情報を含む）
  .get("/:id", async (c) => {
    const id = c.req.param("id");

    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const video = await service.getVideoById(id);
    return c.json({ success: true, video });
  })
  // 動画の追加
  .post("/", zValidator("json", videoInsertSchema), async (c) => {
    const input = c.req.valid("json") as VideoInsert;

    // コンテキストからdbClientを取得するか、ない場合は従来通りの方法で取得
    let dbClient = c.get("dbClient");
    if (!dbClient) {
      const { DB } = getRequestContext().env;
      dbClient = createDbClient(DB);
    }

    const service = createVideoService(dbClient);
    const id = await service.createVideo(input);

    // 作成後、著者情報を含めて返す
    const video = await service.getVideoById(id);
    return c.json({ success: true, id, video }, 201);
  })
  // ...その他のエンドポイント
```

## 依存性注入パターン

サービスレイヤーでは依存性注入パターンを採用し、テスト容易性と柔軟性を高めています。

```typescript
// src/db/services/videos.ts
import type { DbClient } from "@/db/config/hono";
import { videos } from "@/db/models/videos";
import { NotFoundError, DatabaseError } from "@/db/utils/errors";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";

// 型定義
export type VideoInsert = {
  title: string;
  url: string;
  authorId: string;
  start?: number;
  end?: number;
};

export type VideoUpdate = Partial<VideoInsert>;

/**
 * 動画サービスを作成する関数
 * 依存性注入パターンを使用して、DBクライアントを外部から注入できるようにする
 */
export function createVideoService(dbClient: DbClient) {
  return {
    /**
     * すべての動画を取得する
     */
    async getAllVideos() {
      try {
        const result = await dbClient.select().from(videos).all();
        return result;
      } catch (error) {
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    /**
     * IDによって動画を取得する
     */
    async getVideoById(id: string) {
      try {
        const video = await dbClient
          .select()
          .from(videos)
          .where(eq(videos.id, id))
          .get();

        if (!video) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }

        return video;
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    // その他のメソッド...
  };
}
```

## エラーハンドリング

API実装では一貫したエラーハンドリングパターンを使用して、クライアントに適切なエラーメッセージを返します。

```typescript
// エラーハンドリングの例（PlaylistsRouterから）
.get("/:id", async (c) => {
  const id = c.req.param("id");

  // DbClientをコンテキストから取得、なければ新規作成
  let dbClient = c.get("dbClient");
  if (!dbClient) {
    const { DB } = getRequestContext().env;
    dbClient = createDbClient(DB);
  }

  try {
    const service = createPlaylistService(dbClient);
    const playlist = await service.getPlaylistWithVideosById(id);
    return c.json({ success: true, playlist });
  } catch (error) {
    if (error instanceof NotFoundError) {
      return c.json({ success: false, message: error.message }, 404);
    }
    console.error("Failed to get playlist:", error);
    return c.json({ success: false, message: "プレイリストの取得に失敗しました" }, 500);
  }
})
```

## セキュリティ

APIのセキュリティ対策として以下を実装します：

1. **認証**: JWTベースの認証システム
2. **認可**: ロールベースのアクセス制御
3. **入力バリデーション**: すべてのリクエストデータのバリデーション
4. **セキュアヘッダー**: 適切なセキュリティヘッダーの設定
5. **レート制限**: 大量のリクエストからの保護

## データベース操作

データベース操作はDrizzle ORMを使用して行います。

```typescript
// src/db/drizzle.ts
import { drizzle } from 'drizzle-orm/d1';
import { D1Database } from '@cloudflare/workers-types';
import * as schema from './models';

export function getDb(db: D1Database) {
  return drizzle(db, { schema });
}
```

## テスト

APIのテストは以下のアプローチで行います：

1. **単体テスト**: サービスレイヤーの各関数をモックしてテスト
2. **統合テスト**: 実際のデータベースを使用してAPIエンドポイントをテスト
3. **E2Eテスト**: フロントエンドからの実際のAPI呼び出しをテスト

詳細なテスト方法については [api-testing.mdc](mdc:api-testing.mdc) を参照してください。

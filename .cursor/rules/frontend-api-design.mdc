---
description: Kirinuki-PlaylistプロジェクトのAPI設計ガイドライン
globs: src/app/api/**/*.ts, src/repositories/**/*.ts
---
# API 設計ガイドライン

Kirinuki-Playlistプロジェクトでは、フロントエンドとバックエンドの間のAPI通信に関して、以下のガイドラインに従って設計を行います。

## 基本原則

1. **シンプル**: 理解しやすく、使いやすいAPIを設計する
2. **一貫性**: 命名規則、レスポンス形式、エラー処理などを一貫させる
3. **型安全**: TypeScriptとZodを使用して、型安全なAPIを構築する
4. **自己文書化**: 型定義と規約によって、APIの使用方法が明確になるようにする
5. **テスト容易性**: 単体テスト、統合テストが書きやすいAPI設計にする

## API構造

### エンドポイント設計

RESTful APIの原則に従い、リソース指向のURLパスを使用します：

- `/api/[リソース名]` - リソースのコレクション
- `/api/[リソース名]/:id` - 特定のリソース

### リレーションを含む場合のエンドポイント設計

リソース間のリレーションを表現するために以下のパターンを使用します：

- `/api/[親リソース]/:id/[子リソース]` - 関連リソースの取得
- `/api/[親リソース]/:id/[関連操作]` - リレーション操作に特化したエンドポイント
- `/api/[リソース名]/[専用操作]` - 特定のクエリパラメータを使用した操作（例：`/api/tags/videos?tagIds=...`）

### ネストされたリソース

- 深いネストは避け、最大2階層までにする
- 複雑なリレーションはクエリパラメータや専用エンドポイントで表現する

## 命名規則

### URL

- 複数形の名詞を使用（`/videos`, `/playlists`, `/authors`, `/tags`）
- 小文字と `-` (ハイフン) を使用
- 動詞は避け、HTTPメソッドで操作を表現

### リクエスト/レスポンスフィールド

- camelCase形式を使用
- 一貫した命名パターンを使用（`createdAt`, `updatedAt` など）
- ブール値のフィールドには、`is`, `has`, `can` などのプレフィックスを使用

## HTTPメソッド

各操作には適切なHTTPメソッドを使用します：

- GET - リソースの取得
- POST - リソースの作成
- PUT - リソースの完全更新
- PATCH - リソースの部分更新
- DELETE - リソースの削除

## レスポンス形式

すべてのAPIレスポンスは一貫した形式で返します：

### 成功レスポンス

```
{
  "success": true,
  "[リソース名]": データ,
  "message": "任意のメッセージ" (オプション)
}
```

### エラーレスポンス

```
{
  "success": false,
  "message": "エラーメッセージ",
  "errors": { "フィールド": ["エラー内容"] } (オプション、バリデーションエラーの場合)
}
```

## 関連リソースの扱い

### 関連リソースのインライン展開

関連リソースを含める場合は以下の原則に従います：

1. **基本リクエストではシンプルに**: 基本リクエストでは、IDのみを返す
2. **拡張情報はオプションで**: 詳細情報が必要な場合は、クエリパラメータや特別なエンドポイントを使用
3. **一貫した命名**: 関連リソースは一貫した命名規則で表現

### クライアントへのヒント

関連リソースの存在をクライアントに示すため、以下のアプローチを使用します：

1. **明示的なクエリパラメータ**: `?include=author,videos`
2. **特殊なエンドポイント**: `/api/playlists/123/withVideos`
3. **コンテンツネゴシエーション**: Accept ヘッダーやカスタムヘッダー

## リクエストバリデーション

リクエストバリデーションには Zod を使用します：

- 各リソースごとに適切なスキーマを定義
- 入力検証を明示的に行い、適切なエラーメッセージを返す
- スキーマから型を生成して型安全性を確保

## Zodを使用したスキーマ定義

### 基本的なエンティティスキーマ

各エンティティに対して基本的なスキーマを定義し、共通のルールや型定義を提供します：

- 基本レスポンススキーマ
- エンティティスキーマ（著者、動画、プレイリスト、タグなど）
- 関連エンティティを含むスキーマ

### 関連エンティティを含むスキーマ

複合的なデータ構造ではエンティティ間の関係を表現するスキーマを定義します：

- エンティティ拡張スキーマ
- ネスト構造のスキーマ
- リレーション用のスキーマ

### レスポンススキーマ

API応答の構造を定義するスキーマを用意します：

- 単一リソースレスポンススキーマ
- コレクションレスポンススキーマ
- 拡張情報付きレスポンススキーマ
- 関連IDのみを含むレスポンススキーマ（例：`videoIds`）

### リクエストスキーマ

クライアントからの入力を検証するスキーマを定義します：

- 作成用スキーマ
- 更新用スキーマ
- 関連付け操作用スキーマ
- クエリパラメータ検証用スキーマ（例：`tagIds`の検証）

## クエリパラメータの型安全な処理

クエリパラメータを扱う際には以下のパターンを使用します：

1. **柔軟なパラメータ処理**: 単一値と配列値の両方を受け付けるスキーマを定義
   ```typescript
   const tagIdsSchema = z.object({
     tagIds: z.union([z.string(), z.array(z.string())]).optional(),
   });
   ```

2. **パラメータの正規化**: API内部では一貫した型で処理できるよう、受け取ったパラメータを正規化
   ```typescript
   const { tagIds = [] } = c.req.valid("query");
   if (typeof tagIds === "string") {
     // 単一の文字列の場合は配列に変換
     const videoIds = await service.getVideosByTagIds([tagIds]);
     return c.json({ success: true, videoIds });
   }
   const videoIds = await service.getVideosByTagIds(tagIds);
   ```

## エラーハンドリング

エラーハンドリングについては、別途 `frontend-api-error-handling.mdc` を参照してください。

## API実装のベストプラクティス

1. **明確な関心の分離**
   - ルーティング、バリデーション、ビジネスロジック、データアクセスを明確に分離
   - 各コンポーネントが単一の責任を持つように設計

2. **型安全性の確保**
   - スキーマ定義から TypeScript の型を生成
   - APIクライアント、サーバー間で型の一貫性を保つ

3. **一貫したエラーハンドリング**
   - 詳細なエラーメッセージと適切なHTTPステータスコード
   - クライアントが理解しやすいエラーフォーマット

4. **効率的なデータ取得**
   - N+1問題を避ける（複数のAPIリクエストが連鎖する問題）
   - 必要に応じて、関連データをプリフェッチまたはインライン展開

5. **適切なドキュメント化**
   - 型定義を活用した自己文書化
   - コメントや専用ドキュメントによる補完

## Next.js × Honoのルーティング

Next.jsでのHonoの実装では、以下のパターンを使用します：

1. **ベースアプリケーションの定義**: 共通の設定とルーターをマウント
2. **リソース別のルーター分割**: 各リソースタイプに専用のルーターを定義
3. **型のエクスポート**: クライアント側で使用する型情報をエクスポート
4. **ハンドラー関数のエクスポート**: Vercel/Edgeランタイムでの処理に必要なハンドラーをエクスポート

## まとめ

このAPI設計ガイドラインに従うことで、以下のメリットが得られます：

1. **一貫性**: すべてのAPIが同じパターンを共有し、開発者が予測しやすい
2. **安全性**: TypeScriptとZodによる型安全な実装
3. **拡張性**: 新しいエンドポイントや機能を追加しやすい設計
4. **保守性**: 明確な関心の分離により、メンテナンスが容易
5. **テスト容易性**: モジュール化されたコンポーネントで単体テストが書きやすい

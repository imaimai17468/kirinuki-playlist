---
description: Kirinuki-PlaylistプロジェクトのAPI設計ガイドライン
globs: src/app/api/**/*.ts, src/repositories/**/*.ts
---
# Kirinuki-Playlist API設計ガイドライン

## 概要

Kirinuki-PlaylistプロジェクトのAPI設計は、シンプルさ、一貫性、型安全性を重視しています。
このガイドラインに従うことで、サーバーとクライアント間の通信が予測可能で信頼性の高いものになります。

## API構造

### 命名規則

APIエンドポイントとリソース名には以下の命名規則を適用します：

- **リソース名は複数形を使用**: `/api/videos`, `/api/playlists`, `/api/authors` など
- **ファイル名もリソース名と一致させる**: `videos.ts`, `playlists.ts`, `authors.ts` など
- **単一リソースの操作**: 単一リソースの操作には、URLパラメータを使用（例：`/api/videos/:id`）

この命名規則に従うことで、APIの一貫性が保たれ、開発者が直感的に理解できるようになります。

### エンドポイント

基本的なエンドポイント構造は次のとおりです：

```
/api/videos - 動画リソース
/api/playlists - プレイリストリソース
/api/authors - 著者リソース
```

### HTTPメソッド

各リソースに対して次のHTTPメソッドを使用します：

- `GET` - リソースの取得
- `POST` - リソースの作成
- `PUT` - リソースの完全な更新
- `PATCH` - リソースの部分的な更新
- `DELETE` - リソースの削除

### 例：動画リソース

```
GET /api/videos - すべての動画を取得
GET /api/videos/:id - 特定のIDの動画を取得
POST /api/videos - 新しい動画を作成
PUT /api/videos/:id - 動画を完全に更新
PATCH /api/videos/:id - 動画を部分的に更新
DELETE /api/videos/:id - 動画を削除
```

## レスポンスフォーマット

すべてのAPIレスポンスは一貫した形式に従います：

### 成功レスポンス

```json
{
  "success": true,
  "データのキー": データの値
}
```

例えば、動画のリストを返す場合：

```json
{
  "success": true,
  "videos": [
    { "id": "1", "title": "サンプル動画1", ... },
    { "id": "2", "title": "サンプル動画2", ... }
  ]
}
```

### エラーレスポンス

```json
{
  "success": false,
  "message": "エラーメッセージ"
}
```

## ステータスコード

適切なHTTPステータスコードを使用します：

- `200 OK` - リクエストが成功
- `201 Created` - リソースが正常に作成された
- `400 Bad Request` - リクエストが無効
- `401 Unauthorized` - 認証が必要
- `403 Forbidden` - アクセス権限がない
- `404 Not Found` - リソースが見つからない
- `500 Internal Server Error` - サーバーエラー

## リクエストバリデーション

リクエストデータのバリデーションにはZodを使用します：

```typescript
import { z } from "zod";
import { zValidator } from "@hono/zod-validator";

// バリデーションスキーマの定義
const videoCreateSchema = z.object({
  title: z.string().min(1, "タイトルは必須です"),
  url: z.string().url("有効なURLを入力してください"),
  authorId: z.string().min(1, "著者IDは必須です"),
  start: z.number().optional(),
  end: z.number().optional()
});

// バリデーションの適用
.post("/", zValidator("json", videoCreateSchema), async (c) => {
  const data = c.req.valid("json");
  // バリデーション済みデータを使用した処理
})
```

## API実装（サーバーサイド）

### Honoを使用したルーター

```typescript
// src/app/api/[...route]/videos.ts
import { createVideoService } from "@/db/services/videos";
import { Hono } from "hono";
import { zValidator } from "@hono/zod-validator";
import { videoInsertSchema } from "@/db/models/videos";
import type { AppEnv } from "@/db/config/hono";

export const videosRouter = new Hono<AppEnv>()
  .get("/", async (c) => {
    // コンテキストからdbClientを取得
    const dbClient = c.get("dbClient");
    const service = createVideoService(dbClient);

    try {
      const videos = await service.getAllVideos();
      return c.json({ success: true, videos });
    } catch (error) {
      // エラーハンドリングミドルウェアに処理を委譲
      throw error;
    }
  })
  .get("/:id", async (c) => {
    const id = c.req.param("id");
    const dbClient = c.get("dbClient");
    const service = createVideoService(dbClient);

    try {
      const video = await service.getVideoById(id);
      return c.json({ success: true, video });
    } catch (error) {
      throw error;
    }
  })
  .post("/", zValidator("json", videoInsertSchema), async (c) => {
    const input = c.req.valid("json");
    const dbClient = c.get("dbClient");
    const service = createVideoService(dbClient);

    try {
      const id = await service.createVideo(input);
      const video = await service.getVideoById(id);
      return c.json({ success: true, id, video }, 201);
    } catch (error) {
      throw error;
    }
  });
```

## API呼び出し（クライアントサイド）

### リポジトリパターンの実装

APIアクセスはリポジトリパターンを使用して抽象化します。各リソースタイプに対して個別のリポジトリモジュールを作成します：

```typescript
// src/repositories/videos/index.ts
import { getApiClient } from "@/db/config/client";
import type { ApiError } from "@/repositories/types";
import { videoResponseSchema, videosResponseSchema } from "@/repositories/videos/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

// 型をエクスポートして他のファイルで再利用可能にする
export type Video = z.infer<typeof videoResponseSchema>["video"];
export type Videos = z.infer<typeof videosResponseSchema>["videos"];

// 動画一覧を取得
export async function getAllVideos(): Promise<Result<Videos, ApiError>> {
  try {
    // getApiClient()を使用してシングルトンクライアントを取得
    const client = getApiClient();
    const response = await client.api.videos.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videosResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.videos);
  } catch (error) {
    return err(createNetworkError(error));
  }
}

// 動画を取得
export async function getVideoById(id: string): Promise<Result<Video, ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos[":id"].$get({
      param: { id },
    });

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videoResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.video);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

### APIクライアント管理（シングルトンパターン）

APIクライアントはシングルトンパターンを使用して管理し、テスト時のモック化を容易にします：

```typescript
// src/db/config/client.ts
import type { AppType } from "@/app/api/[...route]/route";
import { getBaseURL } from "@/db/config/baseUrl";
import { hc } from "hono/client";

// APIクライアント型定義
export type ApiClient = ReturnType<typeof hc<AppType>>;

// シングルトンインスタンス
let currentClient: ApiClient | null = null;

/**
 * 現在のAPIクライアントを取得
 * 未設定の場合は新しいクライアントを作成して返す
 */
export function getApiClient(): ApiClient {
  if (!currentClient) {
    currentClient = hc<AppType>(`${getBaseURL()}/api`);
  }
  return currentClient;
}

/**
 * テスト時などにクライアントを差し替える
 */
export function setApiClient(client: ApiClient): void {
  currentClient = client;
}

// 従来の実装との互換性のために残しているが、新しいコードでは使用すべきでない
// 代わりに getApiClient() を使用すること
export const client = hc<AppType>(`${getBaseURL()}/api`);
```

このシングルトンパターンを使用することで、以下のメリットがあります：

1. **一貫性**: アプリケーション全体で同一のクライアントインスタンスを使用
2. **テスト容易性**: テスト時にモッククライアントを注入可能
3. **環境分離**: 実行環境に応じた設定を適用可能
4. **ユニットテスト**: 個別のAPIコールを独立してテスト可能

### getApiClient() 関数の使用

新しい実装では、APIクライアントを取得するために`getApiClient()`関数を使用します：

```typescript
// 非推奨 ❌
import { client } from "@/db/config/client";
const response = await client.api.videos.$get();

// 推奨 ✅
import { getApiClient } from "@/db/config/client";
const client = getApiClient();
const response = await client.api.videos.$get();
```

### レスポンスの検証

APIレスポンスの型安全性を確保するためにZodを使用します：

```typescript
// src/repositories/types.ts
import { z } from "zod";

// 基本レスポンススキーマ
export const baseResponseSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
});
```

```typescript
// src/repositories/videos/types.ts
import { z } from "zod";
import { authorSchema } from "../authors/types";
import { baseResponseSchema } from "../types";

// 動画スキーマ
export const videoSchema = z.object({
  id: z.string(),
  title: z.string(),
  url: z.string(),
  authorId: z.string(),
  start: z.number(),
  end: z.number(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
  // 関連する著者情報が含まれる場合
  author: authorSchema.optional(),
});

// 動画レスポンススキーマ
export const videoResponseSchema = baseResponseSchema.extend({
  video: videoSchema,
});

// 動画リストレスポンススキーマ
export const videosResponseSchema = baseResponseSchema.extend({
  videos: z.array(videoSchema),
});
```

### エラーハンドリング

クライアントサイドではResult型（neverthrow）を使用して、エラーハンドリングを型安全に行います：

```typescript
// src/repositories/utils.ts
import type { ApiError } from "./types";
import { baseResponseSchema } from "./types";
import { err } from "neverthrow";
import type { Result } from "neverthrow";

// ネットワークエラーを作成
export function createNetworkError(error: unknown): ApiError {
  return {
    type: "network",
    message: error instanceof Error ? error.message : "ネットワークエラーが発生しました",
    details: error,
  };
}

// スキーマエラーを作成
export function createSchemaError(message: string): ApiError {
  return {
    type: "schema",
    message: `レスポンスの形式が正しくありません: ${message}`,
  };
}

// HTTPエラーを処理
export async function handleHttpError(
  response: Response
): Promise<Result<never, ApiError>> {
  try {
    const data = await response.json();
    const result = baseResponseSchema.safeParse(data);
    const message = result.success ? data.message : "エラーが発生しました";

    return err({
      type: "http",
      status: response.status,
      message,
    });
  } catch (_) {
    return err({
      type: "http",
      status: response.status,
      message: "サーバーからのレスポンスの解析に失敗しました",
    });
  }
}
```

## React Queryとの統合

APIリポジトリはReact Queryと組み合わせて使用することで、キャッシュやローディング状態の管理を効率化できます：

```typescript
// src/hooks/useVideos.ts
import { getAllVideos } from "@/repositories/video";
import { useQuery } from "@tanstack/react-query";
import type { ApiError } from "@/repositories/types";

export function useVideos() {
  return useQuery({
    queryKey: ["videos"],
    queryFn: async () => {
      const result = await getAllVideos();
      return result.match(
        (data) => data,
        (error) => {
          throw error; // React Queryのエラーハンドリングに委譲
        }
      );
    },
  });
}

// コンポーネントでの使用例
function VideoList() {
  const { data: videos, error, isLoading } = useVideos();

  if (isLoading) return <div>読み込み中...</div>;

  if (error) {
    const apiError = error as ApiError;
    return <div>エラー: {apiError.message}</div>;
  }

  return (
    <div>
      <h1>動画一覧</h1>
      <ul>
        {videos.map((video) => (
          <li key={video.id}>{video.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## リポジトリテスト

リポジトリのテストでは、`setApiClient()`関数を使用してモッククライアントを注入します：

```typescript
// src/repositories/video/__tests__/index.test.ts
import { setApiClient } from "@/db/config/client";
import { getAllVideos, getVideoById } from "@/repositories/video";

describe("videoRepository", () => {
  beforeEach(() => {
    // モッククライアントの設定
    const mockClient = {
      api: {
        videos: {
          $get: jest.fn().mockResolvedValue({
            ok: true,
            json: jest.fn().mockResolvedValue({
              success: true,
              videos: [{ id: "1", title: "テスト動画" }],
            }),
          }),
          [":id"]: {
            $get: jest.fn().mockImplementation(({ param }) => ({
              ok: true,
              json: jest.fn().mockResolvedValue({
                success: true,
                video: { id: param.id, title: `テスト動画 ${param.id}` },
              }),
            })),
          },
        },
      },
    };

    setApiClient(mockClient as any);
  });

  it("getAllVideos は動画リストを返すべき", async () => {
    const result = await getAllVideos();
    expect(result.isOk()).toBe(true);

    result.match(
      (data) => {
        expect(data).toHaveLength(1);
        expect(data[0].title).toBe("テスト動画");
      },
      () => {
        fail("エラーは発生しないはずです");
      }
    );
  });

  it("getVideoById は指定したIDの動画を返すべき", async () => {
    const result = await getVideoById("123");
    expect(result.isOk()).toBe(true);

    result.match(
      (data) => {
        expect(data.id).toBe("123");
        expect(data.title).toBe("テスト動画 123");
      },
      () => {
        fail("エラーは発生しないはずです");
      }
    );
  });
});
```

## API設計のベストプラクティス

1. **一貫性**: すべてのエンドポイントで一貫したレスポンス形式を使用する
2. **型安全性**: TypeScriptとZodを使用して型安全なAPIを実装する
3. **エラーハンドリング**: Result型を使用して型安全なエラーハンドリングを実装する
4. **バリデーション**: リクエストデータを厳格にバリデーションする
5. **適切なHTTPメソッド**: リソースの操作に適したHTTPメソッドを使用する
6. **テスト容易性**: APIクライアントをモック化してテストを容易にする
7. **Result型**: クライアント側での成功/エラー結果を型安全に処理する
8. **再利用可能なスキーマ**: スキーマを再利用して一貫性を保つ
9. **シングルトンパターン**: APIクライアントを効率的に管理する
10. **リポジトリパターン**: API呼び出しを抽象化して再利用性を高める

## getRequestContext の動的インポート

サーバーサイドAPIルートでは、パフォーマンス向上のために `getRequestContext` の動的インポートを採用しています：

```typescript
// 以前の実装
import { getRequestContext } from "@cloudflare/next-on-pages";
const { DB } = getRequestContext().env;
const dbClient = createDbClient(DB);

// 新しい実装（推奨）
let dbClient = c.get("dbClient");
if (!dbClient) {
  const { getRequestContext } = await import("@cloudflare/next-on-pages");
  const { DB } = getRequestContext().env;
  dbClient = createDbClient(DB);
}
```

この実装により、必要な場合にのみ `getRequestContext` をインポートするため、初期ロード時のパフォーマンスが向上します。

## セキュリティ

このガイドラインに従うことで、サーバーとクライアント間の通信が予測可能で信頼性の高いものになります。

---
description: Kirinuki-PlaylistプロジェクトのクライアントサイドAPIアクセス規約
globs: src/repositories/**/*.ts
---

# クライアントサイドAPIアクセス

Kirinuki-Playlistでは、フロントエンドからAPIにアクセスする際に、型安全性を確保するために以下のアプローチを採用しています：

1. **Honoクライアント**: APIのエンドポイントとの型安全な通信
2. **リポジトリパターン**: APIロジックの抽象化と再利用性の向上

## Honoクライアント実装

Honoクライアントは、サーバーサイドのHonoルーターの型情報をクライアントサイドでも利用できるようにする機能です。これにより、APIエンドポイントへのリクエストが型安全になります。

### シングルトンパターンによるAPIクライアント管理

APIクライアントはシングルトンパターンで管理します。以下の原則に従ってください：

1. シングルトンインスタンスを保持する変数を定義
2. getApiClient()関数を提供し、未初期化の場合はクライアントを新規作成
3. テスト時用にsetApiClient()関数でクライアント置換機能を提供
4. 直接clientをインポートする代わりにgetApiClient()関数を使用

### getApiClient() 関数の使用

APIクライアントを取得するためには、`getApiClient()`関数を使用してください：

- ✅ 推奨: getApiClient()を呼び出してクライアントを取得
- ❌ 非推奨: 直接clientインスタンスをインポート

## リポジトリパターン実装

リポジトリパターンは、データソースへのアクセスを抽象化するデザインパターンです。APIクライアントの呼び出しとエラーハンドリングをカプセル化し、型安全性とテスト容易性を向上させます。

### ディレクトリ構造

リポジトリは以下のディレクトリ構造に従ってください：

```
src/
├── repositories/
│   ├── types.ts                # 共通型定義（BaseResponseなど）
│   ├── utils.ts                # 共通ユーティリティ関数
│   ├── test/                   # テスト用共有ロジック
│   │   └── setup.ts            # テスト環境セットアップ
│   ├── [エンティティ名]/       # 各エンティティごとのディレクトリ
│   │   ├── index.ts            # 実装
│   │   ├── types.ts            # 固有の型定義とスキーマ
│   │   ├── hooks.ts            # React Queryフック
│   │   └── __tests__/          # テスト
```

### 基本実装原則

リポジトリの実装には以下の原則を適用してください：

1. **型安全性の確保**:
   - Zodスキーマを使用してレスポンスを検証
   - 型をエクスポートして他のファイルでの再利用を可能に

2. **エラーハンドリング**:
   - Result型（neverthrow）を使用してエラー処理
   - ネットワークエラー、スキーマエラー、HTTPエラーを適切に区別

3. **APIクライアントの使用**:
   - getApiClient()関数を使用してシングルトンクライアントを取得
   - Honoクライアントの型安全な呼び出しを活用

4. **テスト容易性**:
   - 依存関係を明示的に表現
   - モックが容易な構造設計

## 型の定義と検証

### エラー型の定義

APIエラーは明確な型定義を持ち、以下のタイプを区別します：

- network: ネットワーク接続エラー
- notFound: リソースが見つからない（404）
- badRequest: 無効なリクエスト（400）
- serverError: サーバーエラー（500など）
- schema: レスポンス検証エラー

### 共通ユーティリティ関数

以下の共通ユーティリティ関数を提供してください：

- エラー作成用関数（createNetworkError, createSchemaErrorなど）
- HTTPエラー処理関数（handleHttpError）

## React Queryとの統合

リポジトリパターンはReact Queryと統合し、以下の方針に従ってください：

1. **フックの命名規則**:
   - 取得系: use[エンティティ名]s(), use[エンティティ名]()
   - 変更系: useCreate[エンティティ名](), useUpdate[エンティティ名](), useDelete[エンティティ名]()

2. **エラーハンドリング**:
   - リポジトリから返されたResult型をチェック
   - エラーの場合は適切に例外をスロー

3. **キャッシュ管理**:
   - 関連するクエリを適切にinvalidate
   - キャッシュキーを一貫して使用

## リポジトリテスト

リポジトリのテストでは、以下のアプローチを採用してください：

1. **モッククライアントの注入**:
   - setApiClient()関数を使用してモッククライアントを注入
   - 各テストケース前にモックを設定

2. **テストパターン**:
   - 成功ケース: 期待される値が返されることを確認
   - エラーケース: 適切なエラー型が返されることを確認
   - パラメータ検証: APIに正しいパラメータが渡されることを確認

## リポジトリパターンの利点

1. **型安全性**: TypeScriptと組み合わせて型安全なAPIアクセスを実現
2. **抽象化**: APIアクセスの詳細を隠蔽し、ビジネスロジックとUIから分離
3. **テスト容易性**: モックを使用したテストが容易
4. **一貫性**: 一貫したエラーハンドリングとレスポンス処理
5. **再利用性**: 共通のAPIアクセスパターンを再利用

## ベストプラクティス

1. **getApiClient() 関数の使用**: 直接`client`をインポートせず、`getApiClient()`を使用する
2. **Result型によるエラーハンドリング**: 例外ではなくResult型を返すことで型安全なエラーハンドリングを実現
3. **スキーマ検証**: Zodを使用してレスポンスを検証し、型安全性を確保
4. **テスト容易性の確保**: シングルトンパターンとモック注入による簡単なテスト
5. **一貫したディレクトリ構造**: 各リポジトリは同じディレクトリ構造に従う

## クライアントサイドでのデータフェッチ

### サーバーコンポーネントとSuspenseの使用

- データフェッチには非同期サーバーコンポーネントを使用する
- 非同期データを扱うコンポーネントはSuspenseでラップする
- ローディング状態はSuspenseのfallbackで処理する
- エラーハンドリングはError Boundaryで処理する
- クライアントコンポーネントでのデータフェッチは最小限に抑える
- 必要に応じてストリーミングを活用する
- キャッシュ戦略はNext.jsのキャッシングメカニズムを使用する

---
description: Kirinuki-PlaylistプロジェクトのクライアントサイドAPIアクセス規約
globs: src/repositories/**/*.ts, src/app/**/client.ts
---

# クライアントサイドAPIアクセス

Kirinuki-Playlistでは、フロントエンドからAPIにアクセスする際に、型安全性を確保するために以下のアプローチを採用しています：

1. **Honoクライアント**: APIのエンドポイントとの型安全な通信
2. **リポジトリパターン**: APIロジックの抽象化と再利用性の向上
3. **シングルトンパターン**: アプリケーション全体で一貫したAPIクライアントの使用

## APIクライアント管理

Kirinuki-Playlistでは、環境に応じたAPIクライアント管理と依存性注入パターンを実装しています。

### シングルトンパターンの実装

```typescript
// src/db/config/client.ts
import type { AppType } from "@/app/api/[...route]/route";
import { getBaseURL } from "@/db/config/baseUrl";
import { hc } from "hono/client";

/**
 * APIクライアントインターフェース
 * 本番環境ではhcを使用したHonoクライアント
 * テスト環境ではモッククライアントを使用するためのインターフェース
 */
export type ApiClient = ReturnType<typeof hc<AppType>>;

// シングルトンインスタンス（アプリケーション内で共有）
let currentClient: ApiClient | null = null;

/**
 * 本番環境用APIクライアントを作成
 * @returns 実際のAPIに接続するクライアント
 */
export function createProdClient(): ApiClient {
  return hc<AppType>(`${getBaseURL()}/api`);
}

/**
 * APIクライアントを設定する（主にテスト用）
 * @param client カスタムAPIクライアント
 */
export function setApiClient(client: ApiClient): void {
  currentClient = client;
}

/**
 * 現在のAPIクライアントを取得
 * セットされていない場合は本番用クライアントを作成して返す
 * すべてのリポジトリで使用すべき推奨メソッド
 */
export function getApiClient(): ApiClient {
  if (!currentClient) {
    currentClient = createProdClient();
  }
  return currentClient;
}

// 従来の実装との互換性のために残しているが、新しいコードでは使用すべきでない
// 代わりに getApiClient() を使用すること
export const client = hc<AppType>(`${getBaseURL()}/api`);
```

### getApiClient() の使用

最新のベストプラクティスとして、直接 `client` をインポートする代わりに `getApiClient()` を使用します：

```typescript
// 古い実装（非推奨）
import { client } from "@/db/config/client";

// 新しい実装（推奨）
import { getApiClient } from "@/db/config/client";

export async function getAllVideos() {
  try {
    // API呼び出しごとにクライアントを取得
    const client = getApiClient();
    const response = await client.api.videos.$get();

    // ... 以下処理
  } catch (error) {
    // ... エラーハンドリング
  }
}
```

### シングルトンパターンの利点

このアプローチには以下の利点があります：

1. **テスト容易性の向上**: テスト時に `setApiClient()` でモッククライアントを注入できます
2. **一貫性の確保**: アプリケーション全体で同じクライアントインスタンスを使用できます
3. **将来の変更への対応**: 実装の詳細を変更しても、インターフェースは維持できます

## Honoクライアント実装

Honoクライアントは、サーバーサイドのHonoルーターの型情報をクライアントサイドでも利用できるようにする機能です。これにより、APIエンドポイントへのリクエストが型安全になります。

### 基本実装

```typescript
// src/app/_components/client.ts
import { hc } from '@hono/client';

// APIのベースURL
const BASE_URL = '/api';

// APIクライアントの作成
export const apiClient = {
  // 各APIエンドポイントのクライアント
  videos: hc<VideoRouter>(`${BASE_URL}/videos`),
  playlists: hc<PlaylistRouter>(`${BASE_URL}/playlists`),
  authors: hc<AuthorRouter>(`${BASE_URL}/authors`),
};
```

### 使用例

```typescript
// APIクライアントを直接使用する例
const fetchVideos = async () => {
  try {
    const response = await apiClient.videos.$get();

    if (!response.ok) {
      throw new Error('API request failed');
    }

    const data = await response.json();

    if (data.success) {
      return data.videos;
    } else {
      throw new Error(data.error.message);
    }
  } catch (error) {
    console.error('Failed to fetch videos:', error);
    throw error;
  }
};
```

## リポジトリパターン実装

リポジトリパターンは、データソースへのアクセスを抽象化するデザインパターンです。APIクライアントの呼び出しとエラーハンドリングをカプセル化し、型安全性とテスト容易性を向上させます。

### ディレクトリ構造

```
src/
├── repositories/
│   ├── video/
│   │   ├── index.ts            # ビデオリポジトリの実装
│   │   └── types.ts            # ビデオ関連の型定義
│   ├── playlist/
│   │   ├── index.ts
│   │   └── types.ts
│   └── author/
│       ├── index.ts
│       └── types.ts
│   ├── types.ts                # 共通型定義
│   └── utils.ts                # 共通ユーティリティ
```

### 基本実装

Kirinuki-Playlistでは、各リポジトリは以下のような標準パターンに従って実装されています:

```typescript
// src/repositories/video/index.ts
import { getApiClient } from "@/db/config/client";
import type { ApiError } from "@/repositories/types";
import { videoResponseSchema, videosResponseSchema } from "@/repositories/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

// ビデオ一覧を取得
export async function getAllVideos(): Promise<Result<z.infer<typeof videosResponseSchema>["videos"], ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videosResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.videos);
  } catch (error) {
    return err(createNetworkError(error));
  }
}

// ビデオを取得
export async function getVideoById(
  id: string,
): Promise<Result<z.infer<typeof videoResponseSchema>["video"], ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos[":id"].$get({
      param: { id },
    });

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videoResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.video);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

### 型定義

```typescript
// src/repositories/types.ts
import { z } from 'zod';

// APIエラー型
export type ApiError = {
  type: 'network' | 'http' | 'schema' | 'unknown';
  status?: number;
  message: string;
  details?: unknown;
};

// ビデオスキーマ（APIレスポンスのバリデーション用）
export const videoSchema = z.object({
  id: z.string(),
  title: z.string(),
  url: z.string().url(),
  // ... 他のフィールド
});

// レスポーススキーマ
export const videoResponseSchema = z.object({
  success: z.literal(true),
  video: videoSchema,
});

export const videosResponseSchema = z.object({
  success: z.literal(true),
  videos: z.array(videoSchema),
});
```

### 共通ユーティリティ

```typescript
// src/repositories/utils.ts
import type { ApiError } from "./types";
import { err } from "neverthrow";

// ネットワークエラーを作成
export function createNetworkError(error: unknown): ApiError {
  return {
    type: "network",
    message: error instanceof Error ? error.message : "ネットワークエラーが発生しました",
    details: error,
  };
}

// スキーマエラーを作成
export function createSchemaError(message: string): ApiError {
  return {
    type: "schema",
    message: `データ形式が不正です: ${message}`,
  };
}

// HTTPエラーを処理
export function handleHttpError(response: Response) {
  return err({
    type: "http",
    status: response.status,
    message: `APIエラー: ${response.status} ${response.statusText}`,
  } as ApiError);
}
```

## エラーハンドリング

リポジトリパターンでは、`neverthrow`パッケージを使用して型安全なエラーハンドリングを実装しています。

```typescript
import { Result, ok, err } from 'neverthrow';

// 使用例
const result = await videoRepository.getById('123');

if (result.isOk()) {
  const video = result.value;
  // ビデオのデータを使用
} else {
  const error = result.error;
  // エラーハンドリング
}

// または
result.match(
  (video) => {
    // 成功時の処理
  },
  (error) => {
    // エラー時の処理
  }
);
```

## データ検証

Zodを使用して、APIからのレスポンスとAPIへのリクエストの両方を検証します。

```typescript
import { z } from 'zod';

// APIレスポンスの検証
const responseData = await response.json();
const validationResult = VideoSchema.safeParse(responseData.video);

if (validationResult.success) {
  // 検証成功
  const validData = validationResult.data;
  // 型安全に使用可能
} else {
  // 検証失敗
  console.error('Validation error:', validationResult.error);
  throw new Error('Invalid API response');
}
```

## React Queryとの統合

リポジトリパターンはReact Queryと簡単に統合できます。

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { getAllVideos, getVideoById } from '@/repositories/video';

// ビデオ一覧を取得するクエリフック
export const useVideos = () => {
  return useQuery({
    queryKey: ['videos'],
    queryFn: async () => {
      const result = await getAllVideos();

      if (result.isErr()) {
        throw result.error;
      }

      return result.value;
    }
  });
};

// ビデオを取得するクエリフック
export const useVideo = (id: string) => {
  return useQuery({
    queryKey: ['video', id],
    queryFn: async () => {
      const result = await getVideoById(id);

      if (result.isErr()) {
        throw result.error;
      }

      return result.value;
    }
  });
};
```

## テスト戦略

APIクライアントのシングルトンパターンを活用すると、テストが容易になります。

```typescript
// src/repositories/video/__tests__/index.test.ts
import { describe, it, expect, beforeEach, afterEach, vi } from 'vitest';
import { getAllVideos } from '@/repositories/video';
import { setApiClient } from '@/db/config/client';

describe('videoRepository', () => {
  // モックAPIクライアント
  const mockClient = {
    api: {
      videos: {
        $get: vi.fn(),
      },
    },
  };

  // テスト前にモッククライアントを注入
  beforeEach(() => {
    setApiClient(mockClient as any);
  });

  // テスト後にモックをリセット
  afterEach(() => {
    vi.resetAllMocks();
  });

  it('should return videos when API call is successful', async () => {
    // モックレスポンスの設定
    mockClient.api.videos.$get.mockResolvedValue({
      ok: true,
      json: async () => ({
        success: true,
        videos: [{ id: '1', title: 'Test Video' }],
      }),
    });

    // テスト対象の関数を実行
    const result = await getAllVideos();

    // アサーション
    expect(result.isOk()).toBe(true);
    if (result.isOk()) {
      expect(result.value).toHaveLength(1);
      expect(result.value[0].title).toBe('Test Video');
    }
  });
});
```

## ベストプラクティス

1. **getApiClient() の一貫した使用**
   - 直接 `client` をインポートするのではなく、常に `getApiClient()` を使用します。
   - これにより、テスト容易性と将来の変更への対応が向上します。

2. **Repository層でのエラーハンドリング**
   - APIリクエストに関連するすべてのエラーはRepository層で処理します。
   - 上位レイヤーには型安全な結果を返します。

3. **Zodによる型検証**
   - APIレスポンスは常にZodスキーマで検証します。
   - これにより、ランタイムエラーを防止し、型安全性を向上させます。

4. **neverthrowによる結果処理**
   - `Result`型を使用して成功/失敗を表現します。
   - 例外を投げるのではなく、型安全な結果を返します。

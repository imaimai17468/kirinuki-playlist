---
description: Kirinuki-PlaylistプロジェクトのクライアントサイドAPIアクセス規約
globs: src/repositories/**/*.ts, src/app/**/client.ts
---

# クライアントサイドAPIアクセス

Kirinuki-Playlistでは、フロントエンドからAPIにアクセスする際に、型安全性を確保するために以下のアプローチを採用しています：

1. **Honoクライアント**: APIのエンドポイントとの型安全な通信
2. **リポジトリパターン**: APIロジックの抽象化と再利用性の向上

## Honoクライアント実装

Honoクライアントは、サーバーサイドのHonoルーターの型情報をクライアントサイドでも利用できるようにする機能です。これにより、APIエンドポイントへのリクエストが型安全になります。

### 基本実装

```typescript
// src/app/_components/client.ts
import { hc } from '@hono/client';

// APIのベースURL
const BASE_URL = '/api';

// APIクライアントの作成
export const apiClient = {
  // 各APIエンドポイントのクライアント
  videos: hc<VideoRouter>(`${BASE_URL}/videos`),
  playlists: hc<PlaylistRouter>(`${BASE_URL}/playlists`),
  authors: hc<AuthorRouter>(`${BASE_URL}/authors`),
};
```

### 使用例

```typescript
// APIクライアントを直接使用する例
const fetchVideos = async () => {
  try {
    const response = await apiClient.videos.$get();

    if (!response.ok) {
      throw new Error('API request failed');
    }

    const data = await response.json();

    if (data.success) {
      return data.videos;
    } else {
      throw new Error(data.error.message);
    }
  } catch (error) {
    console.error('Failed to fetch videos:', error);
    throw error;
  }
};
```

## リポジトリパターン実装

リポジトリパターンは、データソースへのアクセスを抽象化するデザインパターンです。APIクライアントの呼び出しとエラーハンドリングをカプセル化し、型安全性とテスト容易性を向上させます。

### ディレクトリ構造

リポジトリのディレクトリ名はAPIルートと一貫性を持たせるため、**複数形**を使用することを推奨します：

```
src/
├── repositories/
│   ├── videos/           # 複数形を使用（推奨）
│   │   ├── index.ts      # ビデオリポジトリの実装
│   │   ├── hooks.ts      # Reactフック
│   │   ├── types.ts      # ビデオ関連の型定義（必要な場合）
│   │   └── __tests__/    # テスト
│   ├── playlists/
│   │   ├── index.ts
│   │   ├── hooks.ts
│   │   └── types.ts
│   └── authors/         # 著者用リポジトリも複数形に
│       ├── index.ts
│       ├── hooks.ts
│       └── types.ts
```

**注意**: 以前の実装では `author`（単数形）のようなディレクトリ名を使用していましたが、APIルートの命名規則（`/api/authors`）と一致させるため、リポジトリディレクトリも複数形（`authors/`）を使用するようにしてください。

### 基本実装

リポジトリは以下のような標準的なインターフェースを提供します：

```typescript
// src/repositories/video/videoRepository.ts
import { apiClient } from '@/app/_components/client';
import { Result, ResultAsync, ok, err } from 'neverthrow';
import { VideoSchema, VideoCreateSchema } from './types';
import { z } from 'zod';

// ビデオリポジトリ
export const videoRepository = {
  /**
   * 全てのビデオを取得
   */
  getAll: async (): Promise<Result<Video[], Error>> => {
    try {
      const response = await apiClient.videos.$get();
      const data = await response.json();

      if (!data.success) {
        return err(new Error(data.error.message));
      }

      // レスポンスのバリデーション
      const validationResult = z.array(VideoSchema).safeParse(data.videos);
      if (!validationResult.success) {
        return err(new Error('Invalid response format'));
      }

      return ok(validationResult.data);
    } catch (error) {
      return err(error instanceof Error ? error : new Error('Unknown error'));
    }
  },

  /**
   * IDによるビデオ取得
   */
  getById: async (id: string): Promise<Result<Video, Error>> => {
    try {
      const response = await apiClient.videos[':id'].$get({
        param: { id }
      });
      const data = await response.json();

      if (!data.success) {
        return err(new Error(data.error.message));
      }

      // レスポンスのバリデーション
      const validationResult = VideoSchema.safeParse(data.video);
      if (!validationResult.success) {
        return err(new Error('Invalid response format'));
      }

      return ok(validationResult.data);
    } catch (error) {
      return err(error instanceof Error ? error : new Error('Unknown error'));
    }
  },

  /**
   * ビデオの作成
   */
  create: async (input: VideoCreate): Promise<Result<string, Error>> => {
    try {
      // 入力のバリデーション
      const validationResult = VideoCreateSchema.safeParse(input);
      if (!validationResult.success) {
        return err(new Error('Invalid input'));
      }

      const response = await apiClient.videos.$post({
        json: validationResult.data
      });
      const data = await response.json();

      if (!data.success) {
        return err(new Error(data.error.message));
      }

      return ok(data.id);
    } catch (error) {
      return err(error instanceof Error ? error : new Error('Unknown error'));
    }
  },

  /**
   * ビデオの更新
   */
  update: async (id: string, input: Partial<VideoCreate>): Promise<Result<void, Error>> => {
    try {
      const response = await apiClient.videos[':id'].$patch({
        param: { id },
        json: input
      });
      const data = await response.json();

      if (!data.success) {
        return err(new Error(data.error.message));
      }

      return ok(undefined);
    } catch (error) {
      return err(error instanceof Error ? error : new Error('Unknown error'));
    }
  },

  /**
   * ビデオの削除
   */
  delete: async (id: string): Promise<Result<void, Error>> => {
    try {
      const response = await apiClient.videos[':id'].$delete({
        param: { id }
      });
      const data = await response.json();

      if (!data.success) {
        return err(new Error(data.error.message));
      }

      return ok(undefined);
    } catch (error) {
      return err(error instanceof Error ? error : new Error('Unknown error'));
    }
  }
};
```

## 関連エンティティと著者メタデータの拡張

### 関連データを含むレスポンス

プレイリスト、ビデオなどのリソースには関連エンティティのメタデータを含めることができます。これにより、フロントエンドでの追加のAPI呼び出しが減少し、パフォーマンスが向上します。

```typescript
// src/repositories/types.ts
import { z } from 'zod';

// 著者スキーマ
export const authorSchema = z.object({
  id: z.string(),
  name: z.string(),
  iconUrl: z.string().url(),
  bio: z.string().nullable().optional(),
  createdAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
  updatedAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
});

// ビデオスキーマ（著者データを含む拡張バージョン）
export const videoWithAuthorSchema = z.object({
  id: z.string(),
  title: z.string(),
  url: z.string().url(),
  start: z.number().nullable().optional(),
  end: z.number().nullable().optional(),
  authorId: z.string(),
  createdAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
  updatedAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
  // 著者情報を含める
  author: authorSchema,
});

// プレイリストスキーマ（ビデオと著者データを含む）
export const playlistWithVideosSchema = z.object({
  id: z.string(),
  title: z.string(),
  authorId: z.string(),
  createdAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
  updatedAt: z.number().or(z.string()).transform(val =>
    typeof val === 'string' ? new Date(val) : new Date(val)
  ),
  // 著者情報
  author: authorSchema,
  // 関連するビデオ（各ビデオには著者情報も含む）
  videos: z.array(videoWithAuthorSchema),
});
```

### 使用例: プレイリストに関連するビデオと著者データの取得

```typescript
// src/repositories/playlists/index.ts
import { getApiClient } from "@/db/config/client";
import { playlistResponseSchema } from "@/repositories/types";
import { createNetworkError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";

// プレイリストを取得（関連するビデオと著者情報を含む）
export async function getPlaylistById(id: string) {
  try {
    const client = getApiClient();
    const response = await client.api.playlists[":id"].$get({
      param: { id },
    });

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = playlistResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    // 型安全に関連データにアクセス可能
    const playlist = result.data.playlist;

    // videosプロパティには各ビデオの著者情報も含まれている
    const videos = playlist.videos || [];

    return ok(result.data.playlist);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

## 高度なエラーハンドリング

リポジトリパターンでは、`neverthrow`パッケージを使用して型安全なエラーハンドリングを実装しています。エラータイプを詳細に定義することで、より適切なエラー処理が可能になります。

### エラー型の定義

```typescript
// src/repositories/types.ts
import { z } from 'zod';

// APIエラーの型定義
export type ApiError =
  | { type: "network"; message: string }
  | { type: "notFound"; message: string }
  | { type: "badRequest"; message: string }
  | { type: "serverError"; message: string }
  | { type: "schema"; message: string };

// ユーティリティ関数
export function createNetworkError(error: unknown): ApiError {
  return {
    type: "network",
    message: error instanceof Error ? error.message : "ネットワークエラーが発生しました",
  };
}

export function createSchemaError(message: string): ApiError {
  return {
    type: "schema",
    message: `レスポンスの形式が正しくありません: ${message}`,
  };
}

// HTTPエラーを処理する関数
export async function handleHttpError(response: Response) {
  try {
    const data = await response.json();

    // ステータスコードに基づいてエラータイプを決定
    switch (response.status) {
      case 404:
        return err<never, ApiError>({
          type: "notFound",
          message: data.message || "リソースが見つかりませんでした",
        });
      case 400:
        return err<never, ApiError>({
          type: "badRequest",
          message: data.message || "無効なリクエストです",
        });
      default:
        return err<never, ApiError>({
          type: "serverError",
          message: data.message || "サーバーエラーが発生しました",
        });
    }
  } catch (error) {
    return err<never, ApiError>({
      type: "serverError",
      message: "レスポンスの処理中にエラーが発生しました",
    });
  }
}
```

### エラー処理の使用例

```typescript
// コンポーネントでのエラー処理
const { data, error } = usePlaylist(playlistId);

if (error) {
  switch (error.type) {
    case "notFound":
      return <NotFoundPage message="プレイリストが見つかりませんでした" />;
    case "network":
      return <ErrorMessage message="ネットワークエラー: インターネット接続を確認してください" />;
    case "schema":
      // 開発者向けのログ
      console.error("スキーマエラー:", error.message);
      return <ErrorMessage message="データの形式が正しくありません" />;
    default:
      return <ErrorMessage message="エラーが発生しました" />;
  }
}
```

## データ検証

Zodを使用して、APIからのレスポンスとAPIへのリクエストの両方を検証します。

```typescript
import { z } from 'zod';

// APIレスポンスの検証
const responseData = await response.json();
const validationResult = VideoSchema.safeParse(responseData.video);

if (validationResult.success) {
  // 検証成功
  const validData = validationResult.data;
  // 型安全に使用可能
} else {
  // 検証失敗
  console.error('Validation error:', validationResult.error);
  throw new Error('Invalid API response');
}
```

## React Queryとの統合

リポジトリパターンはReact Queryと簡単に統合できます。

```typescript
import { useQuery, useMutation, useQueryClient } from '@tanstack/react-query';
import { videoRepository } from '@/repositories/video/videoRepository';

// ビデオ一覧を取得するクエリフック
export const useVideos = () => {
  return useQuery({
    queryKey: ['videos'],
    queryFn: async () => {
      const result = await videoRepository.getAll();

      if (result.isErr()) {
        throw result.error;
      }

      return result.value;
    }
  });
};

// ビデオを作成するミューテーションフック
export const useCreateVideo = () => {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async (input: VideoCreate) => {
      const result = await videoRepository.create(input);

      if (result.isErr()) {
        throw result.error;
      }

      return result.value;
    },
    onSuccess: () => {
      // 成功時にビデオ一覧を再取得
      queryClient.invalidateQueries({ queryKey: ['videos'] });
    }
  });
};
```

## 重要な教訓

Honoクライアントとリポジトリパターンの実装から得られた重要な教訓：

1. **ルーターの実装がクライアントの型安全性に影響する**
   - サーバーサイドのHonoルーターの実装方法が、クライアントサイドの型安全性に大きく影響します。
   - 適切な型付けとパラメータ定義が重要です。

2. **ベースパスの考慮**
   - Honoクライアントを初期化する際は、APIのベースパスを適切に設定する必要があります。
   - Next.jsの設定によって異なる場合があります。

3. **型安全な組み合わせ**
   - Honoクライアント + Zod + neverthrowの組み合わせにより、フロントエンドからバックエンドまで一貫した型安全性を確保できます。
   - この組み合わせはエラーハンドリングと検証を強化します。

4. **レスポンス形式の一貫性**
   - すべてのAPIエンドポイントで一貫したレスポンス形式を維持することが重要です。
   - 型チェックが容易になり、リポジトリ実装が簡潔になります。

5. **関連エンティティのメタデータ**
   - 関連エンティティのメタデータを含めることで、クライアント側での追加のAPI呼び出しを減らせます。
   - 例: プレイリストの取得時に関連するビデオと著者情報も一緒に取得する。

6. **詳細なエラータイプ**
   - より詳細なエラータイプを定義することで、ユーザーに適切なフィードバックを提供できます。
   - ネットワークエラー、未検出エラー、バリデーションエラーなど、異なるエラータイプに対して異なる処理を実装します。

## ベストプラクティス

1. **Repository層でのエラーハンドリング**
   - APIリクエストに関連するすべてのエラーはRepository層で処理します。
   - 上位レイヤーには型安全な結果を返します。

2. **適切なキャッシュ戦略**
   - React Queryのキャッシュメカニズムを活用します。
   - API呼び出しを最小限に抑え、ユーザーエクスペリエンスを向上させます。

3. **テスト可能性**
   - リポジトリパターンを使用すると、APIロジックをモックしてテストが容易になります。
   - モックサーバーやMSWを使用してE2Eテストを実施できます。

4. **再利用可能なエラー処理**
   - 共通のエラー処理ロジックを実装します。
   - エラーメッセージの変換や分類など、再利用可能な関数を作成します。

5. **詳細なエラータイプ**
   - より詳細なエラータイプを定義することで、ユーザーに適切なフィードバックを提供できます。
   - ネットワークエラー、未検出エラー、バリデーションエラーなど、異なるエラータイプに対して異なる処理を実装します。

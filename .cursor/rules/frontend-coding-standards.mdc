# Kirinuki-Playlist プロジェクトルール

## コードスタイル

### 全般

- TypeScript を使用する
- コンポーネントは関数コンポーネントとして実装する
- 可能な限り型定義を明示する
- `any`型の使用は避ける
- コンポーネントの props には適切な型定義を行う
- 命名規則はキャメルケース（変数・関数）、パスカルケース（コンポーネント・型）を使用する
- 関数の戻り値の型は明示的に定義する
- 複雑な型は型エイリアスまたはインターフェースとして定義する

### ファイル構成

- コンポーネントは機能ごとにディレクトリを分ける
- 関連するコンポーネントは同じディレクトリに配置する
- テストファイルは`__tests__`ディレクトリに配置する
- 定数は`consts.ts`ファイルに定義する
- 国際化関連のファイルは`i18n`ディレクトリに配置する
- 型定義は`types.ts`ファイルに集約する
- フックは`hooks.ts`ファイルに実装する
- ユーティリティ関数は`utils.ts`ファイルに実装する

### コンポーネント

- UI コンポーネントは`src/components/ui`ディレクトリに配置する
- 機能コンポーネントは`src/components/parts`ディレクトリに配置する
- クライアントコンポーネントには`"use client";`ディレクティブを先頭に記述する
- コンポーネントの props は分割代入を使用する
- コンポーネントは適切な名前空間を持つ（例: `Nav*`, `App*`）
- 大きなコンポーネントは小さなコンポーネントに分割する
- コンポーネントの責務は単一にする（単一責任の原則）

### フック

- カスタムフックの名前は`use`プレフィックスで始める
- フックは再利用可能な形で実装する
- フックの引数と戻り値には適切な型定義を行う
- 複雑なロジックはフックに抽出する
- 状態管理ロジックはコンポーネントから分離する
- 副作用は`useEffect`内に限定する
- 依存配列は明示的に指定する

### スタイリング

- スタイリングは Tailwind CSS を使用する
- クラス名の結合には`cn`ユーティリティを使用する
- 条件付きクラスには`className={cn()}`パターンを使用する
- コンポーネントのバリエーションには`class-variance-authority`を使用する
- 複雑なスタイルはコンポーネント化する
- レスポンシブデザインはTailwindのブレークポイントを使用する

## テスト

### テスト全般

- テストフレームワークは Bun のテストランナーを使用する
- テストファイルの命名は`*.test.tsx`とする（コンポーネント）、`*.test.ts`とする（非UIコード）
- 各テストの後に`cleanup()`を実行する
- テストケースは英語または日本語で記述する（プロジェクトで統一する）
- テストケースの説明は「〜すべき」「〜が期待される」などの形式で記述する
- モックは最小限に留め、実際の動作に近い形でテストする
- テストカバレッジは定期的に確認する
- 重要なロジックには必ずテストを書く

### コンポーネントテスト

- コンポーネントのレンダリングテストを必ず実装する
- 状態変化を伴うコンポーネントは、状態変化のテストを実装する
- ユーザーインタラクションのテストには`fireEvent`を使用する
- コンテキストを使用するコンポーネントは、テスト時にプロバイダーでラップする
- モックデータは各テストファイル内で定義する
- 外部依存（Next.js のルーターなど）はモック化する
- スナップショットテストは慎重に使用する
- アクセシビリティテストを実装する

### フックのテスト

- フックのテストには`@testing-library/react`の`renderHook`を使用する
- フックの初期状態が正しく設定されていることを検証する
- 状態更新関数（トグル関数など）が正しく動作することを検証する
- 複雑なロジックを持つ関数は個別にテストする
- 外部依存（プレーヤーなど）はモック化する
- 状態変更を伴うテストでは`act`関数でラップする
- エッジケース（空の配列、境界値など）のテストを実装する
- 複合的な状態変化（ループモードとシャッフルモードの組み合わせなど）をテストする
- テストデータは実際のデータ構造に準拠させる
- 参照型の値（ref）を直接変更せず、適切なハンドラー経由で設定する
- 非同期処理を含むフックは適切に待機処理を実装する

### テストの構造

- `describe`ブロックでコンポーネント名やフック名をグループ化する
- `it`ブロックでテストケースを記述する
- テストケースは明確な動作を説明する形式で記述する
- 各テストは独立して実行できるようにする
- `beforeEach`/`afterEach`でテスト環境のセットアップ/クリーンアップを行う
- 共通のテストデータや設定は変数として抽出する
- 複雑なテストケースは小さな関数に分割する
- 関連するテストケースはネストした`describe`でグループ化する

### モックとスタブ

- `jest.fn()`を使用して関数をモック化する
- 外部APIや依存関係は適切にモック化する
- モックオブジェクトは実際のインターフェースに準拠させる
- 複雑なモックは専用のヘルパー関数として実装する
- テスト間でモックの状態が漏れないように注意する
- モックの検証には`toHaveBeenCalled`や`toHaveBeenCalledWith`を使用する
- 必要に応じて`jest.spyOn`を使用して既存のオブジェクトをスパイする

## プロジェクト固有のルール

### サイドバーコンポーネント

- サイドバー関連のコンポーネントは`src/components/parts/sidebar`ディレクトリに配置する
- ナビゲーション関連のコンポーネントは`navigation`サブディレクトリに配置する
- サイドバーのアイテム定義は`consts.ts`に集約する
- サイドバーコンポーネントは`SidebarProvider`でラップして使用する

### ビデオプレーヤー

- プレーヤー関連のコンポーネントは`src/components/parts/video-player`ディレクトリに配置する
- プレーヤーの状態管理は`useVideoPlayer`フックを使用する
- プレーヤーのイベントハンドラーは適切にモック化してテストする
- シャッフルモードとループモードの組み合わせは適切にテストする

### ブレッドクラム

- パスセグメントに基づいてブレッドクラムを生成する
- 最後のセグメントは`BreadcrumbPage`として表示する
- 中間のセグメントは`BreadcrumbLink`として表示する

### ユーザーインターフェース

- ドロップダウンメニューには`@radix-ui/react-dropdown-menu`を使用する
- アバターには`@radix-ui/react-avatar`を使用する
- アイコンには`lucide-react`を使用する
- 折りたたみ可能な要素には`@radix-ui/react-collapsible`を使用する

## コード品質

### リンター・フォーマッター

- Biome を使用してコードの品質を保つ
- `biome check`でコードをチェックする
- `biome format`でコードをフォーマットする
- コミット前に lefthook を使用して自動チェックを行う

### 型チェック

- `tsc --noEmit`で型チェックを行う
- 型エラーは修正してからコミットする
- 複雑な型は適切に分割する
- ジェネリック型は適切に制約を設ける

### テスト実行

- `bun test`でテストを実行する
- `bun test --watch`で開発中のテスト監視を行う
- CI では全テストが通過することを確認する
- テストカバレッジレポートを定期的に確認する
- 重要なコードパスは必ずテストでカバーする

---
description: Kirinuki-Playlistプロジェクトのフロントエンド開発コーディング規約
globs: src/**/*.{ts,tsx}
---
# Kirinuki-Playlist プロジェクトルール

## コードスタイル

### 全般

- TypeScript を使用する
- コンポーネントは関数コンポーネントとして実装する
- 可能な限り型定義を明示する
- `any`型の使用は避ける
- コンポーネントの props には適切な型定義を行う
- 命名規則はキャメルケース（変数・関数）、パスカルケース（コンポーネント・型）を使用する
- 関数の戻り値の型は明示的に定義する
- 複雑な型は型エイリアスまたはインターフェースとして定義する

### ファイル構成

- コンポーネントは機能ごとにディレクトリを分ける
- 関連するコンポーネントは同じディレクトリに配置する
- テストファイルは`__tests__`ディレクトリに配置する
- 定数は`consts.ts`ファイルに定義する
- 国際化関連のファイルは`i18n`ディレクトリに配置する
- 型定義は`types.ts`ファイルに集約する
- フックは`hooks.ts`ファイルに実装する
- ユーティリティ関数は`utils.ts`ファイルに実装する

### コンポーネント

- UI コンポーネントは`src/components/ui`ディレクトリに配置する
- 機能コンポーネントは`src/components/parts`ディレクトリに配置する
- クライアントコンポーネントには`"use client";`ディレクティブを先頭に記述する
- コンポーネントの props は分割代入を使用する
- コンポーネントは適切な名前空間を持つ（例: `Nav*`, `App*`）
- 大きなコンポーネントは小さなコンポーネントに分割する
- コンポーネントの責務は単一にする（単一責任の原則）

### フック

- カスタムフックの名前は`use`プレフィックスで始める
- フックは再利用可能な形で実装する
- フックの引数と戻り値には適切な型定義を行う
- 複雑なロジックはフックに抽出する
- 状態管理ロジックはコンポーネントから分離する
- 副作用は`useEffect`内に限定する
- 依存配列は明示的に指定する

### スタイリング

- スタイリングは Tailwind CSS を使用する
- クラス名の結合には`cn`ユーティリティを使用する
- 条件付きクラスには`className={cn()}`パターンを使用する
- コンポーネントのバリエーションには`class-variance-authority`を使用する
- 複雑なスタイルはコンポーネント化する
- レスポンシブデザインはTailwindのブレークポイントを使用する

### リポジトリパターン

- APIアクセスはリポジトリパターンを使用して抽象化する
- リポジトリは`src/repositories/`ディレクトリに配置する
- 各リソース（ビデオ、プレイリストなど）ごとにディレクトリを作成する
- リポジトリファイルは`index.ts`として実装する
- APIクライアントのインポートには`getApiClient()`関数を使用する
- エラーハンドリングはResult型（neverthrow）を使用して実装する
- レスポンスのバリデーションにはZodを使用する
- テストでは適切にAPIクライアントをモック化する

#### getApiClient() 関数の使用

```typescript
// 推奨されるAPIクライアントの使用方法
import { getApiClient } from "@/db/config/client";

export async function getAllVideos() {
  try {
    // client変数を直接インポートするのではなく、getApiClient()を使用
    const client = getApiClient();
    const response = await client.api.videos.$get();
    // 以降の処理...
  } catch (error) {
    // エラーハンドリング...
  }
}
```

#### リポジトリの標準的な実装パターン

```typescript
// src/repositories/video/index.ts
import { getApiClient } from "@/db/config/client";
import type { ApiError } from "@/repositories/types";
import { videoResponseSchema, videosResponseSchema } from "@/repositories/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

// 型をエクスポートして他のファイルで再利用可能にする
export type Video = z.infer<typeof videoResponseSchema>["video"];
export type Videos = z.infer<typeof videosResponseSchema>["videos"];

// リソース一覧を取得する関数
export async function getAllVideos(): Promise<Result<Videos, ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videosResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.videos);
  } catch (error) {
    return err(createNetworkError(error));
  }
}

// リソースを取得する関数
export async function getVideoById(id: string): Promise<Result<Video, ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos[":id"].$get({
      param: { id },
    });

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videoResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.video);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

## テスト

### テスト全般

- テストフレームワークは Bun のテストランナーを使用する
- テストファイルの命名は`*.test.tsx`とする（コンポーネント）、`*.test.ts`とする（非UIコード）
- 各テストの後に`cleanup()`を実行する
- テストケースは英語または日本語で記述する（プロジェクトで統一する）
- テストケースの説明は「〜すべき」「〜が期待される」などの形式で記述する
- モックは最小限に留め、実際の動作に近い形でテストする
- テストカバレッジは定期的に確認する
- 重要なロジックには必ずテストを書く

### コンポーネントテスト

- コンポーネントのレンダリングテストを必ず実装する
- 状態変化を伴うコンポーネントは、状態変化のテストを実装する
- ユーザーインタラクションのテストには`fireEvent`を使用する
- コンテキストを使用するコンポーネントは、テスト時にプロバイダーでラップする
- モックデータは各テストファイル内で定義する
- 外部依存（Next.js のルーターなど）はモック化する
- スナップショットテストは慎重に使用する
- アクセシビリティテストを実装する

### フックのテスト

- フックのテストには`@testing-library/react`の`renderHook`を使用する
- フックの初期状態が正しく設定されていることを検証する
- 状態更新関数（トグル関数など）が正しく動作することを検証する
- 複雑なロジックを持つ関数は個別にテストする
- 外部依存（プレーヤーなど）はモック化する
- 状態変更を伴うテストでは`act`関数でラップする
- エッジケース（空の配列、境界値など）のテストを実装する
- 複合的な状態変化（ループモードとシャッフルモードの組み合わせなど）をテストする
- テストデータは実際のデータ構造に準拠させる
- 参照型の値（ref）を直接変更せず、適切なハンドラー経由で設定する
- 非同期処理を含むフックは適切に待機処理を実装する

### リポジトリのテスト

- リポジトリのテストでは`setApiClient()`関数を使用してAPIクライアントをモック化する
- APIレスポンスのモックデータは実際のレスポンス形式に準拠する
- 成功ケースと失敗ケースの両方をテストする
- ネットワークエラー、HTTPエラー、スキーマエラーの各シナリオをテストする
- Result型の戻り値が適切に処理されることを確認する

```typescript
// src/repositories/video/__tests__/index.test.ts
import { setApiClient } from "@/db/config/client";
import { getAllVideos } from "@/repositories/video";

describe("videoRepository", () => {
  beforeEach(() => {
    // APIクライアントのモック設定
    const mockClient = {
      api: {
        videos: {
          $get: jest.fn().mockResolvedValue({
            ok: true,
            json: jest.fn().mockResolvedValue({
              success: true,
              videos: [{ id: "1", title: "テスト動画" }],
            }),
          }),
        },
      },
    };
    setApiClient(mockClient as any);
  });

  it("getAllVideos が成功した場合、動画リストを返すべき", async () => {
    const result = await getAllVideos();
    expect(result.isOk()).toBe(true);

    result.match(
      (data) => {
        expect(data).toHaveLength(1);
        expect(data[0].title).toBe("テスト動画");
      },
      () => {
        fail("エラーは発生しないはずです");
      }
    );
  });

  // 失敗ケースのテスト...
});
```

### テストの構造

- `describe`ブロックでコンポーネント名やフック名をグループ化する
- `it`ブロックでテストケースを記述する
- テストケースは明確な動作を説明する形式で記述する
- 各テストは独立して実行できるようにする
- `beforeEach`/`afterEach`でテスト環境のセットアップ/クリーンアップを行う
- 共通のテストデータや設定は変数として抽出する
- 複雑なテストケースは小さな関数に分割する
- 関連するテストケースはネストした`describe`でグループ化する

### モックとスタブ

- `jest.fn()`を使用して関数をモック化する
- 外部APIや依存関係は適切にモック化する
- モックオブジェクトは実際のインターフェースに準拠させる
- 複雑なモックは専用のヘルパー関数として実装する
- テスト間でモックの状態が漏れないように注意する
- モックの検証には`toHaveBeenCalled`や`toHaveBeenCalledWith`を使用する
- 必要に応じて`jest.spyOn`を使用して既存のオブジェクトをスパイする

## プロジェクト固有のルール

### サイドバーコンポーネント

- サイドバー関連のコンポーネントは`src/components/parts/sidebar`ディレクトリに配置する
- ナビゲーション関連のコンポーネントは`navigation`サブディレクトリに配置する
- サイドバーのアイテム定義は`consts.ts`に集約する
- サイドバーコンポーネントは`SidebarProvider`でラップして使用する

### ビデオプレーヤー

- プレーヤー関連のコンポーネントは`src/components/parts/video-player`ディレクトリに配置する
- プレーヤーの状態管理は`useVideoPlayer`フックを使用する
- プレーヤーのイベントハンドラーは適切にモック化してテストする
- シャッフルモードとループモードの組み合わせは適切にテストする

### ブレッドクラム

- パスセグメントに基づいてブレッドクラムを生成する
- 最後のセグメントは`BreadcrumbPage`として表示する
- 中間のセグメントは`BreadcrumbLink`として表示する

### ユーザーインターフェース

- ドロップダウンメニューには`@radix-ui/react-dropdown-menu`を使用する
- アバターには`@radix-ui/react-avatar`を使用する
- アイコンには`lucide-react`を使用する
- 折りたたみ可能な要素には`@radix-ui/react-collapsible`を使用する

### APIクライアント

- APIクライアントは`getApiClient()`関数を使用して取得する
- 直接`client`変数をインポートするのではなく、常に`getApiClient()`を使用する
- 新しいリポジトリを作成する際は既存のリポジトリのパターンに従う
- エラーハンドリングはResult型を使用して統一的に実装する
- 型安全性を確保するためにZodによるレスポンスバリデーションを実装する
- テスト用モッククライアントの注入には`setApiClient()`関数を使用する

```typescript
// 非推奨 ❌
import { client } from "@/db/config/client";
const response = await client.api.videos.$get();

// 推奨 ✅
import { getApiClient } from "@/db/config/client";
const client = getApiClient();
const response = await client.api.videos.$get();
```

## コード品質

### リンター・フォーマッター

- Biome を使用してコードの品質を保つ
- `biome check`でコードをチェックする
- `biome format`でコードをフォーマットする
- コミット前に lefthook を使用して自動チェックを行う

### 型チェック

- `tsc --noEmit`で型チェックを行う
- 型エラーは修正してからコミットする
- 複雑な型は適切に分割する
- ジェネリック型は適切に制約を設ける

### テスト実行

- `bun test`でテストを実行する
- `bun test --watch`で開発中のテスト監視を行う
- CI では全テストが通過することを確認する
- テストカバレッジレポートを定期的に確認する
- 重要なコードパスは必ずテストでカバーする

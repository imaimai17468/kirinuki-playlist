---
description: Next.js x Hono アプリケーションにおけるCloudflare D1データベース管理ガイド
globs: src/db/**/*.ts,src/repositories/**/*.ts
---

# Cloudflare D1データベース管理ガイド

## データベース構成

Kirinuki-Playlistプロジェクトでは、本番環境ではCloudflare D1、開発環境ではLibSQLをデータベースとして使用し、Drizzle ORMを通じてアクセスします。

### ディレクトリ構造

```
src/
├── db/
│   ├── config/                # データベース構成
│   │   ├── database.ts        # DB接続管理
│   │   ├── client.ts          # APIクライアント
│   │   ├── hono.ts            # Honoアプリ構成
│   │   └── test-database.ts   # テスト環境DB設定
│   ├── models/                # データモデル定義
│   │   ├── videos.ts
│   │   ├── authors.ts
│   │   ├── playlists.ts
│   │   ├── playlist_videos.ts
│   │   └── index.ts           # モデルのエクスポート
│   ├── services/              # サービス層
│   │   ├── videos.ts
│   │   ├── authors.ts
│   │   └── playlists.ts
│   ├── middlewares/           # DB関連ミドルウェア
│   │   └── error-handler.ts   # エラーハンドリング
│   └── types/
│       └── bindings.ts        # 型定義
├── repositories/              # クライアントサイド用データアクセス層
│   ├── video/
│   ├── author/
│   └── playlist/
└── app/
    └── api/                   # API実装
        └── [...route]/        # Honoルート実装
```

## データベースクライアント管理

Kirinuki-Playlistプロジェクトでは、異なる環境（本番、開発、テスト）に対応する柔軟なデータベースクライアント管理を実装しています：

### データベースクライアント

```typescript
// src/db/config/database.ts
import type { D1Database } from "@cloudflare/workers-types";
import { createClient } from "@libsql/client/web";
import { drizzle } from "drizzle-orm/d1";
import { drizzle as drizzleSqlite } from "drizzle-orm/libsql";

/**
 * 本番環境用のデータベースクライアントを作成します
 * Cloudflare WorkersのD1データベースを使用
 */
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};

/**
 * 開発環境用のデータベースクライアントを作成します
 * Edge環境対応版 - マイグレーションなし
 * libsqlサーバーに接続
 */
export const createDevDbClient = async () => {
  // WebクライアントでlibsqlサーバーにHTTP接続
  const url = process.env.LIBSQL_URL || "http://localhost:8080";
  const client = createClient({
    url,
  });

  // Drizzle ORMのクライアントを作成 - マイグレーションなし
  return drizzleSqlite(client);
};
```

### テスト環境用データベース

```typescript
// src/db/config/test-database.ts
import Database from "bun:sqlite";
import { drizzle as drizzleSqlite } from "drizzle-orm/bun-sqlite";
import { migrate as migrateSqlite } from "drizzle-orm/bun-sqlite/migrator";

/**
 * テスト環境用のデータベースクライアントを作成します
 * インメモリSQLiteデータベースを使用
 */
export const createTestDbClient = async (migrationsPath = "./drizzle") => {
  const client = new Database(":memory:");
  const db = drizzleSqlite(client);
  await migrateSqlite(db, { migrationsFolder: migrationsPath });

  return drizzleSqlite(client);
};
```

## API構成と依存性注入

HonoアプリケーションとAPIルーターは、依存性注入パターンを使用して実装されています：

```typescript
// src/db/config/hono.ts
import { authorsRouter } from "@/app/api/[...route]/author";
import { playlistsRouter } from "@/app/api/[...route]/playlists";
import { videosRouter } from "@/app/api/[...route]/videos";
import type { createDbClient } from "@/db/config/database";
import { createDevDbClient } from "@/db/config/database";
import type { createTestDbClient } from "@/db/config/test-database";
import { errorHandler } from "@/db/middlewares/error-handler";
import type { Bindings } from "@/db/types/bindings";
import type { MiddlewareHandler } from "hono";
import { Hono } from "hono";

// DBクライアント型の定義
export type DbClient =
  | ReturnType<typeof createDbClient>
  | Awaited<ReturnType<typeof createTestDbClient>>
  | Awaited<ReturnType<typeof createDevDbClient>>;

// 依存性を格納するための型拡張
type Variables = {
  dbClient?: DbClient;
};

// Bindings型にVariablesを追加した合成型
export type AppEnv = {
  Bindings: Bindings;
  Variables: Variables;
};

/**
 * 環境に応じたHonoアプリケーションを作成する関数
 * 本番環境では実際のD1データベースを使用し、テスト環境ではテスト用DBクライアントを使用
 */
export function createHonoApp(options?: { dbClient?: DbClient }) {
  // 依存性をコンテキストに注入するミドルウェア
  const injectDependencies: MiddlewareHandler<AppEnv> = async (c, next) => {
    // dbClientが直接提供されている場合はそれを使用
    if (options?.dbClient) {
      c.set("dbClient", options.dbClient);
    } else if (process.env.NODE_ENV === "development") {
      const client = await createDevDbClient();
      c.set("dbClient", client);
    }
    await next();
  };

  // Honoアプリケーションの組み立て
  const app = new Hono<AppEnv>()
    .basePath("/api")
    .use("*", errorHandler)
    .use("*", injectDependencies) // 依存性注入ミドルウェア
    .route("/authors", authorsRouter)
    .route("/videos", videosRouter)
    .route("/playlists", playlistsRouter)
    .get("/hello", (c) => c.json({ status: "ok" }));

  return app;
}
```

## サービス層の実装と依存性注入パターン

サービス層ではデータベースクライアントを外部から注入する依存性注入パターンを採用し、テスト容易性と柔軟性を高めています：

```typescript
// src/db/services/videos.ts
import type { DbClient } from "@/db/config/hono";
import { videos } from "@/db/models/videos";
import { authors } from "@/db/models/authors";
import { NotFoundError, DatabaseError } from "@/db/utils/errors";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";

// 型定義
export type Video = {
  id: string;
  title: string;
  url: string;
  start: number | null;
  end: number | null;
  authorId: string;
  createdAt: Date;
  updatedAt: Date;
  author: {
    id: string;
    name: string;
    iconUrl: string;
    bio: string | null;
  };
};

export type VideoInsert = {
  title: string;
  url: string;
  authorId: string;
  start?: number;
  end?: number;
};

export type VideoUpdate = Partial<VideoInsert>;

/**
 * 動画サービスを作成する関数
 * 依存性注入パターンを使用して、DBクライアントを外部から注入できるようにする
 */
export function createVideoService(dbClient: DbClient) {
  return {
    /**
     * すべての動画を著者情報付きで取得する
     */
    async getAllVideos(): Promise<Video[]> {
      try {
        // JOIN操作を使用して動画と著者情報を一度に取得
        const results = await dbClient
          .select()
          .from(videos)
          .innerJoin(authors, eq(videos.authorId, authors.id))
          .all();

        // 結果を適切な形式に変換
        return results.map((row) => ({
          id: row.videos.id,
          title: row.videos.title,
          url: row.videos.url,
          start: row.videos.start,
          end: row.videos.end,
          authorId: row.videos.authorId,
          createdAt: row.videos.createdAt,
          updatedAt: row.videos.updatedAt,
          author: {
            id: row.authors.id,
            name: row.authors.name,
            iconUrl: row.authors.iconUrl,
            bio: row.authors.bio,
          },
        }));
      } catch (error) {
        throw new DatabaseError(
          `動画一覧の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    /**
     * IDによって動画を著者情報付きで取得する
     */
    async getVideoById(id: string): Promise<Video> {
      try {
        // JOIN操作を使用して動画と著者情報を一度に取得
        const result = await dbClient
          .select()
          .from(videos)
          .innerJoin(authors, eq(videos.authorId, authors.id))
          .where(eq(videos.id, id))
          .get();

        if (!result) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }

        return {
          id: result.videos.id,
          title: result.videos.title,
          url: result.videos.url,
          start: result.videos.start,
          end: result.videos.end,
          authorId: result.videos.authorId,
          createdAt: result.videos.createdAt,
          updatedAt: result.videos.updatedAt,
          author: {
            id: result.authors.id,
            name: result.authors.name,
            iconUrl: result.authors.iconUrl,
            bio: result.authors.bio,
          },
        };
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    /**
     * 新しい動画を作成する
     */
    async createVideo(data: VideoInsert): Promise<string> {
      // 現在の日時
      const now = new Date();
      // 一意のIDを生成
      const id = nanoid();

      try {
        // 著者が存在するか確認
        const author = await dbClient
          .select()
          .from(authors)
          .where(eq(authors.id, data.authorId))
          .get();

        if (!author) {
          throw new NotFoundError(`ID: ${data.authorId} の著者が見つかりません`);
        }

        // 動画をデータベースに挿入
        await dbClient.insert(videos).values({
          id,
          ...data,
          createdAt: now,
          updatedAt: now,
        });

        return id;
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の作成中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    // その他のメソッド...
  };
}
```

### サービス層のテスト

依存性注入パターンを使用したサービス層は、テスト容易性が向上し、実際のデータベースを使わずにユニットテストを実行できます：

```typescript
// src/db/services/__tests__/videos.test.ts
import { beforeEach, describe, expect, test } from "bun:test";
import { eq } from "drizzle-orm";
import { createTestDbClient } from "../../config/test-database";
import { authors } from "../../models/authors";
import { videos } from "../../models/videos";
import { NotFoundError } from "../../utils/errors";
import { createVideoService } from "../videos";

// テストデータ
const testAuthors = [
  {
    id: "author1",
    name: "テスト著者1",
    iconUrl: "https://example.com/icon1.png",
    bio: "テスト著者1の自己紹介",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  // ...
];

const testVideos = [
  {
    id: "video1",
    title: "テスト動画1",
    url: "https://example.com/video1",
    start: 0,
    end: 60,
    authorId: "author1",
    createdAt: new Date(),
    updatedAt: new Date(),
  },
  // ...
];

// ヘルパー関数: データベースとサービスの初期化
async function setupDatabase() {
  const dbClient = await createTestDbClient();
  const service = createVideoService(dbClient);

  // テーブルをクリア
  await dbClient.delete(videos).run();
  await dbClient.delete(authors).run();

  // テストデータを挿入
  for (const author of testAuthors) {
    await dbClient.insert(authors).values(author);
  }

  for (const video of testVideos) {
    await dbClient.insert(videos).values(video);
  }

  return { dbClient, service };
}

describe("videoService", () => {
  describe("getVideoById", () => {
    let service: ReturnType<typeof createVideoService>;

    beforeEach(async () => {
      const result = await setupDatabase();
      service = result.service;
    });

    test("IDを指定して動画を取得できること", async () => {
      const result = await service.getVideoById("video1");

      expect(result.id).toBe("video1");
      expect(result.title).toBe("テスト動画1");
      expect(result.author.name).toBe("テスト著者1");
    });

    test("存在しないIDの場合はNotFoundErrorをスローすること", async () => {
      await expect(service.getVideoById("non-existent")).rejects.toThrow(NotFoundError);
    });
  });

  // 他のテストケース...
});
```

## APIクライアント管理

フロントエンドからAPIにアクセスするためのクライアント実装：

```typescript
// src/db/config/client.ts
import type { AppType } from "@/app/api/[...route]/route";
import { getBaseURL } from "@/db/config/baseUrl";
import { hc } from "hono/client";

/**
 * APIクライアントインターフェース
 * 本番環境ではhcを使用したHonoクライアント
 * テスト環境ではtestClientを使用するためのインターフェース
 */
export type ApiClient = ReturnType<typeof hc<AppType>>;

// デフォルトのAPIクライアント（シングルトンパターン）
let currentClient: ApiClient | null = null;

/**
 * 本番環境用APIクライアントを作成
 * @returns 実際のAPIに接続するクライアント
 */
export function createProdClient(): ApiClient {
  return hc<AppType>(`${getBaseURL()}/api`);
}

/**
 * テスト環境用APIクライアントを作成・設定
 * @param client テスト用クライアント
 */
export function setApiClient(client: ApiClient): void {
  currentClient = client;
}

/**
 * 現在のAPIクライアントを取得
 * セットされていない場合は本番用クライアントを作成
 */
export function getApiClient(): ApiClient {
  if (!currentClient) {
    currentClient = createProdClient();
  }
  return currentClient;
}

// 従来の実装との互換性のために、デフォルトの実装もそのまま残す
export const client = hc<AppType>(`${getBaseURL()}/api`);
```

## リポジトリパターン実装

データアクセスロジックは、サーバーサイドではサービス層、クライアントサイドではリポジトリパターンに従って実装します：

```typescript
// src/repositories/video/index.ts の例
import { getApiClient } from "@/db/config/client";

/**
 * ビデオリポジトリ関数 - クライアントサイド実装
 * APIクライアントを使用してサーバーと通信
 */
export async function getAllVideos() {
  try {
    const response = await getApiClient().api.videos.$get();
    if (!response.ok) {
      throw new Error(`動画リストの取得に失敗しました: ${response.status}`);
    }

    const data = await response.json();
    return data.videos;
  } catch (error) {
    console.error("動画リストの取得中にエラーが発生しました:", error);
    throw error;
  }
}

export async function getVideoById(id: string) {
  try {
    const response = await getApiClient().api.videos[id].$get();
    if (!response.ok) {
      if (response.status === 404) {
        throw new Error(`ID: ${id} の動画が見つかりません`);
      }
      throw new Error(`動画の取得に失敗しました: ${response.status}`);
    }

    const data = await response.json();
    return data.video;
  } catch (error) {
    console.error(`ID: ${id} の動画取得中にエラーが発生しました:`, error);
    throw error;
  }
}

// その他のメソッド実装...
```

## マイグレーション管理

Cloudflare D1とDrizzle ORMを使用したマイグレーションの正しいワークフローは以下の通りです：

1. **スキーマ定義**：`src/db/schema`ディレクトリ内のテーブル定義を編集します

2. **マイグレーションファイル生成**：
   ```bash
   bun run generate
   ```
   このコマンドは`drizzle-kit generate`を実行し、`drizzle`ディレクトリにマイグレーションファイルを生成します

3. **ローカル環境へのマイグレーション適用**：

   **Cloudflare D1向け**:
   ```bash
   bun run migrate:local
   ```
   このコマンドは`wrangler d1 migrations apply kirinuki-playlist --local`を実行し、マイグレーションをローカル開発環境のD1データベースに適用します

   **LibSQL向け**:
   ```bash
   bun run migrate:server
   ```
   このコマンドは`bun scripts/migrate.ts`を実行し、マイグレーションをローカル開発環境のLibSQLサーバーに適用します

4. **リモート環境へのマイグレーション適用**（必要な場合）：
   ```bash
   bun run migrate:remote
   ```
   このコマンドは`wrangler d1 migrations apply kirinuki-playlist --remote`を実行し、マイグレーションをリモート（本番/ステージング）環境のD1データベースに適用します

## データシード

テスト・開発用にデータベースにサンプルデータを投入するためのシードスクリプトが用意されています：

```bash
# 通常のシード実行
bun run seed

# マイグレーション実行後にシードを実行
bun run seed:with-migrate
```

シードスクリプト（`scripts/seed.ts`）は以下のデータを挿入します：

1. テスト作者データ
2. テスト動画データ
3. テストプレイリストデータ
4. プレイリスト・動画の関連データ

### 開発環境のセットアップ

開発環境を一度に起動するには以下のコマンドを使用します：

```bash
# DockerでLibSQLサーバーを起動し、マイグレーションを適用した後にNext.jsを起動
bun run dev:with-db
```

このコマンドは以下の処理を順番に実行します：

1. `bun run db:server` - Dockerでlibsqlサーバーをバックグラウンドで起動
2. `bun run migrate:server` - libsqlサーバーにマイグレーションを適用
3. `bun run dev` - Next.js開発サーバーを起動

## スキーマ定義

Drizzle ORMを使用したスキーマ定義の例：

```typescript
// src/db/schema/videos.ts
import { sqliteTable, text, integer } from "drizzle-orm/sqlite-core";
import { createInsertSchema } from "drizzle-zod";
import { z } from "zod";
import { authors } from "./authors";

export const videos = sqliteTable(
  "videos",
  {
    id: text("id").primaryKey(),
    title: text("title").notNull(),
    url: text("url").notNull(),
    start: integer("start").default(0),
    end: integer("end").default(0),
    authorId: text("author_id").notNull().references(() => authors.id),
    createdAt: integer("created_at", { mode: "timestamp" }).notNull().default(sql`CURRENT_TIMESTAMP`),
    updatedAt: integer("updated_at", { mode: "timestamp" }).notNull().default(sql`CURRENT_TIMESTAMP`),
  }
);

// Zodバリデーションスキーマ
export const videoInsertSchema = createInsertSchema(videos, {
  id: z.undefined(),
  title: z.string().min(1, "タイトルは必須です"),
  url: z.string().url("URLの形式が正しくありません"),
  start: z.number().min(0, "開始時間は0以上である必要があります").optional(),
  end: z.number().min(0, "終了時間は0以上である必要があります").optional(),
  authorId: z.string().min(1, "著者IDは必須です"),
  createdAt: z.undefined(),
  updatedAt: z.undefined(),
});
```

## リポジトリパターン

データアクセスロジックはリポジトリパターンに従って実装します：

```typescript
// src/repositories/video-repository.ts
import { eq } from "drizzle-orm";
import type { D1Database } from "@cloudflare/workers-types";
import { createDbClient } from "@/db/utils/client";
import { videos } from "@/db/schema";
import type { Video, VideoInsert } from "@/db/schema/types";
import { NotFoundError, DatabaseError } from "@/db/utils/errors";

export class VideoRepository {
  async getVideoById(db: D1Database, id: string): Promise<Video> {
    const client = createDbClient(db);
    try {
      const video = await client
        .select()
        .from(videos)
        .where(eq(videos.id, id))
        .get();

      if (!video) {
        throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
      }

      return video;
    } catch (error) {
      if (error instanceof NotFoundError) {
        throw error;
      }
      throw new DatabaseError(
        `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
      );
    }
  }

  async createVideo(db: D1Database, data: VideoInsert): Promise<string> {
    // 実装...
  }
}

export const videoRepository = new VideoRepository();
```

## リレーションシップの処理

関連テーブル間のリレーションシップを適切に処理します：

```typescript
// 関連データの取得例
async getVideoWithAuthor(db: D1Database, id: string) {
  const client = createDbClient(db);
  try {
    const result = await client
      .select({
        video: videos,
        author: authors,
      })
      .from(videos)
      .innerJoin(authors, eq(videos.authorId, authors.id))
      .where(eq(videos.id, id))
      .get();

    if (!result) {
      throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
    }

    // 結果を適切な形式に変換して返却
    return {
      id: result.video.id,
      title: result.video.title,
      // ...他のビデオフィールド
      author: {
        id: result.author.id,
        name: result.author.name,
        // ...他の著者フィールド
      },
    };
  } catch (error) {
    // エラーハンドリング
  }
}
```

## 多対多リレーションシップの実装

多対多の関係（例：プレイリストとビデオ）は中間テーブルを使用して実装します：

```typescript
// 中間テーブル定義例
export const playlistVideos = sqliteTable(
  "playlist_videos",
  {
    id: text("id").primaryKey(),
    playlistId: text("playlist_id").notNull(),
    videoId: text("video_id").notNull(),
    order: integer("order").notNull(),  // 並び順を管理
    createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp" }).notNull(),
  }
);

export const playlists = sqliteTable(
  "playlists",
  {
    id: text("id").primaryKey(),
    title: text("title").notNull(),
    authorId: text("author_id").notNull(),
    createdAt: integer("created_at", { mode: "timestamp" }).notNull(),
    updatedAt: integer("updated_at", { mode: "timestamp" }).notNull(),
  }
);

// 関連付けの定義
export const playlistsRelations = relations(playlists, ({ one, many }) => ({
  author: one(authors, {
    fields: [playlists.authorId],
    references: [authors.id],
  }),
  playlistVideos: many(playlistVideos),
}));

export const videosRelations = relations(videos, ({ one, many }) => ({
  author: one(authors, {
    fields: [videos.authorId],
    references: [authors.id],
  }),
  playlistVideos: many(playlistVideos),
}));

export const playlistVideosRelations = relations(playlistVideos, ({ one }) => ({
  playlist: one(playlists, {
    fields: [playlistVideos.playlistId],
    references: [playlists.id],
  }),
  video: one(videos, {
    fields: [playlistVideos.videoId],
    references: [videos.id],
  }),
}));
```

### 多対多関係のデータ取得

多対多関係のデータを取得する際は、複数のJOIN操作とデータ整形が必要です：

```typescript
// プレイリストとそれに含まれるビデオの取得例
async getPlaylistWithVideos(db: D1Database, id: string) {
  const client = createDbClient(db);

  // プレイリストと作成者の情報を取得
  const playlistResult = await client
    .select({
      playlist: playlists,
      author: authors,
    })
    .from(playlists)
    .innerJoin(authors, eq(playlists.authorId, authors.id))
    .where(eq(playlists.id, id))
    .get();

  if (!playlistResult) {
    throw new NotFoundError(`プレイリストが見つかりません`);
  }

  // プレイリストに含まれるビデオを順番に取得
  const playlistVideosResult = await client
    .select({
      video: videos,
      playlistVideo: playlistVideos,
    })
    .from(playlistVideos)
    .innerJoin(videos, eq(playlistVideos.videoId, videos.id))
    .where(eq(playlistVideos.playlistId, id))
    .orderBy(playlistVideos.order)
    .all();

  // 結果を整形して返す
  return {
    id: playlistResult.playlist.id,
    title: playlistResult.playlist.title,
    author: {
      id: playlistResult.author.id,
      name: playlistResult.author.name,
      // 他の著者情報
    },
    videos: playlistVideosResult.map(pv => ({
      id: pv.video.id,
      title: pv.video.title,
      // 他のビデオ情報
      order: pv.playlistVideo.order,
    })),
    createdAt: playlistResult.playlist.createdAt,
    updatedAt: playlistResult.playlist.updatedAt,
  };
}
```

### 削除時の関連データ処理

多対多関係を持つデータを削除する場合は、関連するレコードも適切に処理する必要があります：

```typescript
// プレイリスト削除の例
async deletePlaylist(db: D1Database, id: string): Promise<void> {
  const client = createDbClient(db);

  try {
    // トランザクションを使う場合（SQLiteでは制限あり）
    // await client.transaction(async (tx) => {

    // 1. まず中間テーブルのレコードを削除
    await client
      .delete(playlistVideos)
      .where(eq(playlistVideos.playlistId, id))
      .run();

    // 2. 次にプレイリスト自体を削除
    const result = await client
      .delete(playlists)
      .where(eq(playlists.id, id))
      .run();

    // 削除対象が存在しなかった場合
    if (result.meta.changes === 0) {
      throw new NotFoundError(`ID: ${id} のプレイリストが見つかりません`);
    }

    // トランザクション終了
    // });
  } catch (error) {
    // エラー処理
  }
}
```

## トラブルシューティング

- **テーブルが存在しないエラー**：「no such table: XXX」というエラーが発生した場合、マイグレーションが適用されていません。`bun run migrate:local`を実行してください。

- **マイグレーション適用エラー**：「table already exists」というエラーが発生した場合、マイグレーションの一部だけが適用されている可能性があります。特定のマイグレーションファイルを直接実行することで解決できます：
  ```bash
  bunx wrangler d1 execute kirinuki-playlist --local --file=drizzle/XXXX_migration_name.sql
  ```

- **既存テーブルの確認**：現在のデータベースの状態を確認するには以下のコマンドを使用します：
  ```bash
  bunx wrangler d1 execute kirinuki-playlist --local --command="SELECT name FROM sqlite_master WHERE type='table'"
  ```

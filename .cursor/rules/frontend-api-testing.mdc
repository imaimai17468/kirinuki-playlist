---
description: Kirinuki-Playlistプロジェクトのサービス層テスト規約
globs: src/**/__tests__/**/*.ts
---
# サービス層・リポジトリ層テスト規約

Kirinuki-Playlistプロジェクトでは、サービス層（ビジネスロジック）とリポジトリ層（APIクライアント）のテストに関して以下の規約を定めています。

## 基本方針

1. **単体テスト重視**: 各機能を個別にテストし、依存関係はモックする
2. **テスト容易性**: テスト可能なコードを書くことを重視
3. **カバレッジ**: 重要なビジネスロジックは高いカバレッジを目指す
4. **実行速度**: テストは高速に実行できるようにする
5. **メンテナンス性**: テストは保守しやすく、理解しやすいものにする

## テスト環境設定

### テストフレームワーク

テストには Bun Test（Jest互換）を使用します。

```typescript
// package.json
{
  "scripts": {
    "test": "bun test",
    "test:watch": "bun test --watch"
  }
}
```

### ディレクトリ構造

テストファイルは対象となるコンポーネントと同じディレクトリに配置し、対象ファイル名に `.test.ts` サフィックスを付けます。または、`__tests__` ディレクトリに配置します。

```
src/
├── db/
│   ├── services/
│   │   ├── authors/
│   │   │   ├── authors.test.ts
│   │   │   └── authors.ts
│   │   ├── videos/
│   │   │   ├── videos.test.ts
│   │   │   └── videos.ts
│   │   └── ...
│   ├── ...
├── repositories/
│   ├── test/               # テスト共通機能
│   │   ├── setup.ts        # テスト共通セットアップ
│   │   └── utils.ts        # テスト用ユーティリティ
│   ├── authors/
│   │   ├── authors.test.ts
│   │   ├── index.ts
│   │   ├── hooks.ts
│   │   └── types.ts
│   ├── videos/
│   │   ├── videos.test.ts
│   │   ├── index.ts
│   │   ├── hooks.ts
│   │   └── types.ts
│   └── ...
```

## サービス層テスト

サービス層はビジネスロジックを担当し、データベースアクセスに依存します。テスト時はデータベースをモックします。

### モック方法

データベースのモックには、以下のアプローチを使用します：

```typescript
// src/db/services/videos/videos.test.ts
import { createVideoService } from "./videos";
import { mockDb } from "../../test/mock-db";

// テスト前の共通セットアップ
let videoService: ReturnType<typeof createVideoService>;
let mockDatabase: ReturnType<typeof mockDb>;

beforeEach(() => {
  // データベースモックの作成
  mockDatabase = mockDb();

  // モックデータベースを使用してサービスを初期化
  videoService = createVideoService(mockDatabase);
});

afterEach(() => {
  // 必要に応じてクリーンアップ処理
  jest.clearAllMocks();
});
```

### テストケース例

```typescript
describe("VideoService", () => {
  describe("getAllVideos", () => {
    it("すべての動画を取得できること", async () => {
      // モックデータの準備
      const mockVideos = [
        { id: "1", title: "テスト動画1", url: "https://example.com/1", authorId: "author1" },
        { id: "2", title: "テスト動画2", url: "https://example.com/2", authorId: "author2" }
      ];

      // データベースのモック応答を設定
      mockDatabase.prepare.mockReturnValueOnce({
        all: jest.fn().mockResolvedValueOnce(mockVideos)
      });

      // テスト対象関数の実行
      const result = await videoService.getAllVideos();

      // 結果の検証
      expect(result).toHaveLength(2);
      expect(result[0].title).toBe("テスト動画1");
      expect(result[1].title).toBe("テスト動画2");

      // データベースの呼び出しを検証
      expect(mockDatabase.prepare).toHaveBeenCalledWith(expect.stringContaining("SELECT * FROM videos"));
    });

    it("エラー発生時に適切に処理されること", async () => {
      // エラーをスローするようにモックを設定
      mockDatabase.prepare.mockReturnValueOnce({
        all: jest.fn().mockRejectedValueOnce(new Error("DB error"))
      });

      // テスト対象関数の実行とエラーのキャッチ
      await expect(videoService.getAllVideos()).rejects.toThrow("動画の取得中にエラーが発生しました");
    });
  });

  // その他メソッドのテスト...
});
```

## リポジトリ層テスト

リポジトリ層は、Honoクライアントを使用してサーバーとの通信を行います。リポジトリ層のテストでは、APIサーバーとの実際の通信を避け、テストの安定性と高速な実行のために統一的な方法でテストを行います。

### テスト環境の整備

テスト時は実際のネットワーク通信を行わず、レスポンスを予測可能にするため、テスト用の環境を整備します：

```typescript
// src/repositories/test/setup.ts
import { DbClient } from "@/db/config/hono";
import { createDbClient } from "@/db/config/sqlite";
import { authors } from "@/db/models/authors";
import { videos } from "@/db/models/videos";
import { playlists } from "@/db/models/playlists";
import { playlistVideos } from "@/db/models/playlistVideos";

// テスト環境のセットアップ
export async function setupTestEnv() {
  // インメモリデータベースの作成
  const dbClient = createDbClient(":memory:");

  // テーブルの作成
  await dbClient.run(`
    CREATE TABLE IF NOT EXISTS authors (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      iconUrl TEXT NOT NULL,
      bio TEXT,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL
    )
  `);

  await dbClient.run(`
    CREATE TABLE IF NOT EXISTS videos (
      id TEXT PRIMARY KEY,
      title TEXT NOT NULL,
      url TEXT NOT NULL,
      authorId TEXT NOT NULL,
      start INTEGER,
      end INTEGER,
      createdAt TEXT NOT NULL,
      updatedAt TEXT NOT NULL,
      FOREIGN KEY (authorId) REFERENCES authors (id)
    )
  `);

  // その他のテーブル作成...

  return { dbClient };
}

// テストデータの挿入（著者）
export async function insertTestAuthors(dbClient: DbClient) {
  // テスト用著者データの挿入
  await dbClient.insert(authors).values([
    {
      id: "author1",
      name: "テスト著者1",
      iconUrl: "https://example.com/icon1.jpg",
      bio: "テスト著者1の説明",
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      id: "author2",
      name: "テスト著者2",
      iconUrl: "https://example.com/icon2.jpg",
      bio: "テスト著者2の説明",
      createdAt: new Date(),
      updatedAt: new Date()
    }
  ]);
}

// テストデータのクリーンアップ
export async function cleanupTestData(dbClient: DbClient) {
  // データのクリーンアップ
  await dbClient.delete(playlistVideos);
  await dbClient.delete(videos);
  await dbClient.delete(playlists);
  await dbClient.delete(authors);
}
```

### リポジトリ層のテスト手法

リポジトリ層のテストでは、次の2つのアプローチを選択できます：

#### 1. テスト実装を簡略化するための方法

リポジトリの基本的な機能をテストするシンプルなアプローチです。テストの目的が「リポジトリ関数が期待通りの結果を返すか」の確認のみであれば、APIクライアントのモックは不要です。この場合、実装したリポジトリ関数を直接呼び出してテストします。

```typescript
// src/repositories/authors/authors.test.ts
import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import type { DbClient } from "@/db/config/hono";
import {
  cleanupTestData,
  insertTestAuthors,
  setupTestEnv,
} from "@/repositories/test/setup";
import {
  getAllAuthors,
  getAuthorById,
  createAuthor,
  updateAuthor,
  deleteAuthor,
} from "../authors";
import type { AuthorInsert, AuthorUpdate } from "./types";

// テスト用の状態を保持する変数
let dbClient: DbClient;

describe("著者リポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("getAllAuthors", () => {
    it("著者一覧を正しく取得できること", async () => {
      // リポジトリ関数を呼び出し
      const result = await getAllAuthors();

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const authors = result.value;

        // 正しい数の著者が取得できていることを確認
        expect(authors.length).toBe(2);

        // 特定のプロパティが正しく含まれていることを確認
        expect(authors[0].id).toBe("author1");
        expect(authors[0].name).toBe("テスト著者1");
        expect(authors[1].id).toBe("author2");
        expect(authors[1].name).toBe("テスト著者2");
      }
    });
  });

  // 他のメソッドのテスト...
});
```

このアプローチのメリット：
- テストコードがシンプルで読みやすい
- 特別なモック設定が不要で、メンテナンスコストが低い
- セットアップが容易

デメリット：
- API通信の詳細な挙動をテストできない
- 特定のエラーケースをシミュレートしにくい

#### 2. API通信の詳細な挙動をテストする方法

より詳細なテストを行う場合や、特定のエラーケースをシミュレートする必要がある場合は、APIクライアントをモックします：

```typescript
// src/repositories/test/mock-api-client.ts
import { setApiClient } from "@/db/config/client";
import type { ApiClient } from "@/db/config/client";

// モックAPIクライアントのセットアップ
export function setupMockApiClient() {
  const mockClient = {
    api: {
      authors: {
        $get: jest.fn(),
        $post: jest.fn(),
        [":id"]: {
          $get: jest.fn(),
          $patch: jest.fn(),
          $delete: jest.fn()
        }
      },
      // 他のエンドポイント定義...
    }
  };

  setApiClient(mockClient as unknown as ApiClient);
  return mockClient;
}
```

テストファイルでの使用例：

```typescript
// src/repositories/authors/authors.test.ts
import { afterEach, beforeEach, describe, expect, it, jest } from "bun:test";
import { setApiClient } from "@/db/config/client";
import type { ApiClient } from "@/db/config/client";
import { setupMockApiClient } from "@/repositories/test/mock-api-client";
import {
  getAllAuthors,
  getAuthorById,
  createAuthor,
  updateAuthor,
  deleteAuthor,
} from "../authors";
import type { AuthorInsert, AuthorUpdate } from "./types";

describe("著者リポジトリのテスト", () => {
  let mockClient: ReturnType<typeof setupMockApiClient>;

  beforeEach(() => {
    // APIクライアントのモックをセットアップ
    mockClient = setupMockApiClient();
  });

  afterEach(() => {
    // モックをリセット
    jest.resetAllMocks();
  });

  describe("getAllAuthors", () => {
    it("著者一覧を正しく取得できること", async () => {
      // モックの応答を設定
      mockClient.api.authors.$get.mockResolvedValueOnce({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          authors: [
            { id: "author1", name: "テスト著者1", iconUrl: "https://example.com/icon1.jpg" },
            { id: "author2", name: "テスト著者2", iconUrl: "https://example.com/icon2.jpg" }
          ]
        })
      });

      // リポジトリ関数を呼び出し
      const result = await getAllAuthors();

      // 結果を検証
      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        expect(result.value.length).toBe(2);
        expect(result.value[0].name).toBe("テスト著者1");
      }

      // APIクライアントが正しく呼ばれたことを確認
      expect(mockClient.api.authors.$get).toHaveBeenCalledTimes(1);
    });

    it("APIエラー時にエラー結果を返すこと", async () => {
      // エラーレスポンスをモック
      mockClient.api.authors.$get.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: jest.fn().mockResolvedValueOnce({
          success: false,
          message: "サーバーエラー"
        })
      });

      // リポジトリ関数を呼び出し
      const result = await getAllAuthors();

      // エラー結果を検証
      expect(result.isErr()).toBe(true);
      if (result.isErr()) {
        expect(result.error.type).toBe("serverError");
      }
    });
  });

  // 他のメソッドのテスト...
});
```

このアプローチのメリット：
- API通信の詳細な挙動をテストできる
- 様々なエラーケースを簡単にシミュレートできる
- ネットワークエラー、スキーマ検証エラーなどの特殊なケースもテスト可能

デメリット：
- テストコードが複雑になる
- モックの設定に手間がかかる
- メンテナンスコストが高い

### テスト方法の選択指針

リポジトリテストのアプローチを選択する際の指針：

1. **基本的な機能テスト**:
   - 一般的なCRUD操作のテスト
   - 単純なデータの取得・保存・削除のテスト
   - ➡️ **シンプルなアプローチ（モックなし）を推奨**

2. **エラーケースのテスト**:
   - 特定のAPIエラーのシミュレーション
   - ネットワークエラーやスキーマ検証エラーのテスト
   - 特殊なエッジケースの検証
   - ➡️ **詳細なアプローチ（APIクライアントのモック）を推奨**

3. **アプローチの混合**:
   - 同じリポジトリに対して両方のアプローチを使い分けることも可能
   - 基本機能は簡略アプローチで、特殊ケースは詳細アプローチでテストする

### テストデータの準備

テストデータは、テスト環境に応じて準備します：

```typescript
// モックAPIを使う場合のテストデータ例
const testAuthor = {
  id: "author1",
  name: "テスト著者",
  iconUrl: "https://example.com/icon.jpg",
  bio: "テスト著者の説明",
  createdAt: new Date().toISOString(),
  updatedAt: new Date().toISOString()
};

const testAuthorInsertData: AuthorInsert = {
  name: "新しい著者",
  iconUrl: "https://example.com/new-icon.jpg",
  bio: "新しい著者の説明"
};

const testAuthorUpdateData: AuthorUpdate = {
  name: "更新された著者名",
  bio: "更新された説明"
};
```

## 関連エンティティのテスト

複数のエンティティが関連する処理のテスト例：

```typescript
// src/repositories/playlists/playlists.test.ts
describe("PlaylistRepository", () => {
  // モックAPIを使う場合のテスト例
  describe("getPlaylistWithVideosById", () => {
    beforeEach(() => {
      mockClient = setupMockApiClient();
    });

    it("プレイリストとそれに含まれる動画を取得できること", async () => {
      // テスト用のプレイリスト・動画データ
      const testPlaylist = {
        id: "playlist1",
        title: "テストプレイリスト",
        authorId: "author1",
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        videos: [
          {
            id: "video1",
            title: "テスト動画1",
            url: "https://example.com/video1.mp4",
            authorId: "author1",
            author: {
              id: "author1",
              name: "テスト著者",
              iconUrl: "https://example.com/icon.jpg"
            }
          },
          {
            id: "video2",
            title: "テスト動画2",
            url: "https://example.com/video2.mp4",
            authorId: "author1",
            author: {
              id: "author1",
              name: "テスト著者",
              iconUrl: "https://example.com/icon.jpg"
            }
          }
        ]
      };

      // モックの応答を設定
      mockClient.api.playlists[":id"].withVideos.$get.mockImplementationOnce(({ param }) => ({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          playlist: testPlaylist
        })
      }));

      // リポジトリ関数を呼び出し
      const result = await getPlaylistWithVideosById("playlist1");

      // 結果を検証
      expect(result.isOk()).toBe(true);
      if (result.isOk()) {
        const playlist = result.value;
        expect(playlist.id).toBe("playlist1");
        expect(playlist.videos.length).toBe(2);
        expect(playlist.videos[0].author.name).toBe("テスト著者");
      }
    });

    // エラーケースのテスト...
  });
});
```

## React Queryフックのテスト

リポジトリ層のReact Queryフックもテスト対象です：

```typescript
// src/repositories/authors/hooks.test.ts
import { renderHook, waitFor } from "@testing-library/react";
import { QueryClient, QueryClientProvider } from "@tanstack/react-query";
import { useAuthors, useAuthor, useCreateAuthor } from "./hooks";
import * as authorsRepository from "../authors";

// リポジトリをモック
jest.mock("../authors");

describe("著者フックテスト", () => {
  // テスト用のクエリクライアント
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false
      }
    }
  });

  // モックリポジトリ
  const mockRepository = authorsRepository as jest.Mocked<typeof authorsRepository>;

  // テスト用のラッパー
  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  beforeEach(() => {
    jest.resetAllMocks();
    queryClient.clear();
  });

  describe("useAuthors", () => {
    it("著者一覧を正しく取得できること", async () => {
      // リポジトリ関数のモック
      mockRepository.getAllAuthors.mockResolvedValueOnce({
        isOk: () => true,
        isErr: () => false,
        value: [
          { id: "1", name: "著者1" },
          { id: "2", name: "著者2" }
        ]
      } as any);

      // フックを呼び出し
      const { result } = renderHook(() => useAuthors(), { wrapper });

      // 初期状態はロード中
      expect(result.current.isLoading).toBe(true);

      // データのロード完了を待つ
      await waitFor(() => expect(result.current.isLoading).toBe(false));

      // 結果を検証
      expect(result.current.data).toHaveLength(2);
      expect(result.current.data[0].name).toBe("著者1");
      expect(result.current.data[1].name).toBe("著者2");
    });

    it("エラー時に例外をスローすること", async () => {
      // エラーをスローするようにモック
      mockRepository.getAllAuthors.mockResolvedValueOnce({
        isOk: () => false,
        isErr: () => true,
        error: { type: "network", message: "ネットワークエラー" }
      } as any);

      // コンソールエラーをサプレス（テスト中の意図的なエラー）
      const originalConsoleError = console.error;
      console.error = jest.fn();

      // フックを呼び出し
      const { result } = renderHook(() => useAuthors(), { wrapper });

      // エラー状態になるのを待つ
      await waitFor(() => expect(result.current.isError).toBe(true));

      // エラーメッセージを検証
      expect(result.current.error).toBeDefined();
      expect(result.current.error.message).toContain("ネットワークエラー");

      // コンソールを元に戻す
      console.error = originalConsoleError;
    });
  });

  // その他のフックのテスト...
});
```

## ベストプラクティス

### テスト実装のガイドライン

1. **必要なテスト範囲の見極め**:
   - すべてのメソッドに対して同じレベルのテストは必要ない
   - ビジネス的に重要な機能や複雑なロジックに重点を置く

2. **テストデータの管理**:
   - テストデータは明示的に定義し、理解しやすくする
   - テストデータは再利用可能な形で準備する
   - データベーステストでは、各テストの独立性を保つためにクリーンアップを確実に行う

3. **モックの適切な使用**:
   - 外部依存（APIクライアント、データベース）はモックする
   - モックが複雑になりすぎる場合は、テスト設計を見直す
   - モックの応答は実際のAPIレスポンスを参考に設計する

4. **テストの読みやすさ**:
   - テスト名は機能と期待する結果を明確に表現する
   - AAA（Arrange-Act-Assert）パターンでテストを構造化する
   - 関連するテストをグループ化する

5. **エラーケースのテスト**:
   - 正常系だけでなく、エラーケースも必ずテストする
   - 境界値や特殊なケースも考慮する
   - エラーメッセージの内容も検証する

### 共通の落とし穴と対策

1. **非同期処理の取り扱い**:
   - 非同期テストでは `async/await` を適切に使用する
   - プロミスの解決を確実に待つ
   - 非同期エラーのテストでは、エラーがスローされることを確認する

2. **テスト環境の隔離**:
   - 各テストは独立して実行できるようにする
   - グローバル状態に依存しない
   - テスト前後で適切なセットアップとクリーンアップを行う

3. **テストのパフォーマンス**:
   - 重いリソースの使用を最小限に抑える
   - 不要なネットワークリクエストを避ける
   - テストは高速に実行できるようにする

4. **テストのメンテナンス性**:
   - リファクタリングに強いテストを書く（実装の詳細ではなく動作をテスト）
   - 重複コードを減らすためにヘルパー関数を使用する
   - テストコードもコードレビューの対象とする

## テスト実行とCI/CD統合

テストの実行とCI/CDパイプラインへの統合方法：

```yaml
# .github/workflows/test.yml
name: Test

on:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

jobs:
  test:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: oven-sh/setup-bun@v1
        with:
          bun-version: latest

      - name: Install dependencies
        run: bun install

      - name: Run tests
        run: bun test

      - name: Upload coverage
        uses: codecov/codecov-action@v3
        with:
          file: ./coverage/lcov.info
```

### テストカバレッジの測定

テストカバレッジを測定するための設定：

```typescript
// package.json
{
  "scripts": {
    "test": "bun test",
    "test:coverage": "bun test --coverage"
  }
}
```

## まとめ

サービス層とリポジトリ層のテストは、アプリケーションの信頼性と保守性を高める重要な要素です。適切なテスト戦略を選択し、効率的なテストを実装することで、品質の高いコードを維持できます。

特に、リポジトリ層のテストでは、テスト目的に応じて適切なアプローチ（シンプルなテストまたは詳細なモックを使用したテスト）を選択し、必要なカバレッジを効率的に達成することが重要です。

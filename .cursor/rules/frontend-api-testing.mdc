---
description: Kirinuki-Playlistプロジェクトのサービス層テスト規約
globs: src/**/__tests__/**/*.ts
---
# サービス層・リポジトリ層テスト規約

Kirinuki-Playlistプロジェクトでは、サービス層（ビジネスロジック）とリポジトリ層（APIクライアント）のテストに関して以下の規約を定めています。

## 基本方針

1. **単体テスト重視**: 各機能を個別にテストし、依存関係はモックする
2. **テスト容易性**: テスト可能なコードを書くことを重視
3. **カバレッジ**: 重要なビジネスロジックは高いカバレッジを目指す
4. **実行速度**: テストは高速に実行できるようにする
5. **メンテナンス性**: テストは保守しやすく、理解しやすいものにする

## テスト環境設定

### テストフレームワーク

テストには Bun Test（Jest互換）を使用します。

```typescript
// package.json
{
  "scripts": {
    "test": "bun test",
    "test:watch": "bun test --watch"
  }
}
```

### ディレクトリ構造

テストファイルは各機能ディレクトリ内に配置し、テスト対象のファイル名に関連する名前を付けます。

```
src/
├── db/
│   ├── services/
│   │   ├── videos/
│   │   │   ├── __tests__/
│   │   │   │   └── videos.test.ts
│   │   │   └── videos.ts
│   │   ├── playlists/
│   │   │   └── ...
│   │   └── authors/
│   │       └── ...
│   ├── repositories/
│   │   ├── test/
│   │   │   └── setup.ts          # テスト共通セットアップ
│   │   ├── videos/
│   │   │   ├── __tests__/
│   │   │   │   └── videos.test.ts
│   │   ├── index.ts
│   │   ├── hooks.ts
│   │   └── types.ts
│   ├── playlists/
│   │   ├── playlists.test.ts  # ルートに直接テストファイルを配置することも可
│   │   ├── index.ts
│   │   ├── hooks.ts
│   │   └── types.ts
│   └── ...
```

## サービス層テスト

サービス層はビジネスロジックを担当し、データベースアクセスに依存します。テスト時はデータベースをモックします。

### モック方法

データベースのモックには、以下のアプローチを使用します：

```typescript
// src/db/services/videos/__tests__/videos.test.ts
import { createVideoService } from "../videos";
import { mockDb } from "../../../../test/mock-db";

// テスト前の共通セットアップ
let videoService: ReturnType<typeof createVideoService>;
let mockDatabase: ReturnType<typeof mockDb>;

beforeEach(() => {
  // データベースモックの作成
  mockDatabase = mockDb();

  // モックデータベースを使用してサービスを初期化
  videoService = createVideoService(mockDatabase);
});

afterEach(() => {
  // 必要に応じてクリーンアップ処理
  jest.clearAllMocks();
});
```

### テストケース例

```typescript
describe("VideoService", () => {
  describe("getAllVideos", () => {
    it("すべての動画を取得できること", async () => {
      // モックデータの準備
      const mockVideos = [
        { id: "1", title: "テスト動画1", url: "https://example.com/1", authorId: "author1" },
        { id: "2", title: "テスト動画2", url: "https://example.com/2", authorId: "author2" }
      ];

      // データベースのモック応答を設定
      mockDatabase.select = jest.fn().mockReturnValue({
        from: jest.fn().mockReturnValue({
          innerJoin: jest.fn().mockReturnValue({
            all: jest.fn().mockResolvedValue(mockVideos)
          })
        })
      });

      // テスト対象関数の実行
      const result = await videoService.getAllVideos();

      // 結果の検証
      expect(result).toHaveLength(2);
      expect(result[0].title).toBe("テスト動画1");
      expect(result[1].title).toBe("テスト動画2");

      // データベースの呼び出しを検証
      expect(mockDatabase.select).toHaveBeenCalled();
    });

    it("エラー発生時に適切に処理されること", async () => {
      // エラーをスローするようにモックを設定
      mockDatabase.select = jest.fn().mockReturnValue({
        from: jest.fn().mockReturnValue({
          innerJoin: jest.fn().mockReturnValue({
            all: jest.fn().mockRejectedValue(new Error("DB error"))
          })
        })
      });

      // テスト対象関数の実行とエラーのキャッチ
      await expect(videoService.getAllVideos()).rejects.toThrow("動画の取得中にエラーが発生しました");
    });
  });

  // 他のメソッドのテスト...
});
```

## リポジトリ層テスト

### テスト準備

リポジトリ層のテストでは、`setupTestEnv` 関数を使用してテスト環境をセットアップします：

```typescript
// src/repositories/test/setup.ts
import type { DbClient } from "@/db/config/hono";

export async function setupTestEnv() {
  // テスト環境のセットアップ
  const dbClient = await createTestDbClient();

  return {
    dbClient,
  };
}

// テストデータの挿入関数
export async function insertTestAuthors(dbClient: DbClient) {
  // テスト用著者データの挿入
  await dbClient.insert(authors).values([
    {
      id: "author1",
      name: "テスト著者1",
      iconUrl: "https://example.com/icon1.jpg",
      createdAt: new Date(),
      updatedAt: new Date()
    },
    {
      id: "author2",
      name: "テスト著者2",
      iconUrl: "https://example.com/icon2.jpg",
      createdAt: new Date(),
      updatedAt: new Date()
    }
  ]).run();
}

// 他のテストデータ挿入関数
export async function insertTestVideos(dbClient: DbClient) {
  // ...
}

export async function insertTestPlaylists(dbClient: DbClient) {
  // ...
}

// テストデータのクリーンアップ
export async function cleanupTestData(dbClient: DbClient) {
  await dbClient.delete(playlistVideos).run();
  await dbClient.delete(playlists).run();
  await dbClient.delete(videos).run();
  await dbClient.delete(authors).run();
}
```

### テストケース例（Bunテスト）

Bunテストを使用した例:

```typescript
// src/repositories/authors/authors.test.ts
import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import type { DbClient } from "@/db/config/hono";
import { cleanupTestData, insertTestAuthors, setupTestEnv } from "@/repositories/test/setup";
import { createAuthor, deleteAuthor, getAllAuthors, getAuthorById, updateAuthor } from "../authors";
import type { AuthorInsert, AuthorUpdate } from "./types";

// テスト用の状態を保持する変数
let dbClient: DbClient;

describe("著者リポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("getAllAuthors", () => {
    it("著者一覧を正しく取得できること", async () => {
      // リポジトリ関数を呼び出し
      const result = await getAllAuthors();

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const authors = result.value;

        // 正しい数の著者が取得できていることを確認
        expect(authors.length).toBe(2);

        // 特定のプロパティが正しく含まれていることを確認
        expect(authors[0].id).toBe("author1");
        expect(authors[0].name).toBe("テスト著者1");
        expect(authors[1].id).toBe("author2");
        expect(authors[1].name).toBe("テスト著者2");
      }
    });
  });

  describe("getAuthorById", () => {
    it("存在する著者IDで正しく取得できること", async () => {
      // リポジトリ関数を呼び出し
      const result = await getAuthorById("author1");

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const author = result.value;

        // 取得した著者の情報が正しいことを確認
        expect(author.id).toBe("author1");
        expect(author.name).toBe("テスト著者1");
        expect(author.iconUrl).toBe("https://example.com/icon1.jpg");
      }
    });

    it("存在しない著者IDではエラーになること", async () => {
      // 存在しないIDでリポジトリ関数を呼び出し
      const result = await getAuthorById("non-existent-id");

      // 結果がエラーであることを確認
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const error = result.error;

        // 適切なエラータイプであることを確認
        expect(error.type).toBe("serverError");
      }
    });
  });

  describe("createAuthor", () => {
    it("著者を正しく作成できること", async () => {
      // テスト用の著者データ
      const authorData: AuthorInsert = {
        name: "新しい著者",
        iconUrl: "https://example.com/new-icon.jpg",
        bio: "新しい著者の説明",
      };

      // リポジトリ関数を呼び出し
      const result = await createAuthor(authorData);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);
    });

    it("バリデーションエラーが発生した場合はエラーになること", async () => {
      // 不正なデータでリポジトリ関数を呼び出し
      const result = await createAuthor({
        name: "",
        iconUrl: "不正なURL",
      } as AuthorInsert);

      // 結果がエラーであることを確認
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const error = result.error;

        // 適切なエラータイプであることを確認
        expect(error.type).toBe("badRequest");
      }
    });
  });

  // 他のメソッドのテスト...
});
```

### 関連エンティティテスト例

プレイリストと動画の関連データをテストする例:

```typescript
// src/repositories/playlists/playlists.test.ts
describe("プレイリストリポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
    await insertTestVideos(dbClient);
    await insertTestPlaylists(dbClient);
    await insertTestPlaylistVideos(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("getPlaylistById", () => {
    it("プレイリストに関連する動画と動画の作者情報が正しく取得できること", async () => {
      // リポジトリ関数を呼び出し
      const result = await getPlaylistById("playlist1");

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const playlist = result.value;

        // プレイリスト情報を確認
        expect(playlist.id).toBe("playlist1");
        expect(playlist.title).toBe("テストプレイリスト1");

        // 動画情報があることを確認
        expect(playlist.videos).toBeDefined();
        expect(Array.isArray(playlist.videos)).toBe(true);
        expect(playlist.videos?.length).toBeGreaterThan(0);

        if (playlist.videos) {
          // 関連する動画の情報を確認
          const video1 = playlist.videos.find((v) => v.id === "video1");
          expect(video1).toBeDefined();

          if (video1) {
            expect(video1.title).toBe("テストビデオ1");
            expect(video1.url).toBe("https://example.com/video1");

            // 動画の作者情報を確認
            expect(video1.author).toBeDefined();
            if (video1.author) {
              expect(video1.author.id).toBe("author1");
              expect(video1.author.name).toBe("テスト著者1");
              expect(video1.author.iconUrl).toBe("https://example.com/icon1.jpg");
            }
          }
        }
      }
    });
  });

  describe("addVideoToPlaylist", () => {
    it("プレイリストに動画を正しく追加できること", async () => {
      // テスト用の動画追加データ
      const videoData: PlaylistVideoInsert = {
        videoId: "video2", // playlist1にはvideo1が既に存在するので別の動画を追加
        order: 2,
      };

      // リポジトリ関数を呼び出し
      const result = await addVideoToPlaylist("playlist1", videoData);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      // 追加後のプレイリストを取得して動画が追加されていることを確認
      const getResult = await getPlaylistById("playlist1");
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.videos).toBeDefined();

        if (playlist.videos) {
          // 追加した動画が存在することを確認
          const addedVideo = playlist.videos.find((v) => v.id === videoData.videoId);
          expect(addedVideo).toBeDefined();

          if (addedVideo) {
            expect(addedVideo.order).toBe(videoData.order);
          }
        }
      }
    });
  });

  // 他のテストケース...
});
```

## React Queryフックのテスト

リポジトリを使用するReact Queryフックのテストでは、`@testing-library/react-hooks`と`jest.mock`を使用します：

```typescript
// src/repositories/authors/hooks.test.ts
import { renderHook, waitFor } from '@testing-library/react';
import { QueryClient, QueryClientProvider } from '@tanstack/react-query';
import { useAuthors, useAuthor, useCreateAuthor } from './hooks';
import * as authorsRepository from './index';

// リポジトリ関数をモック
jest.mock('./index');

describe('Authors Hooks', () => {
  // React QueryのQueryClientをセットアップ
  const queryClient = new QueryClient({
    defaultOptions: {
      queries: {
        retry: false,
        cacheTime: 0,
      },
    },
  });

  // モック関数を適切な型にキャスト
  const mockedAuthorsRepository = authorsRepository as jest.Mocked<typeof authorsRepository>;

  const wrapper = ({ children }) => (
    <QueryClientProvider client={queryClient}>
      {children}
    </QueryClientProvider>
  );

  beforeEach(() => {
    // テスト前にモックをリセット
    jest.resetAllMocks();
    queryClient.clear();
  });

  describe('useAuthors', () => {
    it('著者リストを正しく取得できること', async () => {
      // テスト用データ
      const mockAuthors = [
        { id: 'author1', name: 'テスト著者1', iconUrl: 'https://example.com/1', createdAt: new Date(), updatedAt: new Date() },
        { id: 'author2', name: 'テスト著者2', iconUrl: 'https://example.com/2', createdAt: new Date(), updatedAt: new Date() },
      ];

      // モックの戻り値を設定
      mockedAuthorsRepository.getAllAuthors.mockResolvedValueOnce({
        isOk: () => true,
        isErr: () => false,
        value: mockAuthors
      } as any);

      // フックをレンダリング
      const { result } = renderHook(() => useAuthors(), { wrapper });

      // 初期状態ではロード中
      expect(result.current.isLoading).toBe(true);

      // データが取得されるまで待機
      await waitFor(() => expect(result.current.isLoading).toBe(false));

      // データが正しく取得されていることを確認
      expect(result.current.data).toEqual(mockAuthors);
      expect(result.current.error).toBeNull();
    });

    it('エラー発生時にエラー状態になること', async () => {
      // エラーモックの設定
      const mockError = new Error('テストエラー');
      mockedAuthorsRepository.getAllAuthors.mockResolvedValueOnce({
        isOk: () => false,
        isErr: () => true,
        error: { message: 'テストエラー', type: 'network' }
      } as any);

      // フックをレンダリング
      const { result } = renderHook(() => useAuthors(), { wrapper });

      // データ取得完了まで待機
      await waitFor(() => expect(result.current.isLoading).toBe(false));

      // エラー状態になっていることを確認
      expect(result.current.error).not.toBeNull();
      expect(result.current.error?.message).toBe('テストエラー');
    });
  });

  // 他のフックのテスト...
});
```

## プレイリスト・動画管理機能のテスト例

プレイリスト管理機能には、プレイリストの作成・更新・削除に加え、動画の追加・削除・並び替えなどの機能があります。これらの機能をテストする例を以下に示します：

```typescript
// src/repositories/playlists/playlists.test.ts
import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import type { DbClient } from "@/db/config/hono";
import { cleanupTestData, insertTestAuthors, insertTestVideos, insertTestPlaylists, setupTestEnv } from "@/repositories/test/setup";
import {
  createPlaylist,
  updatePlaylist,
  deletePlaylist,
  getPlaylistById,
  getAllPlaylists,
  addVideoToPlaylist,
  removeVideoFromPlaylist,
  updatePlaylistVideo,
  updatePlaylistVideoOrder
} from "./index";
import type { PlaylistInsert, PlaylistUpdate, PlaylistVideoInsert, PlaylistVideoUpdate } from "./types";

// テスト用の状態を保持する変数
let dbClient: DbClient;

describe("プレイリストリポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
    await insertTestVideos(dbClient);
    await insertTestPlaylists(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("createPlaylist", () => {
    it("新しいプレイリストを作成できること", async () => {
      // テスト用のプレイリストデータ
      const playlistData: PlaylistInsert = {
        title: "新しいプレイリスト",
        description: "テスト用の新しいプレイリストです",
        authorId: "author1"
      };

      // リポジトリ関数を呼び出し
      const result = await createPlaylist(playlistData);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const playlistId = result.value;

        // 作成されたプレイリストを取得して検証
        const getResult = await getPlaylistById(playlistId);

        expect(getResult.isOk()).toBe(true);

        if (getResult.isOk()) {
          const playlist = getResult.value;
          expect(playlist.title).toBe(playlistData.title);
          expect(playlist.description).toBe(playlistData.description);
          expect(playlist.authorId).toBe(playlistData.authorId);
        }
      }
    });

    it("不正なデータでエラーになること", async () => {
      // 不正なデータ（タイトルなし）
      const invalidData: PlaylistInsert = {
        title: "", // 空のタイトル
        authorId: "author1"
      };

      // リポジトリ関数を呼び出し
      const result = await createPlaylist(invalidData);

      // 結果がエラーであることを確認
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("badRequest");
      }
    });
  });

  describe("updatePlaylist", () => {
    it("プレイリストを更新できること", async () => {
      const playlistId = "playlist1";

      // 更新データ
      const updateData: PlaylistUpdate = {
        title: "更新されたプレイリスト",
        description: "更新された説明文"
      };

      // リポジトリ関数を呼び出し
      const result = await updatePlaylist(playlistId, updateData);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      // 更新されたプレイリストを取得して検証
      const getResult = await getPlaylistById(playlistId);

      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.title).toBe(updateData.title);
        expect(playlist.description).toBe(updateData.description);
      }
    });

    it("一部のフィールドのみ更新した場合、他のフィールドは変わらないこと", async () => {
      const playlistId = "playlist1";

      // 更新前のプレイリストを取得
      const beforeResult = await getPlaylistById(playlistId);
      expect(beforeResult.isOk()).toBe(true);

      const originalPlaylist = beforeResult.isOk() ? beforeResult.value : null;

      // タイトルのみ更新
      const updateData: PlaylistUpdate = {
        title: "タイトルのみ更新"
      };

      // リポジトリ関数を呼び出し
      const result = await updatePlaylist(playlistId, updateData);
      expect(result.isOk()).toBe(true);

      // 更新後のプレイリストを取得
      const afterResult = await getPlaylistById(playlistId);
      expect(afterResult.isOk()).toBe(true);

      if (afterResult.isOk() && originalPlaylist) {
        const updatedPlaylist = afterResult.value;

        // タイトルは更新されている
        expect(updatedPlaylist.title).toBe(updateData.title);

        // 他のフィールドは変わっていない
        expect(updatedPlaylist.description).toBe(originalPlaylist.description);
        expect(updatedPlaylist.authorId).toBe(originalPlaylist.authorId);
      }
    });
  });

  describe("deletePlaylist", () => {
    it("プレイリストを削除できること", async () => {
      const playlistId = "playlist1";

      // 削除前に存在確認
      const beforeResult = await getPlaylistById(playlistId);
      expect(beforeResult.isOk()).toBe(true);

      // リポジトリ関数を呼び出し
      const result = await deletePlaylist(playlistId);
      expect(result.isOk()).toBe(true);

      // 削除後に存在確認
      const afterResult = await getPlaylistById(playlistId);
      expect(afterResult.isErr()).toBe(true);

      if (afterResult.isErr()) {
        expect(afterResult.error.type).toBe("notFound");
      }
    });
  });

  describe("動画管理機能", () => {
    it("プレイリストに動画を追加できること", async () => {
      const playlistId = "playlist1";
      const videoId = "video2";

      // 動画追加データ
      const videoData: PlaylistVideoInsert = {
        videoId,
        order: 1
      };

      // リポジトリ関数を呼び出し
      const result = await addVideoToPlaylist(playlistId, videoData);
      expect(result.isOk()).toBe(true);

      // プレイリストを取得して動画が追加されているか確認
      const getResult = await getPlaylistById(playlistId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.videos).toBeDefined();

        if (playlist.videos) {
          const foundVideo = playlist.videos.find(v => v.id === videoId);
          expect(foundVideo).toBeDefined();
          expect(foundVideo?.order).toBe(videoData.order);
        }
      }
    });

    it("プレイリストから動画を削除できること", async () => {
      const playlistId = "playlist1";
      const videoId = "video1";

      // 削除前に動画が存在することを確認
      const beforeResult = await getPlaylistById(playlistId);
      expect(beforeResult.isOk()).toBe(true);

      if (beforeResult.isOk()) {
        const playlist = beforeResult.value;
        expect(playlist.videos).toBeDefined();
        expect(playlist.videos?.some(v => v.id === videoId)).toBe(true);
      }

      // リポジトリ関数を呼び出し
      const result = await removeVideoFromPlaylist(playlistId, videoId);
      expect(result.isOk()).toBe(true);

      // 削除後に動画が存在しないことを確認
      const afterResult = await getPlaylistById(playlistId);
      expect(afterResult.isOk()).toBe(true);

      if (afterResult.isOk()) {
        const playlist = afterResult.value;
        expect(playlist.videos?.some(v => v.id === videoId)).toBe(false);
      }
    });

    it("プレイリスト内の動画の順序を更新できること", async () => {
      const playlistId = "playlist1";

      // まず複数の動画を追加
      await addVideoToPlaylist(playlistId, { videoId: "video1", order: 1 });
      await addVideoToPlaylist(playlistId, { videoId: "video2", order: 2 });
      await addVideoToPlaylist(playlistId, { videoId: "video3", order: 3 });

      // 順序を更新
      const newOrders = [
        { videoId: "video1", order: 3 }, // 1→3
        { videoId: "video2", order: 1 }, // 2→1
        { videoId: "video3", order: 2 }  // 3→2
      ];

      const result = await updatePlaylistVideoOrder(playlistId, newOrders);
      expect(result.isOk()).toBe(true);

      // 更新後の順序を確認
      const getResult = await getPlaylistById(playlistId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.videos).toBeDefined();

        if (playlist.videos) {
          const video1 = playlist.videos.find(v => v.id === "video1");
          const video2 = playlist.videos.find(v => v.id === "video2");
          const video3 = playlist.videos.find(v => v.id === "video3");

          expect(video1?.order).toBe(3);
          expect(video2?.order).toBe(1);
          expect(video3?.order).toBe(2);
        }
      }
    });

    it("プレイリスト内の単一動画の順序を更新できること", async () => {
      const playlistId = "playlist1";
      const videoId = "video1";

      // 新しい順序値
      const updateData: PlaylistVideoUpdate = {
        order: 999,
      };

      // リポジトリ関数を呼び出し
      const result = await updatePlaylistVideo(playlistId, videoId, updateData);
      expect(result.isOk()).toBe(true);

      // 更新後のプレイリストを取得して確認
      const getResult = await getPlaylistById(playlistId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.videos).toBeDefined();

        if (playlist.videos) {
          const updatedVideo = playlist.videos.find(v => v.id === videoId);
          expect(updatedVideo).toBeDefined();
          expect(updatedVideo?.order).toBe(updateData.order);
        }
      }
    });

    it("プレイリスト内の最小順序値（0）に更新できること", async () => {
      const playlistId = "playlist1";
      const videoId = "video1";

      // 最小の順序値
      const updateData: PlaylistVideoUpdate = {
        order: 0,
      };

      // リポジトリ関数を呼び出し
      const result = await updatePlaylistVideo(playlistId, videoId, updateData);
      expect(result.isOk()).toBe(true);

      // 更新後のプレイリストを取得して確認
      const getResult = await getPlaylistById(playlistId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        const updatedVideo = playlist.videos?.find(v => v.id === videoId);
        expect(updatedVideo).toBeDefined();
        expect(updatedVideo?.order).toBe(0);
      }
    });

    it("複数の動画の順序入れ替えが正しく機能すること", async () => {
      const playlistId = "playlist1";

      // まず複数の動画を追加
      await addVideoToPlaylist(playlistId, { videoId: "video1", order: 1 });
      await addVideoToPlaylist(playlistId, { videoId: "video2", order: 2 });

      // 順序を入れ替え
      await updatePlaylistVideo(playlistId, "video1", { order: 2 });
      await updatePlaylistVideo(playlistId, "video2", { order: 1 });

      // 更新後の順序を確認
      const getResult = await getPlaylistById(playlistId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const playlist = getResult.value;
        expect(playlist.videos).toBeDefined();

        if (playlist.videos) {
          const video1 = playlist.videos.find(v => v.id === "video1");
          const video2 = playlist.videos.find(v => v.id === "video2");

          expect(video1?.order).toBe(2);
          expect(video2?.order).toBe(1);

          // 動画がorder値でソートされていることを確認
          const sortedVideos = [...playlist.videos].sort((a, b) => a.order - b.order);
          expect(sortedVideos[0].id).toBe("video2");
          expect(sortedVideos[1].id).toBe("video1");
        }
      }
    });

    it("存在しないプレイリストIDでは動画順序更新がエラーになること", async () => {
      const nonExistentId = "non-existent-id";
      const videoId = "video1";

      // リポジトリ関数を呼び出し
      const result = await updatePlaylistVideo(nonExistentId, videoId, { order: 1 });
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const error = result.error;
        expect(error.type).toBe("notFound");
      }
    });

    it("存在しない動画IDでは順序更新がエラーになること", async () => {
      const playlistId = "playlist1";
      const nonExistentVideoId = "non-existent-video";

      // リポジトリ関数を呼び出し
      const result = await updatePlaylistVideo(playlistId, nonExistentVideoId, { order: 1 });
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const error = result.error;
        // エラータイプが notFound または badRequest のいずれかであることを確認
        expect(["notFound", "badRequest"]).toContain(error.type);
      }
    });

    it("不正な順序値（負の値）では更新がエラーになること", async () => {
      const playlistId = "playlist1";
      const videoId = "video1";

      // 負の順序値で更新を試みる
      const result = await updatePlaylistVideo(playlistId, videoId, { order: -1 });
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        const error = result.error;
        expect(error.type).toBe("badRequest");
        expect(error.message).toContain("順序");
      }
    });

    it("プレイリスト内の複数動画の順序を一度に更新できること", async () => {
      // 注: 仮想的な関数 updatePlaylistVideoOrder を想定しています
      // 実際の実装がある場合は、その関数を使用してください
      const playlistId = "playlist1";

      // まず複数の動画を追加
      await addVideoToPlaylist(playlistId, { videoId: "video1", order: 1 });
      await addVideoToPlaylist(playlistId, { videoId: "video2", order: 2 });
      await addVideoToPlaylist(playlistId, { videoId: "video3", order: 3 });

      // 一度に複数の動画の順序を更新
      const newOrders = [
        { videoId: "video1", order: 3 }, // 1→3
        { videoId: "video2", order: 1 }, // 2→1
        { videoId: "video3", order: 2 }  // 3→2
      ];

      if (typeof updatePlaylistVideoOrder === 'function') {
        const result = await updatePlaylistVideoOrder(playlistId, newOrders);
        expect(result.isOk()).toBe(true);

        // 更新後の順序を確認
        const getResult = await getPlaylistById(playlistId);
        expect(getResult.isOk()).toBe(true);

        if (getResult.isOk()) {
          const playlist = getResult.value;
          expect(playlist.videos).toBeDefined();

          if (playlist.videos) {
            const video1 = playlist.videos.find(v => v.id === "video1");
            const video2 = playlist.videos.find(v => v.id === "video2");
            const video3 = playlist.videos.find(v => v.id === "video3");

            expect(video1?.order).toBe(3);
            expect(video2?.order).toBe(1);
            expect(video3?.order).toBe(2);
          }
        }
      } else {
        // 一括更新関数がない場合は、個別に更新する
        for (const item of newOrders) {
          const result = await updatePlaylistVideo(playlistId, item.videoId, { order: item.order });
          expect(result.isOk()).toBe(true);
        }

        // 更新後の順序を確認
        const getResult = await getPlaylistById(playlistId);
        expect(getResult.isOk()).toBe(true);

        if (getResult.isOk()) {
          const playlist = getResult.value;
          const video1 = playlist.videos?.find(v => v.id === "video1");
          const video2 = playlist.videos?.find(v => v.id === "video2");
          const video3 = playlist.videos?.find(v => v.id === "video3");

          expect(video1?.order).toBe(3);
          expect(video2?.order).toBe(1);
          expect(video3?.order).toBe(2);
        }
      }
    });
  });
});
```

## 動画リポジトリのテスト例

動画の管理機能（作成、更新、削除）とメタデータ管理、検索機能などをテストする例を以下に示します：

```typescript
// src/repositories/videos/videos.test.ts
import { afterEach, beforeEach, describe, expect, it } from "bun:test";
import type { DbClient } from "@/db/config/hono";
import { cleanupTestData, insertTestAuthors, insertTestVideos, setupTestEnv } from "@/repositories/test/setup";
import {
  createVideo,
  updateVideo,
  deleteVideo,
  getVideoById,
  getAllVideos,
  searchVideosByTitle,
  getVideosByAuthor,
  updateVideoThumbnail
} from "./index";
import type { VideoInsert, VideoUpdate } from "./types";

// テスト用の状態を保持する変数
let dbClient: DbClient;

describe("動画リポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
    await insertTestVideos(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("createVideo", () => {
    it("新しい動画を作成できること", async () => {
      // テスト用の動画データ
      const videoData: VideoInsert = {
        title: "新しい動画",
        url: "https://example.com/new-video",
        thumbnailUrl: "https://example.com/thumbnail.jpg",
        description: "テスト用の新しい動画です",
        authorId: "author1"
      };

      // リポジトリ関数を呼び出し
      const result = await createVideo(videoData);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const videoId = result.value;

        // 作成された動画を取得して検証
        const getResult = await getVideoById(videoId);

        expect(getResult.isOk()).toBe(true);

        if (getResult.isOk()) {
          const video = getResult.value;
          expect(video.title).toBe(videoData.title);
          expect(video.url).toBe(videoData.url);
          expect(video.thumbnailUrl).toBe(videoData.thumbnailUrl);
          expect(video.description).toBe(videoData.description);
          expect(video.authorId).toBe(videoData.authorId);
        }
      }
    });

    it("不正なURLでエラーになること", async () => {
      // 不正なデータ（無効なURL）
      const invalidData: VideoInsert = {
        title: "不正なURL",
        url: "invalid-url", // 不正なURL形式
        authorId: "author1"
      };

      // リポジトリ関数を呼び出し
      const result = await createVideo(invalidData);

      // 結果がエラーであることを確認
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("badRequest");
        expect(result.error.message).toContain("URL");
      }
    });
  });

  describe("動画検索機能", () => {
    it("タイトルで動画を検索できること", async () => {
      // 検索キーワード
      const searchKeyword = "テスト";

      // リポジトリ関数を呼び出し
      const result = await searchVideosByTitle(searchKeyword);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const videos = result.value;

        // 検索キーワードを含む動画のみが返されることを確認
        expect(videos.length).toBeGreaterThan(0);

        for (const video of videos) {
          expect(video.title.toLowerCase()).toContain(searchKeyword.toLowerCase());
        }
      }
    });

    it("作者IDで動画を取得できること", async () => {
      const authorId = "author1";

      // リポジトリ関数を呼び出し
      const result = await getVideosByAuthor(authorId);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const videos = result.value;

        // 指定した作者の動画のみが返されることを確認
        expect(videos.length).toBeGreaterThan(0);

        for (const video of videos) {
          expect(video.authorId).toBe(authorId);

          // 作者情報が含まれていることを確認
          expect(video.author).toBeDefined();
          expect(video.author?.id).toBe(authorId);
        }
      }
    });
  });

  describe("updateVideoThumbnail", () => {
    it("動画のサムネイルを更新できること", async () => {
      const videoId = "video1";
      const newThumbnailUrl = "https://example.com/new-thumbnail.jpg";

      // リポジトリ関数を呼び出し
      const result = await updateVideoThumbnail(videoId, newThumbnailUrl);

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      // 更新された動画を取得して確認
      const getResult = await getVideoById(videoId);
      expect(getResult.isOk()).toBe(true);

      if (getResult.isOk()) {
        const video = getResult.value;
        expect(video.thumbnailUrl).toBe(newThumbnailUrl);
      }
    });
  });
});
```

## リポジトリフックのミューテーション操作テスト

ミューテーション操作（作成・更新・削除）を行うフックのテスト例：

```typescript
// src/repositories/playlists/hooks.test.ts
describe('useCreatePlaylist', () => {
  it('プレイリストの作成が成功した場合、キャッシュが更新されること', async () => {
    // 初期データの設定
    const initialPlaylists = [
      { id: 'playlist1', title: '既存プレイリスト1' },
      { id: 'playlist2', title: '既存プレイリスト2' }
    ];

    // getAllPlaylistsのモック
    mockedPlaylistsRepository.getAllPlaylists.mockResolvedValue({
      isOk: () => true,
      isErr: () => false,
      value: initialPlaylists
    } as any);

    // createPlaylistのモック
    const newPlaylistId = 'new-playlist-id';
    mockedPlaylistsRepository.createPlaylist.mockResolvedValue({
      isOk: () => true,
      isErr: () => false,
      value: newPlaylistId
    } as any);

    // プレイリスト一覧を取得するフックをレンダリング
    const { result: playlistsResult } = renderHook(() => usePlaylists(), { wrapper });

    // データが取得されるまで待機
    await waitFor(() => expect(playlistsResult.current.isLoading).toBe(false));
    expect(playlistsResult.current.data).toEqual(initialPlaylists);

    // プレイリスト作成フックをレンダリング
    const { result: createResult } = renderHook(() => useCreatePlaylist(), { wrapper });

    // 作成フックのミューテーション関数を実行
    const newPlaylist = { title: '新しいプレイリスト' };
    await act(async () => {
      await createResult.current.mutateAsync(newPlaylist);
    });

    // プレイリスト一覧のデータが更新されたことを確認
    await waitFor(() => expect(queryClient.getQueryData(['playlists'])).not.toEqual(initialPlaylists));

    // 作成が成功したことを確認
    expect(createResult.current.isSuccess).toBe(true);
    expect(createResult.current.data).toEqual(newPlaylistId);

    // モック関数が正しく呼ばれたことを確認
    expect(mockedPlaylistsRepository.createPlaylist).toHaveBeenCalledWith(newPlaylist);
  });

  it('エラー発生時にエラー状態になること', async () => {
    // createPlaylistのモックでエラーを返す
    mockedPlaylistsRepository.createPlaylist.mockResolvedValue({
      isOk: () => false,
      isErr: () => true,
      error: { type: 'badRequest', message: 'バリデーションエラー' }
    } as any);

    // フックをレンダリング
    const { result } = renderHook(() => useCreatePlaylist(), { wrapper });

    // ミューテーション関数を実行
    await act(async () => {
      try {
        await result.current.mutateAsync({ title: '新しいプレイリスト' });
      } catch (error) {
        // エラーはキャッチするが何もしない
      }
    });

    // エラー状態になっていることを確認
    expect(result.current.isError).toBe(true);
    expect(result.current.error).toEqual({ type: 'badRequest', message: 'バリデーションエラー' });
  });
});
```

## ベストプラクティス

### 一般的なベストプラクティス

1. **テストの分離**: 各テストは独立して実行できるようにする
2. **テストデータの明示**: テストに必要なデータを明示的に定義する
3. **テスト用ヘルパー関数**: 共通のセットアップや検証ロジックをヘルパー関数として抽出
4. **エラーケースのテスト**: 正常系だけでなく、エラーケースも必ずテストする
5. **モックの適切な使用**: 外部依存はモックするが、ビジネスロジック自体はモックしない

### テスト項目のチェックリスト

サービス層・リポジトリ層のテストでは、以下の項目を確認します：

- [ ] 基本的なCRUD操作が正しく動作するか
- [ ] エラーケースが適切に処理されるか
- [ ] 関連エンティティが正しく取得・結合されるか
- [ ] バリデーションが正しく機能するか
- [ ] 期待通りのデータ変換が行われるか
- [ ] パフォーマンス要件を満たしているか（必要に応じて）

### データ型のテスト

1. **型安全性**: 関数の入力と出力が正しい型であることを確認
2. **バリデーション**: スキーマバリデーションが正しく機能することを確認
3. **部分的更新**: 部分的更新（Partial Update）が正しく機能することを確認
4. **型変換**: データ変換（DB型からドメイン型など）が正しく行われることを確認

### APIクライアントの使い方

1. **エラーハンドリング**: API呼び出しのエラーが適切に処理されることを確認
2. **リトライ**: 必要に応じてリトライロジックが機能することを確認
3. **キャッシュ**: キャッシュが正しく動作することを確認（React Queryなど）
4. **並行リクエスト**: 並行リクエストが正しく処理されることを確認

### テスト実行のベストプラクティス

1. **継続的インテグレーション**: CIパイプラインでテストを自動実行する
2. **高速なテスト実行**: テストは高速に実行できるようにする
3. **コードカバレッジの測定**: 重要なコードパスがテストされていることを確認
4. **テスト失敗の迅速な対応**: テストが失敗したら優先的に修正する
5. **テストコードのレビュー**: 実装コードと同様にテストコードもレビューの対象とする

### React Queryを使用した動画順序更新フック

動画の順序更新操作のためのReact Queryフックの実装例：

```typescript
// src/repositories/playlists/hooks.ts
import {
  useQuery,
  useMutation,
  useQueryClient
} from '@tanstack/react-query';
import { updatePlaylistVideo } from './index';
import type { PlaylistVideoUpdate } from './types';

// プレイリスト内の動画を更新するフック
export function useUpdatePlaylistVideo(playlistId: string) {
  const queryClient = useQueryClient();

  return useMutation({
    mutationFn: async ({
      videoId,
      data,
    }: {
      videoId: string;
      data: PlaylistVideoUpdate;
    }) => {
      const result = await updatePlaylistVideo(playlistId, videoId, data);
      if (result.isErr()) {
        throw result.error;
      }
      return result.value;
    },
    onSuccess: () => {
      // 更新成功後に該当プレイリストを再取得
      queryClient.invalidateQueries({ queryKey: ['playlists', playlistId] });
    },
  });
}

// このフックのテスト例
// src/repositories/playlists/hooks.test.ts
describe('useUpdatePlaylistVideo', () => {
  it('動画の順序を更新し、キャッシュが正しく更新されること', async () => {
    // updatePlaylistVideoのモック
    mockedPlaylistsRepository.updatePlaylistVideo.mockResolvedValue({
      isOk: () => true,
      isErr: () => false,
      value: undefined
    } as any);

    // プレイリストIDと動画ID
    const playlistId = 'playlist1';
    const videoId = 'video1';

    // 更新データ
    const updateData: PlaylistVideoUpdate = {
      order: 999,
    };

    // フックをレンダリング
    const { result } = renderHook(() => useUpdatePlaylistVideo(playlistId), { wrapper });

    // ミューテーション関数を実行
    await act(async () => {
      await result.current.mutateAsync({
        videoId,
        data: updateData,
      });
    });

    // 成功したことを確認
    expect(result.current.isSuccess).toBe(true);

    // モック関数が正しく呼ばれたことを確認
    expect(mockedPlaylistsRepository.updatePlaylistVideo).toHaveBeenCalledWith(
      playlistId,
      videoId,
      updateData
    );

    // キャッシュが無効化されたことを確認
    expect(queryClient.invalidateQueries).toHaveBeenCalledWith({
      queryKey: ['playlists', playlistId]
    });
  });

  it('エラー発生時にエラー状態になること', async () => {
    // updatePlaylistVideoのモックでエラーを返す
    mockedPlaylistsRepository.updatePlaylistVideo.mockResolvedValue({
      isOk: () => false,
      isErr: () => true,
      error: {
        type: 'badRequest',
        message: '順序は0以上の整数である必要があります'
      }
    } as any);

    // フックをレンダリング
    const { result } = renderHook(() => useUpdatePlaylistVideo('playlist1'), { wrapper });

    // ミューテーション関数を実行
    await act(async () => {
      try {
        await result.current.mutateAsync({
          videoId: 'video1',
          data: { order: -1 } // 不正な値
        });
      } catch (error) {
        // エラーはキャッチするが何もしない
      }
    });

    // エラー状態になっていることを確認
    expect(result.current.isError).toBe(true);
    expect(result.current.error).toEqual({
      type: 'badRequest',
      message: '順序は0以上の整数である必要があります'
    });
  });
});

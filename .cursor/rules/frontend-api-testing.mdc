---
description: Kirinuki-Playlistプロジェクトのサービス層テスト規約
globs: src/**/__tests__/**/*.ts
---
# サービス層・リポジトリ層テスト規約

Kirinuki-Playlistプロジェクトでは、サービス層（ビジネスロジック）とリポジトリ層（APIクライアント）のテストに関して以下の規約を定めています。

## 基本方針

1. **単体テスト重視**: 各機能を個別にテストし、依存関係はモックする
2. **テスト容易性**: テスト可能なコードを書くことを重視
3. **カバレッジ**: 重要なビジネスロジックは高いカバレッジを目指す
4. **実行速度**: テストは高速に実行できるようにする
5. **メンテナンス性**: テストは保守しやすく、理解しやすいものにする

## テスト環境設定

### テストフレームワーク

テストには Bun Test（Jest互換）を使用します。

```typescript
// package.json
{
  "scripts": {
    "test": "bun test",
    "test:watch": "bun test --watch"
  }
}
```

### ディレクトリ構造

テストファイルは `__tests__` ディレクトリに配置し、テスト対象のファイル名に `.test.ts` サフィックスを付けます。

```
src/
├── db/
│   ├── services/
│   │   ├── __tests__/
│   │   │   ├── videos.test.ts
│   │   │   ├── playlists.test.ts
│   │   │   └── authors.test.ts
│   │   ├── videos.ts
│   │   ├── playlists.ts
│   │   └── authors.ts
│   ├── ...
├── repositories/
│   ├── __tests__/
│   │   ├── setup.ts          # テスト共通セットアップ
│   │   ├── utils.test.ts     # 共通ユーティリティのテスト
│   ├── videos/
│   │   ├── __tests__/
│   │   │   └── videos.test.ts
│   │   ├── index.ts
│   │   └── types.ts
│   ├── playlists/
│   │   ├── __tests__/
│   │   │   └── playlists.test.ts
│   │   ├── index.ts
│   │   └── types.ts
│   └── ...
```

## サービス層テスト

サービス層はビジネスロジックを担当し、データベースアクセスに依存します。テスト時はデータベースをモックします。

### モック方法

データベースのモックには、以下のアプローチを使用します：

```typescript
// src/db/services/__tests__/videos.test.ts
import { createVideoService } from "../videos";
import { mockDb } from "../../../test/mock-db";

// テスト前の共通セットアップ
let videoService: ReturnType<typeof createVideoService>;
let mockDatabase: ReturnType<typeof mockDb>;

beforeEach(() => {
  // データベースモックの作成
  mockDatabase = mockDb();

  // モックデータベースを使用してサービスを初期化
  videoService = createVideoService(mockDatabase);
});

afterEach(() => {
  // 必要に応じてクリーンアップ処理
  jest.clearAllMocks();
});
```

### テストケース例

```typescript
describe("VideoService", () => {
  describe("getAllVideos", () => {
    it("すべての動画を取得できること", async () => {
      // モックデータの準備
      const mockVideos = [
        { id: "1", title: "テスト動画1", url: "https://example.com/1", authorId: "author1" },
        { id: "2", title: "テスト動画2", url: "https://example.com/2", authorId: "author2" }
      ];

      // データベースのモック応答を設定
      mockDatabase.prepare.mockReturnValueOnce({
        all: jest.fn().mockResolvedValueOnce(mockVideos)
      });

      // テスト対象関数の実行
      const result = await videoService.getAllVideos();

      // 結果の検証
      expect(result).toHaveLength(2);
      expect(result[0].title).toBe("テスト動画1");
      expect(result[1].title).toBe("テスト動画2");

      // データベースの呼び出しを検証
      expect(mockDatabase.prepare).toHaveBeenCalledWith(expect.stringContaining("SELECT * FROM videos"));
    });

    it("エラー発生時に適切に処理されること", async () => {
      // エラーをスローするようにモックを設定
      mockDatabase.prepare.mockReturnValueOnce({
        all: jest.fn().mockRejectedValueOnce(new Error("DB error"))
      });

      // テスト対象関数の実行とエラーのキャッチ
      await expect(videoService.getAllVideos()).rejects.toThrow("動画の取得中にエラーが発生しました");
    });
  });

  describe("getVideoById", () => {
    it("指定したIDの動画を取得できること", async () => {
      // モックデータの準備
      const mockVideo = { id: "1", title: "テスト動画", url: "https://example.com/1", authorId: "author1" };

      // データベースのモック応答を設定
      mockDatabase.prepare.mockReturnValueOnce({
        get: jest.fn().mockResolvedValueOnce(mockVideo)
      });

      // テスト対象関数の実行
      const result = await videoService.getVideoById("1");

      // 結果の検証
      expect(result).not.toBeNull();
      expect(result?.id).toBe("1");
      expect(result?.title).toBe("テスト動画");

      // データベースの呼び出しを検証
      expect(mockDatabase.prepare).toHaveBeenCalledWith(expect.stringContaining("SELECT * FROM videos WHERE id = ?"));
    });

    it("存在しないIDの場合はnullを返すこと", async () => {
      // データベースのモック応答を設定（データなし）
      mockDatabase.prepare.mockReturnValueOnce({
        get: jest.fn().mockResolvedValueOnce(null)
      });

      // テスト対象関数の実行
      const result = await videoService.getVideoById("999");

      // 結果の検証
      expect(result).toBeNull();
    });
  });

  // その他のメソッドのテスト...
});
```

### 関連エンティティのテスト

複数のエンティティが関連する処理のテスト例：

```typescript
// src/db/services/__tests__/playlists.test.ts
describe("PlaylistService", () => {
  describe("getPlaylistWithVideosById", () => {
    it("プレイリストとそれに含まれる動画を取得できること", async () => {
      // プレイリストのモックデータ
      const mockPlaylist = {
        id: "1",
        title: "テストプレイリスト",
        authorId: "author1"
      };

      // プレイリスト-動画関連のモックデータ
      const mockPlaylistVideos = [
        { playlistId: "1", videoId: "video1" },
        { playlistId: "1", videoId: "video2" }
      ];

      // 動画のモックデータ
      const mockVideos = [
        { id: "video1", title: "テスト動画1", url: "https://example.com/1", authorId: "author1" },
        { id: "video2", title: "テスト動画2", url: "https://example.com/2", authorId: "author2" }
      ];

      // データベースのモック応答を順番に設定
      mockDatabase.prepare
        // プレイリスト取得
        .mockReturnValueOnce({
          get: jest.fn().mockResolvedValueOnce(mockPlaylist)
        })
        // プレイリスト-動画関連取得
        .mockReturnValueOnce({
          all: jest.fn().mockResolvedValueOnce(mockPlaylistVideos)
        })
        // 動画取得
        .mockReturnValueOnce({
          all: jest.fn().mockResolvedValueOnce(mockVideos)
        });

      // テスト対象関数の実行
      const result = await playlistService.getPlaylistWithVideosById("1");

      // 結果の検証
      expect(result).not.toBeNull();
      expect(result?.id).toBe("1");
      expect(result?.title).toBe("テストプレイリスト");
      expect(result?.videos).toHaveLength(2);
      expect(result?.videos?.[0].title).toBe("テスト動画1");
      expect(result?.videos?.[1].title).toBe("テスト動画2");
    });

    // 他のテストケース...
  });
});
```

## リポジトリ層テスト

リポジトリ層はAPIクライアントを使用してサーバーと通信します。テスト時はAPIクライアントをモックします。

### モック方法

APIクライアントのモックには、シングルトンパターンの `setApiClient` 関数を使用します：

```typescript
// src/repositories/__tests__/setup.ts
import { setApiClient } from "@/db/config/client";

export function setupMockApiClient() {
  const mockClient = {
    api: {
      videos: {
        $get: jest.fn(),
        $post: jest.fn(),
        [":id"]: {
          $get: jest.fn(),
          $patch: jest.fn(),
          $delete: jest.fn()
        }
      },
      playlists: {
        $get: jest.fn(),
        $post: jest.fn(),
        [":id"]: {
          $get: jest.fn(),
          $patch: jest.fn(),
          $delete: jest.fn(),
          withVideos: {
            $get: jest.fn()
          },
          videos: {
            $post: jest.fn(),
            [":videoId"]: {
              $delete: jest.fn()
            }
          }
        }
      },
      authors: {
        $get: jest.fn(),
        $post: jest.fn(),
        [":id"]: {
          $get: jest.fn(),
          $patch: jest.fn(),
          $delete: jest.fn()
        }
      }
    }
  };

  setApiClient(mockClient as any);

  return mockClient;
}
```

### テストケース例

```typescript
// src/repositories/videos/__tests__/videos.test.ts
import { getAllVideos, getVideoById } from "@/repositories/videos";
import { setupMockApiClient } from "@/repositories/__tests__/setup";

describe("VideoRepository", () => {
  let mockClient: ReturnType<typeof setupMockApiClient>;

  beforeEach(() => {
    // APIクライアントのモックをセットアップ
    mockClient = setupMockApiClient();
  });

  describe("getAllVideos", () => {
    it("成功時に動画リストを返すこと", async () => {
      // モックレスポンスの設定
      mockClient.api.videos.$get.mockResolvedValueOnce({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          videos: [
            { id: "1", title: "テスト動画1" },
            { id: "2", title: "テスト動画2" }
          ]
        })
      });

      // テスト対象関数の実行
      const result = await getAllVideos();

      // 結果の検証
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        expect(result.value).toHaveLength(2);
        expect(result.value[0].id).toBe("1");
        expect(result.value[1].id).toBe("2");
      }

      // APIクライアントの呼び出しを検証
      expect(mockClient.api.videos.$get).toHaveBeenCalledTimes(1);
    });

    it("APIエラー時にエラー結果を返すこと", async () => {
      // エラーレスポンスのモック
      mockClient.api.videos.$get.mockResolvedValueOnce({
        ok: false,
        status: 500,
        json: jest.fn().mockResolvedValueOnce({
          success: false,
          message: "サーバーエラー"
        })
      });

      // テスト対象関数の実行
      const result = await getAllVideos();

      // 結果の検証
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("serverError");
        expect(result.error.message).toContain("サーバーエラー");
      }
    });

    it("スキーマ検証エラー時にスキーマエラーを返すこと", async () => {
      // 無効なレスポンス形式のモック
      mockClient.api.videos.$get.mockResolvedValueOnce({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          // videos配列が欠けている
        })
      });

      // テスト対象関数の実行
      const result = await getAllVideos();

      // 結果の検証
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("schema");
      }
    });

    it("ネットワークエラー時にネットワークエラーを返すこと", async () => {
      // ネットワークエラーのモック
      mockClient.api.videos.$get.mockRejectedValueOnce(new Error("Network error"));

      // テスト対象関数の実行
      const result = await getAllVideos();

      // 結果の検証
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("network");
        expect(result.error.message).toContain("Network error");
      }
    });
  });

  describe("getVideoById", () => {
    it("指定したIDの動画を返すこと", async () => {
      // モックレスポンスの設定
      mockClient.api.videos[":id"].$get.mockImplementationOnce(({ param }) => ({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          video: { id: param.id, title: `テスト動画 ${param.id}` }
        })
      }));

      // テスト対象関数の実行
      const result = await getVideoById("123");

      // 結果の検証
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        expect(result.value.id).toBe("123");
        expect(result.value.title).toBe("テスト動画 123");
      }

      // APIクライアントの呼び出しを検証
      expect(mockClient.api.videos[":id"].$get).toHaveBeenCalledWith({
        param: { id: "123" }
      });
    });

    // 他のエラーケースのテスト...
  });
});
```

### 関連エンティティのテスト

リポジトリ層で関連エンティティを処理するテスト例：

```typescript
// src/repositories/playlists/__tests__/playlists.test.ts
import { getPlaylistWithVideosById } from "@/repositories/playlists";
import { setupMockApiClient } from "@/repositories/__tests__/setup";

describe("PlaylistRepository", () => {
  let mockClient: ReturnType<typeof setupMockApiClient>;

  // テスト用の著者データ
  const testAuthor = {
    id: "author1",
    name: "テスト著者",
    iconUrl: "https://example.com/icon.jpg",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString()
  };

  // テスト用の動画データ（著者情報付き）
  const testVideosWithAuthor = [
    {
      id: "video1",
      title: "テスト動画1",
      url: "https://example.com/video1",
      authorId: "author1",
      author: testAuthor,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    },
    {
      id: "video2",
      title: "テスト動画2",
      url: "https://example.com/video2",
      authorId: "author1",
      author: testAuthor,
      createdAt: new Date().toISOString(),
      updatedAt: new Date().toISOString()
    }
  ];

  // テスト用のプレイリストデータ（動画と著者情報付き）
  const testPlaylistWithVideos = {
    id: "playlist1",
    title: "テストプレイリスト",
    authorId: "author1",
    createdAt: new Date().toISOString(),
    updatedAt: new Date().toISOString(),
    videos: testVideosWithAuthor
  };

  beforeEach(() => {
    // APIクライアントのモックをセットアップ
    mockClient = setupMockApiClient();
  });

  describe("getPlaylistWithVideosById", () => {
    it("プレイリストと関連する動画、著者情報を取得できること", async () => {
      // モックレスポンスの設定
      mockClient.api.playlists[":id"].withVideos.$get.mockImplementationOnce(({ param }) => ({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          playlist: testPlaylistWithVideos
        })
      }));

      // テスト対象関数の実行
      const result = await getPlaylistWithVideosById("playlist1");

      // 結果の検証
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const playlist = result.value;

        // プレイリスト情報の検証
        expect(playlist.id).toBe("playlist1");
        expect(playlist.title).toBe("テストプレイリスト");

        // 動画情報の検証
        expect(playlist.videos).toBeDefined();
        expect(playlist.videos.length).toBe(2);
        expect(playlist.videos[0].title).toBe("テスト動画1");
        expect(playlist.videos[1].title).toBe("テスト動画2");

        // 著者情報の検証
        expect(playlist.videos[0].author).toBeDefined();
        expect(playlist.videos[0].author.name).toBe("テスト著者");
        expect(playlist.videos[1].author.name).toBe("テスト著者");
      }

      // APIクライアントの呼び出しを検証
      expect(mockClient.api.playlists[":id"].withVideos.$get).toHaveBeenCalledWith({
        param: { id: "playlist1" }
      });
    });

    it("動画情報が含まれていない場合はエラーを返すこと", async () => {
      // 動画情報が欠けているプレイリストデータ
      const playlistWithoutVideos = {
        ...testPlaylistWithVideos,
        videos: undefined
      };

      // モックレスポンスの設定
      mockClient.api.playlists[":id"].withVideos.$get.mockImplementationOnce(({ param }) => ({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          playlist: playlistWithoutVideos
        })
      }));

      // テスト対象関数の実行
      const result = await getPlaylistWithVideosById("playlist1");

      // 結果の検証
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("relation");
        expect(result.error.message).toContain("動画情報");
      }
    });

    it("動画の著者情報が欠けている場合はエラーを返すこと", async () => {
      // 著者情報が欠けている動画データ
      const videosWithoutAuthor = testVideosWithAuthor.map(video => ({
        ...video,
        author: undefined
      }));

      // 著者情報が欠けているプレイリストデータ
      const playlistWithVideosWithoutAuthor = {
        ...testPlaylistWithVideos,
        videos: videosWithoutAuthor
      };

      // モックレスポンスの設定
      mockClient.api.playlists[":id"].withVideos.$get.mockImplementationOnce(({ param }) => ({
        ok: true,
        json: jest.fn().mockResolvedValueOnce({
          success: true,
          playlist: playlistWithVideosWithoutAuthor
        })
      }));

      // テスト対象関数の実行
      const result = await getPlaylistWithVideosById("playlist1");

      // 結果の検証
      expect(result.isErr()).toBe(true);

      if (result.isErr()) {
        expect(result.error.type).toBe("relation");
        expect(result.error.message).toContain("著者情報");
      }
    });

    // その他のエラーケーステスト...
  });
});
```

## 統合テスト

リポジトリとサービスを統合したテストも必要に応じて実装します。これにより、レイヤー間の連携が正しく動作することを確認できます。

```typescript
// src/integration-tests/playlist-flow.test.ts
import { createPlaylistService } from "@/db/services/playlists";
import * as playlistRepository from "@/repositories/playlists";
import { setupTestDb } from "@/test/setup-db";

// リポジトリ層をモック
jest.mock("@/repositories/playlists");

describe("プレイリスト機能の統合テスト", () => {
  const mockPlaylistRepo = playlistRepository as jest.Mocked<typeof playlistRepository>;
  let playlistService: ReturnType<typeof createPlaylistService>;
  let testDb: ReturnType<typeof setupTestDb>;

  beforeEach(() => {
    // テスト用データベースのセットアップ
    testDb = setupTestDb();
    playlistService = createPlaylistService(testDb);

    // リポジトリモックのリセット
    jest.clearAllMocks();
  });

  it("プレイリスト作成からビデオ追加までの一連のフローが機能すること", async () => {
    // モックの設定
    mockPlaylistRepo.createPlaylist.mockResolvedValueOnce({
      isOk: () => true,
      isErr: () => false,
      value: "playlist1"
    } as any);

    mockPlaylistRepo.addVideoToPlaylist.mockResolvedValueOnce({
      isOk: () => true,
      isErr: () => false,
      value: true
    } as any);

    mockPlaylistRepo.getPlaylistWithVideosById.mockResolvedValueOnce({
      isOk: () => true,
      isErr: () => false,
      value: {
        id: "playlist1",
        title: "新しいプレイリスト",
        videos: [{ id: "video1", title: "テスト動画" }]
      }
    } as any);

    // プレイリスト作成
    const createResult = await playlistService.createPlaylist({
      title: "新しいプレイリスト",
      authorId: "author1"
    });

    expect(createResult).toBe("playlist1");
    expect(mockPlaylistRepo.createPlaylist).toHaveBeenCalledWith(expect.objectContaining({
      title: "新しいプレイリスト"
    }));

    // ビデオ追加
    const addResult = await playlistService.addVideoToPlaylist("playlist1", "video1");

    expect(addResult.success).toBe(true);
    expect(mockPlaylistRepo.addVideoToPlaylist).toHaveBeenCalledWith("playlist1", "video1");

    // プレイリスト取得（動画情報付き）
    const getResult = await playlistService.getPlaylistWithVideosById("playlist1");

    expect(getResult).toBeDefined();
    expect(getResult?.title).toBe("新しいプレイリスト");
    expect(getResult?.videos).toHaveLength(1);
    expect(getResult?.videos?.[0].title).toBe("テスト動画");
  });
});
```

## ベストプラクティス

### 一般的なベストプラクティス

1. **テストの分離**: 各テストは独立して実行できるようにする
2. **テストデータの明示**: テストに必要なデータを明示的に定義する
3. **テスト用ヘルパー関数**: 共通のセットアップや検証ロジックをヘルパー関数として抽出
4. **エラーケースのテスト**: 正常系だけでなく、エラーケースも必ずテストする
5. **モックの適切な使用**: 外部依存はモックするが、ビジネスロジック自体はモックしない

### テスト項目のチェックリスト

サービス層・リポジトリ層のテストでは、以下の項目を確認します：

- [ ] 基本的なCRUD操作が正しく動作するか
- [ ] エラーケースが適切に処理されるか
- [ ] 関連エンティティが正しく取得・結合されるか
- [ ] バリデーションが正しく機能するか
- [ ] 期待通りのデータ変換が行われるか
- [ ] パフォーマンス要件を満たしているか（必要に応じて）

### テスト実行のベストプラクティス

1. **継続的インテグレーション**: CIパイプラインでテストを自動実行する
2. **高速なテスト実行**: テストは高速に実行できるようにする
3. **コードカバレッジの測定**: 重要なコードパスがテストされていることを確認
4. **テスト失敗の迅速な対応**: テストが失敗したら優先的に修正する
5. **テストコードのレビュー**: 実装コードと同様にテストコードもレビューの対象とする

---
description: Kirinuki-Playlistプロジェクトのサービス層テスト規約
globs: src/db/services/__tests__/**/*.ts
---
# サービス層テスト規約

## テスト基本方針

- **アダプタパターン**: DBクライアントの依存性注入によるテスト容易性の向上
- **インメモリデータベース**: Bunの組み込みSQLiteを使用した高速テスト環境
- **テストの独立性**: 各テストケースは互いに影響を与えないよう設計
- **明確なエラーハンドリング**: 具体的なエラー型を定義して例外処理を統一
- **型安全**: TypeScriptの型システムを活用した堅牢なインターフェース設計

## テストディレクトリ構造

```
src/
├── db/
│   ├── config/
│   │   └── database.ts                 # DBクライアント設定
│   ├── models/
│   │   ├── authors.ts                  # 著者モデル定義
│   │   ├── videos.ts                   # 動画モデル定義
│   │   └── playlists.ts                # プレイリストモデル定義
│   ├── services/                       # サービス層の実装
│   │   ├── authors/                    # 著者サービス
│   │   │   ├── authors.ts              # 著者サービス実装
│   │   │   └── authors.test.ts         # 著者サービステスト
│   │   ├── videos/                     # 動画サービス
│   │   │   ├── videos.ts               # 動画サービス実装
│   │   │   └── videos.test.ts          # 動画サービステスト
│   │   └── playlists/                  # プレイリストサービス
│   │       ├── playlists.ts            # プレイリストサービス実装
│   │       └── playlists.test.ts       # プレイリストサービステスト
│   └── utils/
│       └── errors.ts                   # エラー定義
```

## Bun SQLiteを使用したテスト環境のセットアップ

Bunの組み込みSQLite機能を使用してインメモリデータベースのテスト環境を構築します：

```typescript
// src/db/config/database.ts
import { Database } from "bun:sqlite";
import { drizzle as drizzleSqlite } from "drizzle-orm/bun-sqlite";
import type { D1Database } from "@cloudflare/workers-types";
import { drizzle } from "drizzle-orm/d1";

// プロダクション環境用のデータベースクライアントを作成
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};

// テスト環境用のデータベースクライアントを作成
export const createTestDbClient = async () => {
  // インメモリデータベースを作成（":memory:"を指定）
  const sqlite = new Database(":memory:");

  // テーブルスキーマを作成
  sqlite.exec(`
    CREATE TABLE IF NOT EXISTS authors (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      icon_url TEXT NOT NULL,
      bio TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `);
  // 他のテーブル作成

  // Drizzle ORMのクライアントを作成
  const db = drizzleSqlite(sqlite);

  return db;
};
```

## サービス層の設計とテスト

サービス層は次のポイントを考慮して設計します：

1. **依存性注入**: DBクライアントをパラメータとして受け取る
2. **明確なエラーハンドリング**: 具体的なエラー型を定義して使用
3. **テストの独立性**: 各テストは独自のデータセットで実行

```typescript
// src/db/services/authors.ts
import type { D1Database } from "@cloudflare/workers-types";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { createDbClient, type createTestDbClient } from "../config/database";
import { authors } from "../models/authors";
import { DatabaseError, NotFoundError, UniqueConstraintError } from "../utils/errors";

export type Author = InferSelectModel<typeof authors>;
export type AuthorInsert = Omit<InferInsertModel<typeof authors>, "id" | "createdAt" | "updatedAt">;
export type AuthorUpdate = Partial<Omit<InferInsertModel<typeof authors>, "id" | "createdAt" | "updatedAt">>;

// データベースクライアントの型定義（プロダクションとテスト両方に対応）
export type DbClient =
  | ReturnType<typeof createDbClient>
  | Awaited<ReturnType<typeof createTestDbClient>>;

// 依存性注入パターンを使った著者サービスの作成関数
export const createAuthorService = (dbClient: DbClient) => ({
  // 全著者取得
  async getAllAuthors(): Promise<Author[]> {
    try {
      return await dbClient.select().from(authors).all();
    } catch (_) {
      throw new DatabaseError("著者一覧の取得に失敗しました");
    }
  },

  // IDによる著者取得
  async getAuthorById(id: string): Promise<Author> {
    try {
      const author = await dbClient
        .select()
        .from(authors)
        .where(eq(authors.id, id))
        .get();

      if (!author) {
        throw new NotFoundError(`ID: ${id} の著者が見つかりません`);
      }

      return author;
    } catch (error) {
      if (error instanceof NotFoundError) {
        throw error;
      }
      throw new DatabaseError(
        `著者の取得中にエラーが発生しました: ${
          error instanceof Error ? error.message : "不明なエラー"
        }`
      );
    }
  },

  // その他のCRUD操作
});

// デフォルトのauthorServiceインスタンス（API層で使用）
export const authorService = {
  getAllAuthors: (db: D1Database) => {
    const client = createDbClient(db);
    return createAuthorService(client).getAllAuthors();
  },
  // 他のメソッド
};
```

## サービス層のテスト実装

```typescript
// src/db/services/__tests__/authors.test.ts
import { beforeEach, describe, expect, test } from "bun:test";
import { eq } from "drizzle-orm";
import { createTestDbClient } from "../../config/database";
import { authors } from "../../models/authors";
import { NotFoundError } from "../../utils/errors";
import { type Author, createAuthorService } from "../authors";

// テストデータ
const testAuthors: Omit<Author, "createdAt" | "updatedAt">[] = [
  {
    id: "author1",
    name: "テスト著者1",
    iconUrl: "https://example.com/icon1.png",
    bio: "テスト著者1の自己紹介",
  },
  {
    id: "author2",
    name: "テスト著者2",
    iconUrl: "https://example.com/icon2.png",
    bio: "テスト著者2の自己紹介",
  },
];

// ヘルパー関数: データベースとサービスの初期化
async function setupDatabase() {
  const dbClient = await createTestDbClient();
  const service = createAuthorService(dbClient);

  // テーブルをクリア
  await dbClient.delete(authors).run();

  // テストデータを挿入
  for (const author of testAuthors) {
    await dbClient.insert(authors).values({
      ...author,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  }

  return { dbClient, service };
}

describe("authorService", () => {
  describe("getAllAuthors", () => {
    let service: ReturnType<typeof createAuthorService>;

    beforeEach(async () => {
      const result = await setupDatabase();
      service = result.service;
    });

    test("全ての著者を取得できること", async () => {
      const result = await service.getAllAuthors();
      expect(result.length).toBe(2);

      // データを検証
      const sorted = result.sort((a, b) => a.id.localeCompare(b.id));
      expect(sorted[0].id).toBe("author1");
      expect(sorted[0].name).toBe("テスト著者1");
    });
  });

  // 更新や削除のテストケース
  describe("updateAuthor", () => {
    let dbClient: Awaited<ReturnType<typeof createTestDbClient>>;
    let service: ReturnType<typeof createAuthorService>;

    beforeEach(async () => {
      ({ dbClient, service } = await setupDatabase());
    });

    test("著者を更新できること", async () => {
      const updateData = {
        name: "更新著者名",
        bio: "更新された自己紹介",
      };

      await service.updateAuthor("author1", updateData);

      // 更新を検証
      const updatedAuthor = await dbClient
        .select()
        .from(authors)
        .where(eq(authors.id, "author1"))
        .get();

      expect(updatedAuthor?.name).toBe("更新著者名");
      expect(updatedAuthor?.bio).toBe("更新された自己紹介");
      // 更新していないフィールドは変更されないことを確認
      expect(updatedAuthor?.iconUrl).toBe("https://example.com/icon1.png");
    });

    test("存在しないIDの更新はNotFoundErrorをスローすること", async () => {
      let errorThrown = false;
      try {
        await service.updateAuthor("non-existent", { name: "更新名" });
      } catch (error) {
        errorThrown = true;
        expect(error instanceof NotFoundError).toBe(true);
      }
      expect(errorThrown).toBe(true);
    });
  });
});
```

## テスト実装における重要なポイント

1. **テスト間の独立性**:
   - 各テストの`beforeEach`でデータベースをリセットし新しいテストデータを挿入
   - テストケース間での副作用を防止

2. **エラーケースのテスト**:
   - 存在しないIDの取得・更新・削除など、エラーケースを適切にテスト
   - 正しいエラー型がスローされることを確認

3. **データベース接続の抽象化**:
   - `createTestDbClient`関数を使用して、テスト用のインメモリDBを作成
   - プロダクション環境のD1とテスト環境のSQLiteを統一的に扱うインターフェース

4. **テスト前の事前確認**:
   - 更新・削除操作の前に、データの存在確認を行い、エラーを早期に検出
   - 例: `updateAuthor`メソッドで対象レコードを先に取得して存在確認

5. **型安全性の確保**:
   - すべてのデータ操作に適切な型定義を使用
   - 型の不一致によるランタイムエラーを防止

6. **サービス層での例外処理**:
   - NotFoundErrorなどの具体的なエラークラスを使用
   - エラースタックの伝播と変換を適切に行う

7. **テストのカバレッジ**:
   - 成功ケースだけでなく失敗ケースもテスト
   - エッジケースを含めた網羅的なテストシナリオを用意

これらのプラクティスにより、堅牢で信頼性の高いテストが可能になります。

## 関連エンティティを含む拡張テスト

最新のプレイリストサービスでは、プレイリスト、ビデオ、著者の関係性をテストする必要があります。

### 関連エンティティをテストするための基本ステップ

1. すべての関連エンティティ（著者、ビデオ、プレイリスト）のテストデータを作成
2. エンティティ間の関連付け（playlist_videosなど）を作成
3. サービスメソッドを呼び出して、関連データが正しく取得できることを検証

### テストコード例

```typescript
test("プレイリストの取得時に関連動画と著者情報も取得できること", async () => {
  // テストデータのセットアップは beforeEach で実行済み

  // プレイリストを取得（動画と著者情報を含む）
  const result = await service.getPlaylistWithVideosById("playlist1");

  // プレイリスト情報の検証
  expect(result.id).toBe("playlist1");
  expect(result.title).toBe("テストプレイリスト");

  // 著者情報の検証
  expect(result.author).toBeDefined();
  expect(result.author.id).toBe("author1");
  expect(result.author.name).toBe("テスト著者1");

  // 関連動画の検証
  expect(result.videos).toBeDefined();
  expect(result.videos.length).toBe(2);

  // 各動画に著者情報が含まれていることを確認
  const video1 = result.videos.find(v => v.id === "video1");
  expect(video1).toBeDefined();
  expect(video1.author).toBeDefined();
  expect(video1.author.id).toBe("author1");
  expect(video1.author.name).toBe("テスト著者1");
});
```

## 著者メタデータテストの重要なポイント

著者メタデータとビデオ情報を含むプレイリストのテストでは、以下の点に注意します：

1. **完全なデータセット**: テスト前に著者、ビデオ、プレイリスト、関連付けのすべてのデータを用意
2. **エンティティ間の一貫性**: authorIdとauthorオブジェクトの整合性を確認
3. **メタデータの検証**: createdAt、updatedAtなどのメタデータも検証
4. **ネスト関係の検証**: プレイリスト > ビデオ > 著者という階層関係を検証

## テストで検証すべき項目

1. **正しい型**: 各プロパティが期待される型であることを確認
2. **データの正確性**: IDや名前などのデータが正しいことを確認
3. **関連の完全性**: すべての関連エンティティが取得されていることを確認
4. **エラーケース**: 存在しないIDを指定した場合など、エラーケースも検証

## リポジトリテストでの著者情報検証

APIリポジトリのテストでも、著者情報を含むレスポンスを正しく処理できることを検証します：

```typescript
test("動画情報と著者情報を取得できること", async () => {
  const result = await getVideoById("video1");

  expect(result.isOk()).toBe(true);

  if (result.isOk()) {
    const video = result.value;

    // 基本情報の検証
    expect(video.id).toBe("video1");
    expect(video.title).toBe("テスト動画");

    // 著者情報の検証
    expect(video.author).toBeDefined();
    expect(video.author.id).toBe("author1");
    expect(video.author.name).toBe("テスト著者");
    expect(video.author.iconUrl).toBeDefined();
  }
});
```

## プレイリストリポジトリテスト

プレイリストリポジトリでは、関連動画と著者情報を含むプレイリストの取得を検証する必要があります。これにより、API経由での結合データ取得が正しく機能することを確認できます：

```typescript
describe("プレイリストリポジトリのテスト", () => {
  // 各テストの前に実行するセットアップ
  beforeEach(async () => {
    // テスト環境をセットアップ
    const env = await setupTestEnv();
    dbClient = env.dbClient;

    // テストデータを挿入
    await insertTestAuthors(dbClient);
    await insertTestVideos(dbClient);
    await insertTestPlaylists(dbClient);
    await insertTestPlaylistVideos(dbClient);
  });

  // 各テストの後に実行するクリーンアップ
  afterEach(async () => {
    await cleanupTestData(dbClient);
  });

  describe("getPlaylistById", () => {
    it("プレイリストに関連する動画と動画の作者情報が正しく取得できること", async () => {
      // リポジトリ関数を呼び出し
      const result = await getPlaylistById("playlist1");

      // 結果が成功していることを確認
      expect(result.isOk()).toBe(true);

      if (result.isOk()) {
        const playlist = result.value;

        // プレイリスト情報を確認
        expect(playlist.id).toBe("playlist1");
        expect(playlist.title).toBe("テストプレイリスト1");

        // 動画情報があることを確認
        expect(playlist.videos).toBeDefined();
        expect(Array.isArray(playlist.videos)).toBe(true);
        expect(playlist.videos?.length).toBeGreaterThan(0);

        if (playlist.videos) {
          // 関連する動画の情報を確認
          const video1 = playlist.videos.find((v) => v.id === "video1");
          expect(video1).toBeDefined();

          if (video1) {
            expect(video1.title).toBe("テストビデオ1");
            expect(video1.url).toBe("https://example.com/video1");

            // 動画の作者情報を確認
            expect(video1.author).toBeDefined();
            if (video1.author) {
              expect(video1.author.id).toBe("author1");
              expect(video1.author.name).toBe("テスト著者1");
              expect(video1.author.iconUrl).toBe("https://example.com/icon1.jpg");
            }
          }

          // 複数の動画がある場合は2つ目の動画も確認
          const video2 = playlist.videos.find((v) => v.id === "video2");
          expect(video2).toBeDefined();
          if (video2 && video2.author) {
            expect(video2.author.id).toBe("author2");
            expect(video2.author.name).toBe("テスト著者2");
          }
        }
      }
    });
  });
});
```

## 複数エンティティのテストデータセットアップ

複雑な関連を持つエンティティのテストには、テストデータをモジュール化して再利用可能にすることが重要です：

```typescript
// テストヘルパー関数の例
export async function setupTestEnv() {
  // テスト用のDBクライアントを作成
  const dbClient = await createTestDbClient();

  // テスト用Honoアプリを作成
  const app = createHonoApp({
    dbClient,
  });

  // テスト用クライアントを作成
  const client = testClient(app);

  // 全てのテストデータをクリア
  await dbClient.delete(playlistVideos).run();
  await dbClient.delete(playlists).run();
  await dbClient.delete(videos).run();
  await dbClient.delete(authors).run();

  // APIクライアントを設定
  setApiClient(client);

  return { dbClient, app, client };
}

export async function insertAllTestData(dbClient: DbClient) {
  const authors = await insertTestAuthors(dbClient);
  const videos = await insertTestVideos(dbClient);
  const playlists = await insertTestPlaylists(dbClient);
  const relations = await insertTestPlaylistVideos(dbClient);

  return { authors, videos, playlists, relations };
}
```

## 検証エラーハンドリングのテスト強化

スキーマ検証エラーのログ出力とエラー処理の強化も重要です：

```typescript
// リポジトリ関数でのエラーハンドリング
if (!result.success) {
  console.error("Schema validation error:", result.error.message);
  return err(createSchemaError(result.error.message));
}

// エラーテストの実装
it("存在しないプレイリストIDではエラーになること", async () => {
  // 存在しないIDでリポジトリ関数を呼び出し
  const result = await getPlaylistById("non-existent-id");

  // 結果がエラーであることを確認
  expect(result.isErr()).toBe(true);

  if (result.isErr()) {
    const error = result.error;

    // 適切なエラータイプであることを確認
    expect(error.type).toBe("notFound");
  }
});
```

## テストのベストプラクティス

1. **各テストの独立性を確保**: 各テストは他のテストに依存せず、独立して実行できるようにする
2. **現実的なデータを使用**: 実際の使用シナリオに近いテストデータを使用する
3. **エラーケースをカバー**: 境界条件やエラーケースも適切にテストする
4. **テストの可読性**: テスト目的が明確に理解できるようにする

この規約に従うことで、サービス層の品質と信頼性を確保し、安全なリファクタリングや機能追加が可能になります。

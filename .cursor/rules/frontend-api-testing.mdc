---
description: Kirinuki-Playlistプロジェクトのサービス層テスト規約
globs: src/db/services/__tests__/**/*.ts
---
# サービス層テスト規約

## テスト基本方針

- **アダプタパターン**: DBクライアントの依存性注入によるテスト容易性の向上
- **インメモリデータベース**: Bunの組み込みSQLiteを使用した高速テスト環境
- **テストの独立性**: 各テストケースは互いに影響を与えないよう設計
- **明確なエラーハンドリング**: 具体的なエラー型を定義して例外処理を統一
- **型安全**: TypeScriptの型システムを活用した堅牢なインターフェース設計

## テストディレクトリ構造

```
src/
├── db/
│   ├── config/
│   │   └── database.ts                 # DBクライアント設定
│   ├── models/
│   │   ├── authors.ts                  # 著者モデル定義
│   │   ├── videos.ts                   # 動画モデル定義
│   │   └── playlists.ts                # プレイリストモデル定義
│   ├── services/                       # サービス層の実装
│   │   ├── __tests__/                  # サービス層のテスト
│   │   │   └── authors.test.ts         # 著者サービスのテスト
│   │   ├── authors.ts                  # 著者サービスの実装
│   │   ├── videos.ts                   # 動画サービスの実装
│   │   └── playlists.ts                # プレイリストサービスの実装
│   └── utils/
│       └── errors.ts                   # エラー定義
```

## Bun SQLiteを使用したテスト環境のセットアップ

Bunの組み込みSQLite機能を使用してインメモリデータベースのテスト環境を構築します：

```typescript
// src/db/config/database.ts
import { Database } from "bun:sqlite";
import { drizzle as drizzleSqlite } from "drizzle-orm/bun-sqlite";
import type { D1Database } from "@cloudflare/workers-types";
import { drizzle } from "drizzle-orm/d1";

// プロダクション環境用のデータベースクライアントを作成
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};

// テスト環境用のデータベースクライアントを作成
export const createTestDbClient = async () => {
  // インメモリデータベースを作成（":memory:"を指定）
  const sqlite = new Database(":memory:");

  // テーブルスキーマを作成
  sqlite.exec(`
    CREATE TABLE IF NOT EXISTS authors (
      id TEXT PRIMARY KEY,
      name TEXT NOT NULL,
      icon_url TEXT NOT NULL,
      bio TEXT,
      created_at INTEGER NOT NULL,
      updated_at INTEGER NOT NULL
    )
  `);
  // 他のテーブル作成

  // Drizzle ORMのクライアントを作成
  const db = drizzleSqlite(sqlite);

  return db;
};
```

## サービス層の設計とテスト

サービス層は次のポイントを考慮して設計します：

1. **依存性注入**: DBクライアントをパラメータとして受け取る
2. **明確なエラーハンドリング**: 具体的なエラー型を定義して使用
3. **テストの独立性**: 各テストは独自のデータセットで実行

```typescript
// src/db/services/authors.ts
import type { D1Database } from "@cloudflare/workers-types";
import { eq } from "drizzle-orm";
import { nanoid } from "nanoid";
import { createDbClient, type createTestDbClient } from "../config/database";
import { authors } from "../models/authors";
import { DatabaseError, NotFoundError, UniqueConstraintError } from "../utils/errors";

export type Author = InferSelectModel<typeof authors>;
export type AuthorInsert = Omit<InferInsertModel<typeof authors>, "id" | "createdAt" | "updatedAt">;
export type AuthorUpdate = Partial<Omit<InferInsertModel<typeof authors>, "id" | "createdAt" | "updatedAt">>;

// データベースクライアントの型定義（プロダクションとテスト両方に対応）
export type DbClient =
  | ReturnType<typeof createDbClient>
  | Awaited<ReturnType<typeof createTestDbClient>>;

// 依存性注入パターンを使った著者サービスの作成関数
export const createAuthorService = (dbClient: DbClient) => ({
  // 全著者取得
  async getAllAuthors(): Promise<Author[]> {
    try {
      return await dbClient.select().from(authors).all();
    } catch (_) {
      throw new DatabaseError("著者一覧の取得に失敗しました");
    }
  },

  // IDによる著者取得
  async getAuthorById(id: string): Promise<Author> {
    try {
      const author = await dbClient
        .select()
        .from(authors)
        .where(eq(authors.id, id))
        .get();

      if (!author) {
        throw new NotFoundError(`ID: ${id} の著者が見つかりません`);
      }

      return author;
    } catch (error) {
      if (error instanceof NotFoundError) {
        throw error;
      }
      throw new DatabaseError(
        `著者の取得中にエラーが発生しました: ${
          error instanceof Error ? error.message : "不明なエラー"
        }`
      );
    }
  },

  // その他のCRUD操作
});

// デフォルトのauthorServiceインスタンス（API層で使用）
export const authorService = {
  getAllAuthors: (db: D1Database) => {
    const client = createDbClient(db);
    return createAuthorService(client).getAllAuthors();
  },
  // 他のメソッド
};
```

## サービス層のテスト実装

```typescript
// src/db/services/__tests__/authors.test.ts
import { beforeEach, describe, expect, test } from "bun:test";
import { eq } from "drizzle-orm";
import { createTestDbClient } from "../../config/database";
import { authors } from "../../models/authors";
import { NotFoundError } from "../../utils/errors";
import { type Author, createAuthorService } from "../authors";

// テストデータ
const testAuthors: Omit<Author, "createdAt" | "updatedAt">[] = [
  {
    id: "author1",
    name: "テスト著者1",
    iconUrl: "https://example.com/icon1.png",
    bio: "テスト著者1の自己紹介",
  },
  {
    id: "author2",
    name: "テスト著者2",
    iconUrl: "https://example.com/icon2.png",
    bio: "テスト著者2の自己紹介",
  },
];

// ヘルパー関数: データベースとサービスの初期化
async function setupDatabase() {
  const dbClient = await createTestDbClient();
  const service = createAuthorService(dbClient);

  // テーブルをクリア
  await dbClient.delete(authors).run();

  // テストデータを挿入
  for (const author of testAuthors) {
    await dbClient.insert(authors).values({
      ...author,
      createdAt: new Date(),
      updatedAt: new Date(),
    });
  }

  return { dbClient, service };
}

describe("authorService", () => {
  describe("getAllAuthors", () => {
    let service: ReturnType<typeof createAuthorService>;

    beforeEach(async () => {
      const result = await setupDatabase();
      service = result.service;
    });

    test("全ての著者を取得できること", async () => {
      const result = await service.getAllAuthors();
      expect(result.length).toBe(2);

      // データを検証
      const sorted = result.sort((a, b) => a.id.localeCompare(b.id));
      expect(sorted[0].id).toBe("author1");
      expect(sorted[0].name).toBe("テスト著者1");
    });
  });

  // 更新や削除のテストケース
  describe("updateAuthor", () => {
    let dbClient: Awaited<ReturnType<typeof createTestDbClient>>;
    let service: ReturnType<typeof createAuthorService>;

    beforeEach(async () => {
      ({ dbClient, service } = await setupDatabase());
    });

    test("著者を更新できること", async () => {
      const updateData = {
        name: "更新著者名",
        bio: "更新された自己紹介",
      };

      await service.updateAuthor("author1", updateData);

      // 更新を検証
      const updatedAuthor = await dbClient
        .select()
        .from(authors)
        .where(eq(authors.id, "author1"))
        .get();

      expect(updatedAuthor?.name).toBe("更新著者名");
      expect(updatedAuthor?.bio).toBe("更新された自己紹介");
      // 更新していないフィールドは変更されないことを確認
      expect(updatedAuthor?.iconUrl).toBe("https://example.com/icon1.png");
    });

    test("存在しないIDの更新はNotFoundErrorをスローすること", async () => {
      let errorThrown = false;
      try {
        await service.updateAuthor("non-existent", { name: "更新名" });
      } catch (error) {
        errorThrown = true;
        expect(error instanceof NotFoundError).toBe(true);
      }
      expect(errorThrown).toBe(true);
    });
  });
});
```

## テスト実装における重要なポイント

1. **テスト間の独立性**:
   - 各テストの`beforeEach`でデータベースをリセットし新しいテストデータを挿入
   - テストケース間での副作用を防止

2. **エラーケースのテスト**:
   - 存在しないIDの取得・更新・削除など、エラーケースを適切にテスト
   - 正しいエラー型がスローされることを確認

3. **データベース接続の抽象化**:
   - `createTestDbClient`関数を使用して、テスト用のインメモリDBを作成
   - プロダクション環境のD1とテスト環境のSQLiteを統一的に扱うインターフェース

4. **テスト前の事前確認**:
   - 更新・削除操作の前に、データの存在確認を行い、エラーを早期に検出
   - 例: `updateAuthor`メソッドで対象レコードを先に取得して存在確認

5. **型安全性の確保**:
   - すべてのデータ操作に適切な型定義を使用
   - 型の不一致によるランタイムエラーを防止

6. **サービス層での例外処理**:
   - NotFoundErrorなどの具体的なエラークラスを使用
   - エラースタックの伝播と変換を適切に行う

7. **テストのカバレッジ**:
   - 成功ケースだけでなく失敗ケースもテスト
   - エッジケースを含めた網羅的なテストシナリオを用意

これらのプラクティスにより、堅牢で信頼性の高いテストが可能になります。

## 関連エンティティを含む拡張テスト

最新のプレイリストサービスでは、プレイリスト、ビデオ、著者の関係性をテストする必要があります。

### 関連エンティティをテストするための基本ステップ

1. すべての関連エンティティ（著者、ビデオ、プレイリスト）のテストデータを作成
2. エンティティ間の関連付け（playlist_videosなど）を作成
3. サービスメソッドを呼び出して、関連データが正しく取得できることを検証

### テストコード例

```typescript
test("プレイリストの取得時に関連動画と著者情報も取得できること", async () => {
  // テストデータのセットアップは beforeEach で実行済み

  // プレイリストを取得（動画と著者情報を含む）
  const result = await service.getPlaylistWithVideosById("playlist1");

  // プレイリスト情報の検証
  expect(result.id).toBe("playlist1");
  expect(result.title).toBe("テストプレイリスト");

  // 著者情報の検証
  expect(result.author).toBeDefined();
  expect(result.author.id).toBe("author1");
  expect(result.author.name).toBe("テスト著者1");

  // 関連動画の検証
  expect(result.videos).toBeDefined();
  expect(result.videos.length).toBe(2);

  // 各動画に著者情報が含まれていることを確認
  const video1 = result.videos.find(v => v.id === "video1");
  expect(video1).toBeDefined();
  expect(video1.author).toBeDefined();
  expect(video1.author.id).toBe("author1");
  expect(video1.author.name).toBe("テスト著者1");
});
```

## 著者メタデータテストの重要なポイント

著者メタデータとビデオ情報を含むプレイリストのテストでは、以下の点に注意します：

1. **完全なデータセット**: テスト前に著者、ビデオ、プレイリスト、関連付けのすべてのデータを用意
2. **エンティティ間の一貫性**: authorIdとauthorオブジェクトの整合性を確認
3. **メタデータの検証**: createdAt、updatedAtなどのメタデータも検証
4. **ネスト関係の検証**: プレイリスト > ビデオ > 著者という階層関係を検証

## テストで検証すべき項目

1. **正しい型**: 各プロパティが期待される型であることを確認
2. **データの正確性**: IDや名前などのデータが正しいことを確認
3. **関連の完全性**: すべての関連エンティティが取得されていることを確認
4. **エラーケース**: 存在しないIDを指定した場合など、エラーケースも検証

## リポジトリテストでの著者情報検証

APIリポジトリのテストでも、著者情報を含むレスポンスを正しく処理できることを検証します：

```typescript
test("動画情報と著者情報を取得できること", async () => {
  const result = await getVideoById("video1");

  expect(result.isOk()).toBe(true);

  if (result.isOk()) {
    const video = result.value;

    // 基本情報の検証
    expect(video.id).toBe("video1");
    expect(video.title).toBe("テスト動画");

    // 著者情報の検証
    expect(video.author).toBeDefined();
    expect(video.author.id).toBe("author1");
    expect(video.author.name).toBe("テスト著者");
    expect(video.author.iconUrl).toBeDefined();
  }
});
```

## テストのベストプラクティス

1. **各テストの独立性を確保**: 各テストは他のテストに依存せず、独立して実行できるようにする
2. **現実的なデータを使用**: 実際の使用シナリオに近いテストデータを使用する
3. **エラーケースをカバー**: 境界条件やエラーケースも適切にテストする
4. **テストの可読性**: テスト目的が明確に理解できるようにする

この規約に従うことで、サービス層の品質と信頼性を確保し、安全なリファクタリングや機能追加が可能になります。

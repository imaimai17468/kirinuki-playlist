---
description: Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約
globs: src/app/api/**/*.ts, src/db/utils/errors.ts, src/repositories/**/*.ts
---
# Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約

## 概要

Kirinuki-Playlistプロジェクトでは、APIエラーハンドリングを統一的に行うための規約を定めています。
以下のパターンに従うことで、クライアント側で適切なエラーメッセージを表示し、
エラーの原因を特定しやすくなります。

## カスタムエラークラス

エラーの種類によって適切に分類するために、カスタムエラークラスを定義します：

```typescript
// src/db/utils/errors.ts
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class AuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthenticationError";
  }
}

export class AuthorizationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthorizationError";
  }
}
```

## エラーハンドリングミドルウェア

Honoミドルウェアを使用して、一元的にエラーをハンドリングします：

```typescript
// src/db/middlewares/error-handler.ts
import type { MiddlewareHandler } from "hono";
import {
  NotFoundError,
  DatabaseError,
  ValidationError,
  AuthenticationError,
  AuthorizationError
} from "@/db/utils/errors";

export const errorHandler: MiddlewareHandler = async (c, next) => {
  try {
    await next();
  } catch (error) {
    console.error("API Error:", error);

    // エラーの種類によって適切なステータスコードとレスポンスを返す
    if (error instanceof NotFoundError) {
      return c.json({ success: false, message: error.message }, 404);
    }

    if (error instanceof ValidationError) {
      return c.json({ success: false, message: error.message }, 400);
    }

    if (error instanceof AuthenticationError) {
      return c.json({ success: false, message: error.message }, 401);
    }

    if (error instanceof AuthorizationError) {
      return c.json({ success: false, message: error.message }, 403);
    }

    if (error instanceof DatabaseError) {
      return c.json({ success: false, message: error.message }, 500);
    }

    // その他のエラー
    return c.json({
      success: false,
      message: "予期しないエラーが発生しました",
    }, 500);
  }
};
```

## サービスレイヤーでのエラーハンドリング

サービスレイヤーでは、適切なカスタムエラーをスローします：

```typescript
// サービスレイヤーのエラーハンドリング例（videos.ts）
async getVideoById(id: string) {
  try {
    const video = await this.dbClient
      .select()
      .from(videos)
      .where(eq(videos.id, id))
      .get();

    if (!video) {
      throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
    }

    return video;
  } catch (error) {
    if (error instanceof NotFoundError) {
      throw error; // NotFoundErrorはそのまま上位に伝播
    }
    throw new DatabaseError(
      `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
    );
  }
}
```

## APIレイヤーでのエラーハンドリング

APIレイヤーでは、サービスからスローされたエラーを適切に処理します：

```typescript
// APIレイヤーでのエラーハンドリング（playlists.ts）
.get("/:id", async (c) => {
  const id = c.req.param("id");

  try {
    const service = createPlaylistService(c.get("dbClient"));
    const playlist = await service.getPlaylistById(id);
    return c.json({ success: true, playlist });
  } catch (error) {
    // エラーミドルウェアに処理を委譲
    throw error;
  }
})
```

## リポジトリパターンでのエラーハンドリング

クライアントサイドのリポジトリパターンでは、Result型を使用してエラーを扱います：

```typescript
// src/repositories/types.ts
import { z } from "zod";

// API エラータイプ
export type ApiError = {
  type: "network" | "http" | "schema" | "unknown";
  status?: number;
  message: string;
  details?: unknown;
};

// レスポンススキーマ
export const baseResponseSchema = z.object({
  success: z.boolean(),
  message: z.string().optional(),
});

// 動画レスポンススキーマ
export const videoSchema = z.object({
  id: z.string(),
  title: z.string(),
  url: z.string(),
  authorId: z.string(),
  author: z.object({
    id: z.string(),
    name: z.string(),
  }).optional(),
  start: z.number().nullable().optional(),
  end: z.number().nullable().optional(),
  createdAt: z.string().optional(),
  updatedAt: z.string().optional(),
});

export const videoResponseSchema = baseResponseSchema.extend({
  video: videoSchema,
});

export const videosResponseSchema = baseResponseSchema.extend({
  videos: z.array(videoSchema),
});
```

```typescript
// src/repositories/utils.ts
import type { ApiError } from "./types";
import { baseResponseSchema } from "./types";
import { err } from "neverthrow";
import type { Result } from "neverthrow";
import { z } from "zod";

// ネットワークエラーを作成
export function createNetworkError(error: unknown): ApiError {
  return {
    type: "network",
    message: error instanceof Error ? error.message : "ネットワークエラーが発生しました",
    details: error,
  };
}

// スキーマエラーを作成
export function createSchemaError(message: string): ApiError {
  return {
    type: "schema",
    message: `レスポンスの形式が正しくありません: ${message}`,
  };
}

// HTTPエラーを作成
export function createHttpError(status: number, message: string): ApiError {
  return {
    type: "http",
    status,
    message,
  };
}

// HTTPエラーを処理
export async function handleHttpError(
  response: Response
): Promise<Result<never, ApiError>> {
  try {
    const data = await response.json();
    const result = baseResponseSchema.safeParse(data);
    const message = result.success ? data.message : "エラーが発生しました";

    return err(createHttpError(response.status, message));
  } catch (_) {
    return err(createHttpError(response.status, "サーバーからのレスポンスの解析に失敗しました"));
  }
}
```

## クライアントサイドでのエラー処理

リポジトリからのResultオブジェクトを使用して、フロントエンドでエラーを処理します：

```typescript
// クライアントコンポーネントでのエラー処理の例
import { getAllVideos } from "@/repositories/video";
import { useState, useEffect } from "react";

export function VideoList() {
  const [videos, setVideos] = useState([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState(null);

  useEffect(() => {
    async function loadVideos() {
      const result = await getAllVideos();

      result.match(
        // 成功した場合
        (data) => {
          setVideos(data);
          setLoading(false);
        },
        // エラーの場合
        (error) => {
          setError(error.message);
          setLoading(false);

          // エラータイプに応じた処理
          switch (error.type) {
            case "network":
              console.error("ネットワークエラー:", error);
              break;
            case "http":
              if (error.status === 404) {
                console.error("リソースが見つかりません:", error);
              } else if (error.status >= 500) {
                console.error("サーバーエラー:", error);
              }
              break;
            case "schema":
              console.error("スキーマエラー:", error);
              break;
            default:
              console.error("不明なエラー:", error);
          }
        }
      );
    }

    loadVideos();
  }, []);

  if (loading) return <div>読み込み中...</div>;
  if (error) return <div>エラー: {error}</div>;

  return (
    <div>
      <h1>動画一覧</h1>
      <ul>
        {videos.map((video) => (
          <li key={video.id}>{video.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## React Queryとの統合

React Queryを使用する場合は、以下のようにエラーハンドリングを統合できます：

```typescript
// src/hooks/useVideos.ts
import { getAllVideos } from "@/repositories/video";
import { useQuery } from "@tanstack/react-query";

export function useVideos() {
  return useQuery({
    queryKey: ["videos"],
    queryFn: async () => {
      const result = await getAllVideos();
      return result.match(
        (data) => data,
        (error) => {
          throw error; // React Queryのエラーハンドリングに委譲
        }
      );
    },
  });
}

// コンポーネントでの使用例
function VideoListWithReactQuery() {
  const { data: videos, error, isLoading } = useVideos();

  if (isLoading) return <div>読み込み中...</div>;

  if (error) {
    // エラータイプに応じたUIを表示
    const apiError = error as ApiError;
    if (apiError.type === "http" && apiError.status === 404) {
      return <div>動画が見つかりませんでした</div>;
    }
    return <div>エラー: {apiError.message}</div>;
  }

  return (
    <div>
      <h1>動画一覧</h1>
      <ul>
        {videos.map((video) => (
          <li key={video.id}>{video.title}</li>
        ))}
      </ul>
    </div>
  );
}
```

## エラーレスポンスの形式

APIからのエラーレスポンスは以下の形式に統一します：

```json
{
  "success": false,
  "message": "エラーメッセージ"
}
```

成功時のレスポンスは以下の形式に統一します：

```json
{
  "success": true,
  "データのキー": データの値
}
```

例えば、動画のリストを返す場合：

```json
{
  "success": true,
  "videos": [
    { "id": "1", "title": "サンプル動画1", ... },
    { "id": "2", "title": "サンプル動画2", ... }
  ]
}
```

## クライアントサイドでのgetApiClient()への移行

以前は直接`client`をインポートしてAPIリクエストを行っていましたが、シングルトンパターンを導入し、`getApiClient()`関数を使用するように変更されました：

```typescript
// 古い実装（非推奨）
import { client } from "@/db/config/client";

export async function getAllVideos() {
  try {
    const response = await client.api.videos.$get();
    // ...処理...
  } catch (error) {
    // ...エラー処理...
  }
}

// 新しい実装（推奨）
import { getApiClient } from "@/db/config/client";

export async function getAllVideos() {
  try {
    const client = getApiClient();
    const response = await client.api.videos.$get();
    // ...処理...
  } catch (error) {
    // ...エラー処理...
  }
}
```

この変更により以下のメリットがあります：

1. **テスト容易性の向上**: テスト時にモッククライアントを注入できる
2. **環境分離**: 環境ごとに異なるクライアント設定を使用可能
3. **一貫性の確保**: アプリケーション全体で同じクライアントインスタンスを使用

## コード例：エラーハンドリングの実装

### 1. APIエンドポイントの実装

```typescript
// src/app/api/[...route]/videos.ts
import { createDbClient } from "@/db/config/database";
import type { AppEnv } from "@/db/config/hono";
import { videoInsertSchema } from "@/db/models/videos";
import { createVideoService } from "@/db/services/videos";
import { getRequestContext } from "@cloudflare/next-on-pages";
import { zValidator } from "@hono/zod-validator";
import { Hono } from "hono";

export const videosRouter = new Hono<AppEnv>()
  .get("/", async (c) => {
    try {
      let dbClient = c.get("dbClient");
      if (!dbClient) {
        const { DB } = getRequestContext().env;
        dbClient = createDbClient(DB);
      }

      const service = createVideoService(dbClient);
      const videos = await service.getAllVideos();
      return c.json({ success: true, videos });
    } catch (error) {
      // エラーハンドリングミドルウェアに処理を委譲
      throw error;
    }
  })
  .get("/:id", async (c) => {
    try {
      const id = c.req.param("id");

      let dbClient = c.get("dbClient");
      if (!dbClient) {
        const { DB } = getRequestContext().env;
        dbClient = createDbClient(DB);
      }

      const service = createVideoService(dbClient);
      const video = await service.getVideoById(id);
      return c.json({ success: true, video });
    } catch (error) {
      // エラーハンドリングミドルウェアに処理を委譲
      throw error;
    }
  });
```

### 2. サービスレイヤーの実装

```typescript
// src/db/services/videos.ts
import type { DbClient } from "@/db/config/hono";
import { videos } from "@/db/models/videos";
import { NotFoundError, DatabaseError } from "@/db/utils/errors";
import { eq } from "drizzle-orm";

export function createVideoService(dbClient: DbClient) {
  return {
    async getAllVideos() {
      try {
        const result = await dbClient.select().from(videos).all();
        return result;
      } catch (error) {
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    async getVideoById(id: string) {
      try {
        const video = await dbClient
          .select()
          .from(videos)
          .where(eq(videos.id, id))
          .get();

        if (!video) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }

        return video;
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    }
  };
}
```

### 3. リポジトリの実装

```typescript
// src/repositories/video/index.ts
import { getApiClient } from "@/db/config/client";
import type { ApiError } from "@/repositories/types";
import { videoResponseSchema, videosResponseSchema } from "@/repositories/types";
import { createNetworkError, createSchemaError, handleHttpError } from "@/repositories/utils";
import { err, ok } from "neverthrow";
import type { Result } from "neverthrow";
import type { z } from "zod";

export async function getAllVideos(): Promise<Result<z.infer<typeof videosResponseSchema>["videos"], ApiError>> {
  try {
    const client = getApiClient();
    const response = await client.api.videos.$get();

    if (!response.ok) {
      return handleHttpError(response);
    }

    const data = await response.json();
    const result = videosResponseSchema.safeParse(data);

    if (!result.success) {
      return err(createSchemaError(result.error.message));
    }

    return ok(result.data.videos);
  } catch (error) {
    return err(createNetworkError(error));
  }
}
```

## まとめ

Kirinuki-PlaylistのAPIエラーハンドリングでは以下のポイントを重視しています：

1. **一貫したエラーレスポンスフォーマット**: すべてのAPIは統一されたフォーマットでエラーを返す
2. **適切なステータスコード**: HTTPステータスコードを適切に使用する
3. **具体的なエラーメッセージ**: エラーの理由を明確に示すメッセージを提供する
4. **型安全性**: TypeScriptとZodを使用してレスポンスの型安全性を確保する
5. **集中管理**: エラーハンドリングミドルウェアで一元的に処理する
6. **効率的なデバッグ**: エラーログの記録と適切なデバッグ情報の提供
7. **Results型**: クライアント側では Result<T, E> パターンで型安全にエラーを処理

これらの規約に従うことで、統一的かつ適切なエラー処理が可能になり、
クライアント側でもユーザーフレンドリーなエラーメッセージを表示できます。

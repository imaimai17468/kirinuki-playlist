---
description: Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約
globs: src/app/api/**/*.ts,src/db/middlewares/**/*.ts
---
# Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約

## 概要

Kirinuki-PlaylistプロジェクトでのAPIエラーハンドリングに関する統一的なアプローチを定義します。
適切なエラー処理はクライアントへの一貫性のあるレスポンスを保証し、デバッグと保守性を向上させます。

## エラー型の定義

サービス層とAPI層で一貫して使用できるカスタムエラークラスを定義します：

```typescript
// src/db/utils/errors.ts
export class NotFoundError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "NotFoundError";
  }
}

export class DatabaseError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "DatabaseError";
  }
}

export class ValidationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "ValidationError";
  }
}

export class AuthenticationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthenticationError";
  }
}

export class AuthorizationError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "AuthorizationError";
  }
}
```

## エラーミドルウェア

Honoのエラーミドルウェアを使用して、API全体で一貫したエラーハンドリングを実現します：

```typescript
// src/db/middlewares/error-handler.ts
import { MiddlewareHandler } from "hono";
import { HTTPException } from "hono/http-exception";
import { ZodError } from "zod";
import {
  NotFoundError,
  DatabaseError,
  ValidationError,
  AuthenticationError,
  AuthorizationError
} from "@/db/utils/errors";

export const errorHandler: MiddlewareHandler = async (c, next) => {
  try {
    await next();
  } catch (error) {
    console.error("API Error:", error);

    // Honoの組み込みHTTP例外
    if (error instanceof HTTPException) {
      return c.json(
        {
          success: false,
          message: error.message,
        },
        error.status
      );
    }

    // カスタムエラー型の処理
    if (error instanceof NotFoundError) {
      return c.json(
        {
          success: false,
          message: error.message,
        },
        404
      );
    }

    if (error instanceof ValidationError) {
      return c.json(
        {
          success: false,
          message: error.message,
        },
        400
      );
    }

    if (error instanceof AuthenticationError) {
      return c.json(
        {
          success: false,
          message: error.message,
        },
        401
      );
    }

    if (error instanceof AuthorizationError) {
      return c.json(
        {
          success: false,
          message: error.message,
        },
        403
      );
    }

    // Zodバリデーションエラー
    if (error instanceof ZodError) {
      return c.json(
        {
          success: false,
          message: "入力データが無効です",
          details: error.errors,
        },
        400
      );
    }

    // データベースエラー
    if (error instanceof DatabaseError) {
      return c.json(
        {
          success: false,
          message: "データベース操作中にエラーが発生しました",
        },
        500
      );
    }

    // その他の予期しないエラー
    return c.json(
      {
        success: false,
        message: "予期しないエラーが発生しました",
      },
      500
    );
  }
};
```

## サービス層でのエラーハンドリング

サービス層では、適切なカスタムエラーをスローしてください。依存性注入パターンを採用したサービスでは、エラーハンドリングを一貫して実装します：

```typescript
// サービス関数内でのエラーハンドリング例
export function createVideoService(dbClient: DbClient) {
  return {
    async getVideoById(id: string) {
      try {
        const video = await dbClient
          .select()
          .from(videos)
          .where(eq(videos.id, id))
          .get();

        if (!video) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }

        return video;
      } catch (error) {
        // NotFoundErrorは再スロー
        if (error instanceof NotFoundError) {
          throw error;
        }
        // その他のエラーはDatabaseErrorにラップ
        throw new DatabaseError(
          `動画の取得中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    },

    async updateVideo(id: string, data: VideoUpdate) {
      try {
        // ...実装...
        const result = await dbClient
          .update(videos)
          .set({ ...data, updatedAt: new Date() })
          .where(eq(videos.id, id))
          .run();

        if (result.meta?.changes === 0) {
          throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
        }
      } catch (error) {
        if (error instanceof NotFoundError) {
          throw error;
        }
        throw new DatabaseError(
          `動画の更新中にエラーが発生しました: ${error instanceof Error ? error.message : "不明なエラー"}`
        );
      }
    }
  };
}
```

## API層でのエラーハンドリング

API層でのエラーハンドリングにはエラーミドルウェアを活用し、必要に応じて追加のエラーハンドリングを実装します：

```typescript
// APIルーターでのエラーハンドリング
.get("/:id", async (c) => {
  const id = c.req.param("id");

  // DbClientをコンテキストから取得、なければ新規作成
  let dbClient = c.get("dbClient");
  if (!dbClient) {
    const { DB } = getRequestContext().env;
    dbClient = createDbClient(DB);
  }

  try {
    const service = createPlaylistService(dbClient);
    const playlist = await service.getPlaylistWithVideosById(id);
    return c.json({ success: true, playlist });
  } catch (error) {
    // エラーミドルウェアですべてのエラーをハンドリングできるため、
    // ここではエラーを再スローするだけでも可能
    throw error;

    // あるいは、より詳細なエラーハンドリングを行う場合：
    if (error instanceof NotFoundError) {
      return c.json({ success: false, message: error.message }, 404);
    }
    console.error("プレイリスト取得中にエラーが発生しました:", error);
    return c.json({ success: false, message: "プレイリストの取得に失敗しました" }, 500);
  }
})
```

## エラーレスポンスの形式

すべてのAPIエラーレスポンスは一貫した形式に従う必要があります：

```json
{
  "success": false,
  "message": "エラーの説明メッセージ",
  "details": [
    // オプションで詳細情報（特にバリデーションエラーの場合）
  ]
}
```

これにより、フロントエンドでのエラー処理が簡素化され、一貫性が保たれます。

## エラーのログ記録

重要なエラーはコンソールにログ記録する必要があります。環境に応じて詳細レベルを調整してください：

```typescript
// 開発環境では詳細なエラー情報を記録
console.error("API Error:", error);

// 本番環境ではスタックトレースを含まない簡潔なログを記録
console.error(`API Error: ${error.name} - ${error.message}`);
```

## バリデーションエラー

リクエストデータのバリデーションにはZodを使用し、バリデーションエラーを適切に処理します：

```typescript
import { zValidator } from "@hono/zod-validator";
import { videoInsertSchema } from "@/db/models/videos";

// リクエストデータのバリデーション
.post("/", zValidator("json", videoInsertSchema), async (c) => {
  const input = c.req.valid("json");
  // バリデーションが成功した場合のみここが実行される
  // ...実装...
})
```

## エラー処理のベストプラクティス

1. **早期リターン**: エラー条件に一致した場合、できるだけ早くリターンする
2. **適切なエラー型**: エラーの種類に応じて適切なカスタムエラークラスを使用する
3. **一貫性**: プロジェクト全体で一貫したエラーハンドリングパターンを使用する
4. **エラーメッセージ**: エンドユーザー向けの分かりやすいエラーメッセージを提供する
5. **デバッグ情報の保護**: 本番環境では詳細なデバッグ情報を漏らさない

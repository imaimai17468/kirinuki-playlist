---
description: Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約
globs: src/app/api/**/*.ts, src/db/utils/errors.ts, src/repositories/**/*.ts
---
# Kirinuki-PlaylistプロジェクトのHono APIエラーハンドリング規約

## 概要

Kirinuki-Playlistプロジェクトでは、APIエラーハンドリングを統一的に行うための規約を定めています。
以下のパターンに従うことで、クライアント側で適切なエラーメッセージを表示し、
エラーの原因を特定しやすくなります。

## カスタムエラークラス

エラーの種類によって適切に分類するために、以下のカスタムエラークラスを定義します：

- **NotFoundError**: リソースが見つからない場合
- **DatabaseError**: データベース操作中のエラー
- **ValidationError**: 入力値の検証エラー
- **AuthenticationError**: 認証エラー
- **AuthorizationError**: 認可エラー
- **UniqueConstraintError**: 一意制約違反
- **RelationError**: エンティティ間の関連性に関するエラー

各エラークラスはエラーメッセージを受け取り、適切な名前プロパティを設定します。

## エラーハンドリングミドルウェア

Honoミドルウェアを使用して、一元的にエラーをハンドリングします。このミドルウェアは：

1. すべてのリクエストで発生するエラーをキャッチ
2. エラーの種類に応じて適切なステータスコードとレスポンスを返す
3. エラーログを記録

各エラータイプに対応するHTTPステータスコードは以下の通りです：
- NotFoundError: 404
- ValidationError: 400
- AuthenticationError: 401
- AuthorizationError: 403
- UniqueConstraintError: 409
- RelationError: 400
- DatabaseError: 500
- その他のエラー: 500

## 責任分離とエラーハンドリングの効率化

### APIルーターとサービスレイヤー間の責任分離

エラーハンドリングにおいても、APIルーターとサービスレイヤーの間で責任を適切に分離します：

1. **サービスレイヤー**: リソースの存在チェックとビジネスロジックの検証を行い、適切なエラーをスローする
2. **APIルーター**: サービスからスローされたエラーをキャッチし、適切なHTTPレスポンスとしてクライアントに返す

この責任分離により、コードの重複を避け、エラーハンドリングの一貫性を確保します。

### 二重チェックの防止

APIルーターとサービスレイヤーの両方で同じ検証を行うと、パフォーマンスが低下し、コードが複雑になります。
そのため、サービスレイヤーに存在チェックを委譲し、APIルーターではエラーのキャッチと変換のみを行います。

### 複合リソース操作のエラーハンドリング

複数のリソースが関連する操作では、サービスレイヤー内部でエラーを適切に識別し、具体的な情報を含むエラーをスローします。
例えば、プレイリストに動画を追加する際には、プレイリストと動画の両方の存在を確認し、適切なエラーメッセージを提供します。

### APIレスポンスの一貫性

エラーメッセージには、問題の原因と可能な解決策に関する情報を含めるようにします：

1. **具体的なリソース識別子**: エラーに関連するリソースのIDを含める
2. **明確なエラー理由**: 何が問題だったのかを具体的に説明
3. **一貫した形式**: すべてのAPIエンドポイントで同じエラーレスポンス形式を使用

## サービスレイヤーでのエラーハンドリング

サービスレイヤーでは、操作中に発生する可能性のあるエラーを適切に捕捉し、カスタムエラーとして再スローします。
既知のエラータイプ（NotFoundErrorなど）はそのまま上位に伝播し、その他のエラーはDatabaseErrorに変換します。

## 関連エンティティのエラーハンドリング

プレイリスト、ビデオ、著者などの関連エンティティを扱う場合は、各エンティティの存在を確認し、
関連性や整合性を検証します。特に、複数テーブルにまたがる操作では、より詳細なエラーメッセージを提供します。

## APIレイヤーでのエラーハンドリング

APIレイヤーでは、サービスからスローされたエラーをキャッチし、一貫したレスポンス形式で返します。
原則として、エラーミドルウェアに処理を委譲し、必要に応じて追加の処理（ログ記録など）を行います。

## リポジトリパターンでのエラーハンドリング

クライアントサイドのリポジトリパターンでは、Result型を使用してエラーを扱います：

### エラー型の定義

APIエラーは以下のタイプを区別します：
- network: ネットワーク接続エラー
- http: HTTPステータスコードに関連するエラー
- schema: レスポンス検証エラー
- relation: エンティティ間の関連性に関するエラー
- notFound: リソースが見つからないエラー
- unknown: 未分類のエラー

### クライアントサイドでのエラーハンドリング

React コンポーネントでは、エラータイプに基づいて適切なUIを表示します。
各エラータイプに対して、ユーザーに理解しやすいメッセージと適切なアクションを提示します。

## エラーハンドリングのベストプラクティス

1. **適切なエラータイプの使用**: 状況に応じて最も適切なエラータイプをスローする
2. **詳細なエラーメッセージ**: ユーザーが理解しやすく、開発者がデバッグしやすいメッセージを提供
3. **一貫性のあるエラー形式**: すべてのAPIエンドポイントで一貫したエラーレスポンス形式を使用
4. **関連エンティティの検証**: 複雑な関連を持つデータでは、各エンティティの存在と整合性を検証
5. **段階的なエラーハンドリング**: サービス層、API層、クライアント層でそれぞれ適切にエラーを処理

## エラーログの記録

エラーが発生した場合は、適切なログを記録して後でデバッグできるようにします：
- エラーの詳細（メッセージ、タイプ、スタックトレースなど）
- 関連するコンテキスト（リソースID、操作タイプなど）
- タイムスタンプ

## エラーハンドリングのテストカバレッジ

テストでは、以下のエラーシナリオをカバーすることが重要です：

1. **存在しないリソース**: 指定されたIDのリソースが存在しない場合
2. **関連エンティティの欠落**: 必要な関連エンティティが欠落している場合
3. **スキーマ検証の失敗**: レスポンスデータがスキーマに適合しない場合
4. **ネットワークエラー**: API通信中に発生するネットワーク関連のエラー
5. **認証/認可エラー**: ユーザーの権限不足や認証失敗によるエラー
6. **一意制約違反**: 一意であるべきデータが重複する場合
7. **入力検証エラー**: ユーザー入力が検証に失敗する場合

このエラーハンドリング規約に従うことで、堅牢でユーザーフレンドリーなAPI実装が可能になります。

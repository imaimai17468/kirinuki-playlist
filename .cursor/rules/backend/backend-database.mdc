---
description: Cloudflare D1データベースとマイグレーションの管理ガイド
globs: ["**/backend/**/*.ts"]
---

backend-database: Cloudflare D1データベースとマイグレーションの管理ガイド

# Kirinuki-Playlist バックエンドデータベース管理ガイド

## Cloudflare D1 データベース管理

Kirinuki-Playlistプロジェクトでは、Cloudflare D1をデータベースとして使用しています。以下のガイドラインに従ってデータベースの管理を行ってください。

### マイグレーションワークフロー

Cloudflare D1とDrizzle ORMを使用したマイグレーションの正しいワークフローは以下の通りです：

1. **スキーマ定義**：`src/models`ディレクトリ内のテーブル定義を編集します

2. **マイグレーションファイル生成**：
   ```bash
   bun run generate
   ```
   このコマンドは`drizzle-kit generate`を実行し、`drizzle`ディレクトリにマイグレーションファイルを生成します

3. **ローカル環境へのマイグレーション適用**：
   ```bash
   bun run migrate:local
   ```
   このコマンドは`wrangler d1 migrations apply kirinuki-playlist --local`を実行し、マイグレーションをローカル開発環境のD1データベースに適用します

4. **リモート環境へのマイグレーション適用**（必要な場合）：
   ```bash
   bun run migrate:remote
   ```
   このコマンドは`wrangler d1 migrations apply kirinuki-playlist --remote`を実行し、マイグレーションをリモート（本番/ステージング）環境のD1データベースに適用します

### 重要な注意点

- **Drizzle-kitとCloudflare D1の関係**：`drizzle-kit migrate`コマンドはマイグレーションファイルを生成・管理しますが、Cloudflare D1データベースに直接マイグレーションを適用する機能は持っていません。必ず`wrangler d1 migrations apply`コマンドを使用して適用してください。

- **マイグレーション適用の確認**：エラー「no such table: XXX」が発生した場合は、マイグレーションが適用されていない可能性があります。その場合は`bun run migrate:local`を実行してください。

- **既存テーブルの確認**：現在のデータベースの状態を確認するには以下のコマンドを使用します：
  ```bash
  bunx wrangler d1 execute kirinuki-playlist --local --command="SELECT name FROM sqlite_master WHERE type='table'"
  ```

- **特定のSQLの実行**：特定のSQLを直接実行する場合は以下のようにします：
  ```bash
  bunx wrangler d1 execute kirinuki-playlist --local --file=path/to/sql/file.sql
  ```

## データベース操作

- Drizzle ORMを使用
- トランザクションの適切な使用
- クエリの最適化
- マイグレーション管理

```typescript
// config/database.ts
export const createDbClient = (db: D1Database) => {
  return drizzle(db);
};
```

## リレーションシップの処理

### モデル定義

- リレーションシップを持つテーブルは外部キー制約を明示的に定義する
- 関連するモデル間の型定義は一貫性を保つ
- 親子関係のあるモデルは適切な命名規則に従う

```typescript
// models/videos.ts
export const videos = sqliteTable(
  "videos",
  {
    id: text("id").primaryKey(),
    title: text("title").notNull(),
    // ...
    authorId: text("author_id").notNull().references(() => authors.id),
  }
);
```

### サービス層での実装

- 関連エンティティの存在確認を必ず行う
- 外部キー制約違反を防ぐためのバリデーションを実装する
- JOIN操作を使用して関連データを効率的に取得する
- 関連エンティティの情報を含むレスポンス型を定義する

```typescript
// services/videos.ts
async getVideoById(db: D1Database, id: string): Promise<Video> {
  const client = createDbClient(db);
  try {
    // JOIN操作を使用して著者情報も取得
    const result = await client
      .select({
        video: videos,
        author: authors,
      })
      .from(videos)
      .innerJoin(authors, eq(videos.authorId, authors.id))
      .where(eq(videos.id, id))
      .get();

    if (!result) {
      throw new NotFoundError(`ID: ${id} の動画が見つかりません`);
    }

    // 結果を適切な形式に変換
    return {
      id: result.video.id,
      title: result.video.title,
      // ...他のビデオフィールド
      authorId: result.video.authorId,
      author: {
        id: result.author.id,
        name: result.author.name,
        // ...他の著者フィールド
      },
    };
  } catch (error) {
    // エラーハンドリング
  }
}
```

### データ作成・更新時の検証

- 関連エンティティの存在確認を行ってから操作を実行する
- 外部キー制約違反を適切にハンドリングする
- 関連エンティティの更新時は整合性を保つ

```typescript
async createVideo(db: D1Database, data: VideoInsert): Promise<string> {
  const client = createDbClient(db);

  try {
    // 著者が存在するか確認
    const author = await client.select().from(authors).where(eq(authors.id, data.authorId)).get();
    if (!author) {
      throw new NotFoundError(`ID: ${data.authorId} の著者が見つかりません`);
    }

    // データベースに挿入
    // ...
  } catch (error) {
    // エラーハンドリング
  }
}
```

### トラブルシューティング

- **テーブルが存在しないエラー**：「no such table: XXX」というエラーが発生した場合、マイグレーションが適用されていません。`bun run migrate:local`を実行してください。

- **マイグレーション適用エラー**：「table already exists」というエラーが発生した場合、マイグレーションの一部だけが適用されている可能性があります。特定のマイグレーションファイルを直接実行することで解決できます：
  ```bash
  bunx wrangler d1 execute kirinuki-playlist --local --file=drizzle/XXXX_migration_name.sql
  ```

これらのガイドラインに従うことで、Cloudflare D1データベースの管理とマイグレーションをスムーズに行うことができます。
